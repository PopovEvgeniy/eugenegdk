<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=us-ascii">
    <title>Programmer Reference</title>
  </head>
  <body>
    <div align="center"><big>Eugene game development kit: Programmer Reference</big><br>
    </div>
    <big><br>
      <br>
    </big>
    <ol id="mozToc">
      <!--mozToc h1 1 h2 2 h3 3 h4 4 h5 5 h6 6-->
      <li><a href="#mozTocId368114">Part 1. Welcome to Eugene game development
          kit</a>
        <ol>
          <li><a href="#mozTocId929677">Chapter 1. Introduction</a></li>
          <li><a href="#mozTocId619515">Chapter 2. A special thanks</a></li>
          <li><a href="#mozTocId591463">Chapter 3. License</a></li>
          <li><a href="#mozTocId414200">Chapter 4. System requirements</a></li>
          <li><a href="#mozTocId190862">Chapter 5. Troubleshooting Guide</a></li>
          <li><a href="#mozTocId437883">Chapter 6. Compilers</a></li>
          <li><a href="#mozTocId832725">Chapter 7. Platform-specific notes</a></li>
          <li><a href="#mozTocId93850">Chapter 8. The engine namespace</a></li>
          <li><a href="#mozTocId650219">Chapter 9. Custom data types</a></li>
        </ol>
      </li>
      <li><a href="#mozTocId390952">Part 2. Base things</a>
        <ol>
          <li><a href="#mozTocId620810">Chapter 1. Coordinate system</a></li>
          <li><a href="#mozTocId977477">Chapter 2. Game loop</a></li>
        </ol>
      </li>
      <li><a href="#mozTocId775315">Part 3. Graphics</a>
        <ol>
          <li><a href="#mozTocId660835">Chapter 1. The sub-namespace</a></li>
          <li><a href="#mozTocId42831">Chapter 2. Base graphics subsystem</a></li>
          <li><a href="#mozTocId579031">Chapter 3. Picture subsystem</a></li>
          <li><a href="#mozTocId377293">Chapter 4. Animation subsystem</a></li>
          <li><a href="#mozTocId223691">Chapter 5. Vertex index</a></li>
          <li><a href="#mozTocId293242">Chapter 6. Image kind</a></li>
          <li><a href="#mozTocId901350">Chapter 7. Background</a></li>
          <li><a href="#mozTocId85917">Chapter 8. Static background</a></li>
          <li><a href="#mozTocId440826">Chapter 9. Parallax</a></li>
          <li><a href="#mozTocId344141">Chapter 10. Base sprite subsystem</a></li>
          <li><a href="#mozTocId805483">Chapter 11. Ordinary sprites</a></li>
          <li><a href="#mozTocId425033">Chapter 12. Static sprites</a></li>
          <li><a href="#mozTocId825989">Chapter 13. Sprite sheet</a></li>
          <li><a href="#mozTocId890973">Chapter 14. Text</a></li>
          <li><a href="#mozTocId739937">Chapter 15. Loading images</a></li>
          <li><a href="#mozTocId615578">Chapter 16. Camera</a></li>
        </ol>
      </li>
      <li><a href="#mozTocId311940">Part 4. Transformation</a>
        <ol>
          <li><a href="#mozTocId798362">Chapter 1. The sub-namespace</a></li>
          <li><a href="#mozTocId393371">Chapter 2. Cartesian coordinates and
              screen coordinates</a></li>
          <li><a href="#mozTocId877752">Chapter 3. Cartesian coordinates and
              isometric coordinates</a></li>
          <li><a href="#mozTocId955439">Chapter 4. Isometric level</a></li>
        </ol>
      </li>
      <li><a href="#mozTocId248663">Part 5. Common things</a>
        <ol>
          <li><a href="#mozTocId633183">Chapter 1. The sub-namespace</a></li>
          <li><a href="#mozTocId379038">Chapter 2. Abnormal program termination</a></li>
          <li><a href="#mozTocId566528">Chapter 3. Timer</a></li>
          <li><a href="#mozTocId908141">Chapter 4. Collision</a></li>
          <li><a href="#mozTocId539746">Chapter 5. Tile map</a></li>
        </ol>
      </li>
      <li><a href="#mozTocId181862">Part 6. Other important things</a>
        <ol>
          <li><a href="#mozTocId605872">Chapter 1. The sub-namespace</a></li>
          <li><a href="#mozTocId983926">Chapter 2. Memory</a></li>
          <li><a href="#mozTocId151935">Chapter 3. Audio</a></li>
        </ol>
      </li>
      <li><a href="#mozTocId1450">Part 7. Misc</a>
        <ol>
          <li><a href="#mozTocId336341">Chapter 1. File system</a></li>
          <li><a href="#mozTocId308918">Chapter 2. Tools</a></li>
          <li><a href="#mozTocId473447">Chapter 3. Resource Manager</a></li>
        </ol>
      </li>
      <li><a href="#mozTocId72710">Part 8. Binary files</a>
        <ol>
          <li><a href="#mozTocId706443">Chapter 1. The sub-namespace</a></li>
          <li><a href="#mozTocId168093">Chapter 2. Base binary file subsystem</a></li>
          <li><a href="#mozTocId575205">Chapter 3. File reader</a></li>
          <li><a href="#mozTocId140504">Chapter 4. File writer</a></li>
        </ol>
      </li>
      <li><a href="#mozTocId231501">Part 9. Input</a>
        <ol>
          <li><a href="#mozTocId524623">Chapter 1. The sub-namespace</a></li>
          <li><a href="#mozTocId621333">Chapter 2. Keyboard</a></li>
          <li><a href="#mozTocId829188">Chapter 3. Mouse</a></li>
          <li><a href="#mozTocId906897">Chapter 4. Gamepad</a></li>
        </ol>
      </li>
      <li><a href="#mozTocId768064">Part 10. Internal details of the engine
          subsystems</a>
        <ol>
          <li><a href="#mozTocId478780">Chapter 1. A few words for a curious
              programmer</a></li>
          <li><a href="#mozTocId5089">Chapter 2. Internal classes</a></li>
          <li><a href="#mozTocId856781">Chapter 3. Base graphics subsystem</a></li>
          <li><a href="#mozTocId625163">Chapter 4. Gamepad</a></li>
          <li><a href="#mozTocId25850">Chapter 5. Input</a></li>
          <li><a href="#mozTocId248668">Chapter 6. Audio</a></li>
        </ol>
      </li>
      <li><a href="#mozTocId928107">Version history</a></li>
    </ol>
    <h1><a id="mozTocId368114" class="mozTocH1"></a><big>Part 1. Welcome to
        Eugene game development kit</big></h1>
    <h2><a id="mozTocId929677" class="mozTocH2"></a><big>Chapter 1. Introduction</big></h2>
    <big><br>
      <u>Introduction</u><br>
      <br>
      Hello from Russia. My name is Popov Evgeniy Alekseyevich. I am the
      individual programmer. I enjoy creating software. I also like the
      old-school video games. Do you want to develop video games for
      Microsoft Windows? You need a good game engine to do it. I made my own
      engine. I hope that my C++ game engine will be useful for many
      programmers.<br>
      <br>
      <u>Features</u><br>
      <br>
      Let me show you the engine features. Let's go.<br>
      <br>
    </big>
    <ul>
      <li><big>Open-source code.</big></li>
      <li><big>Easy-to-use object-oriented design.</big></li>
      <li><big>Very fast.</big></li>
      <li><big>Minimum external dependencies: only <a href="https://learn.microsoft.com/en-us/windows/win32/directx">DirectX</a>,
          <a href="https://opengl.org">OPENGL</a>, and standard <a href="https://learn.microsoft.com/en-us/windows/win32/apiindex/windows-api-list">Windows
            API</a> libraries.</big></li>
      <li><big>You don't need to link a main program with the engine binary
          file. The engine is just the source code files.</big></li>
    </ul>
    <big><u><br>
        Installation</u><br>
      <br>
      How do I install this engine? Follow these steps:<br>
      <br>
      Copy these files to your project directory:<br>
      <br>
    </big>
    <ul>
      <li><big>eugenegdk.h</big></li>
      <li><big>eugenegdk.cpp</big></li>
    </ul>
    <big><br>
      Add it to your project.<br>
      Add this directive to your code: <i>#include "eugenegdk.h"</i><br>
      Yes. This is really all you need to do.<br>
    </big>
    <h2><a id="mozTocId619515" class="mozTocH2"></a><big>Chapter 2. A special
        thanks</big></h2>
    <big><br>
      I want to say «Big thanks for technical consultation» to these people:<br>
      <br>
    </big>
    <ul>
      <li><a href="https://github.com/dmitrysmagin"><big>Dmitry Smagin</big></a></li>
      <li><a href="https://bsg.org.ua"><big>Pavel Samko</big></a></li>
      <li><a href="https://github.com/EXL"><big>EXL</big></a></li>
      <li><a href="http://www.almost-university.com"><big>Vladimir Mozhenkov</big></a></li>
      <li><a href="https://vk.com/strong666"><big>Vitaliy Molochkov</big></a></li>
      <li><a href="mailto:eyegem@mail.ru"><big>Evgenia Germanova</big></a></li>
      <li><big>DDMZ</big></li>
      <li><big>Anastasiya</big></li>
    </ul>
    <big><br>
      Thanks to the PVS-Studio team for the <a href="https://www.viva64.com/en/b/0614/">free
        license</a>.<br>
    </big>
    <h2><a id="mozTocId591463" class="mozTocH2"></a><big>Chapter 3. License</big></h2>
    <big><br>
      <u>Eugene game development kit license</u><br>
      <br>
      Copyright (C) 2021 – 2025 Popov Evgeniy Alekseyevich<br>
      <br>
      This software is provided 'as–is', without any express or implied<br>
      warranty. In no event will the authors be held liable for any damages<br>
      arising from the use of this software.<br>
      Permission is granted to anyone to use this software for any purpose,<br>
      including commercial applications, and to alter it and redistribute it<br>
      freely, subject to the following restrictions:<br>
      1. The origin of this software must not be misrepresented; you must not<br>
      claim that you wrote the original software. If you use this software<br>
      in a product, an acknowledgment in the product documentation would be<br>
      appreciated but is not required.<br>
      2. Altered source versions must be plainly marked as such, and must not be<br>
      misrepresented as being the original software.<br>
      3. This notice may not be removed or altered from any source distribution.<br>
      <br>
      <u>Third–party license</u><br>
      <br>
      Copyright (c) 2007 – 2010 The Khronos Group Inc.<br>
      <br>
      Permission is hereby granted, free of charge, to any person obtaining a<br>
      copy of this software and/or associated documentation files (the<br>
      "Materials"), to deal in the Materials without restriction, including<br>
      without limitation the rights to use, copy, modify, merge, publish,<br>
      distribute, sublicense, and/or sell copies of the Materials, and to<br>
      permit persons to whom the Materials are furnished to do so, subject to<br>
      the following conditions:<br>
      The above copyright notice and this permission notice shall be included<br>
      in all copies or substantial portions of the Materials.<br>
      THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
      IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
      CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
      TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
      MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.<br>
    </big>
    <h2><a id="mozTocId414200" class="mozTocH2"></a><big>Chapter 4. System
        requirements</big></h2>
    <big><br>
      You can see the minimum system requirements below.<br>
      <br>
    </big>
    <table border="1">
      <tbody>
        <tr>
          <td><big>Operating system</big></td>
          <td><big>Windows XP or higher</big></td>
        </tr>
        <tr>
          <td><big>Minimum color depth</big></td>
          <td><big>16 bits</big></td>
        </tr>
        <tr>
          <td><big>Sound card</big></td>
          <td><big>Any sound card</big></td>
        </tr>
        <tr>
          <td colspan="1" rowspan="2"><big>Processor</big></td>
          <td><big>Intel Pentium II 400 MHz for 32-bit systems</big></td>
        </tr>
        <tr>
          <td><big>Intel Core 2 Duo for 64-bit systems</big></td>
        </tr>
      </tbody>
    </table>
    <big><br>
    </big>
    <h2><a id="mozTocId190862" class="mozTocH2"></a><big>Chapter 5.
        Troubleshooting Guide</big></h2>
    <big><br>
      You need <a href="https://support.microsoft.com/en-us/help/2977003/the-latest-supported-visual-c-downloads">Visual
        C++ Redistributable</a> packages if your game code is compiled under Visual C++.<br>
    </big>
    <h2><a id="mozTocId437883" class="mozTocH2"></a><big>Chapter 6. Compilers</big></h2>
    <big><br>
      This engine was successfully tested with these compilers:<br>
      <br>
    </big>
    <ul>
      <li><a href="https://jmeubank.github.io/tdm-gcc/"><big>TDM-GCC</big></a></li>
      <li><a href="http://mingw-w64.org"><big>MINGW-w64</big></a></li>
      <li><a href="http://openwatcom.org"><big>Open Watcom</big></a></li>
      <li><a href="https://open-watcom.github.io"><big>Open Watcom V2 Fork</big></a></li>
      <li><big>Visual C++ 2003</big></li>
      <li><big>Visual C++ 2005</big></li>
      <li><big>Visual C++ 2008</big></li>
      <li><big>Visual C++ 2010</big></li>
      <li><big>Visual C++ 2012</big></li>
      <li><big>Visual C++ 2013</big></li>
      <li><big>Visual C++ 2015</big></li>
      <li><big>Visual C++ 2017</big></li>
      <li><big>Visual C++ 2019</big></li>
      <li><big>Visual C++ 2022</big></li>
      <li><big>C++ Builder 2010</big></li>
      <li><big>C++ Builder XE</big></li>
      <li><big>C++ Builder XE2</big></li>
      <li><big>C++ Builder XE3</big></li>
      <li><big>C++ Builder XE4</big></li>
      <li><big>C++ Builder XE5</big></li>
      <li><big>C++ Builder XE6</big></li>
      <li><big>C++ Builder XE7</big></li>
      <li><big>C++ Builder XE8</big></li>
      <li><big>C++ Builder 10 Seattle</big></li>
      <li><big>C++ Builder 10.1 Berlin</big></li>
      <li><big>C++ Builder 10.2 Tokyo</big></li>
      <li><big>C++ Builder 10.3 Rio</big></li>
      <li><big>C++ Builder 10.4 Sydney</big></li>
      <li><big>C++ Builder 11 Alexandria</big></li>
    </ul>
    <h2><a id="mozTocId832725" class="mozTocH2"></a><big>Chapter 7.
        Platform-specific notes</big></h2>
    <big><u><br>
        The old processors support<br>
      </u><br>
      You need one of the following compilers for the old processors support:<br>
      <br>
    </big>
    <ul>
      <li><big>Open Watcom</big></li>
      <li><big>Open Watcom V2 Fork</big></li>
      <li><big>Visual C++ 2003</big></li>
      <li><big>Visual C++ 2005</big></li>
    </ul>
    <big><br>
      <u>Windows XP support</u><br>
      <br>
      You need one of the following compilers for <a href="https://en.wikipedia.org/wiki/Windows_XP">Windows
        XP</a> support:<br>
      <br>
    </big>
    <ul>
      <li><big>TDM–GCC</big></li>
      <li><big>Open Watcom</big></li>
      <li><big>Open Watcom V2 Fork</big></li>
      <li><big>Visual C++ 2003</big></li>
      <li><big>Visual C++ 2005</big></li>
      <li><big>Visual C++ 2008</big></li>
    </ul>
    <big><u><br>
        Windows SDK and DirectX SDK</u><br>
      <br>
      You need <a href="https://www.microsoft.com/en-us/download/details.aspx?id=15656">Windows
        Server 2003 SP1 Platform SDK</a> and <a href="https://archive.org/details/dxsdk_feb2005">DirectX
        SDK February 2005</a> if you are using Visual C++ 2005 Express.<br>
      <u><br>
        Notes for Visual C++ users</u><br>
      <br>
      Disable precompiled headers before starting compilation. Old Visual C++
      users can do it via the project creation wizard.<br>
      Visual C++ 2017 or higher users must follow these steps:<br>
      <br>
      Go to «Project Properties — C/C++ — Precompiled Headers»<br>
      Set the «Precomiled Header» option to «Not Using Precompiled Headers».<br>
      <br>
      <u>Notes for MINGW-w64 and TDM-GCC users</u><br>
      <br>
      Don't forget to link your program with these files:<br>
      <br>
    </big>
    <ul>
      <li><big>user32.lib</big></li>
      <li><big>kernel32.lib</big></li>
      <li><big>gdi32.lib</big></li>
      <li><big>opengl32.lib</big></li>
      <li><big>ole32.lib</big></li>
      <li><big>strmiids.lib</big></li>
      <li><big>winmm.lib</big></li>
    </ul>
    <big><br>
      See the documentation of the compiler for more information about linking.<br>
    </big>
    <h2><a id="mozTocId93850" class="mozTocH2"></a><big>Chapter 8. The engine
        namespace</big></h2>
    <big><br>
      <i>EUGENEGDK</i> is the main namespace. All the engine classes are
      declared in a few nested namespaces.<br>
    </big>
    <h2><a id="mozTocId650219" class="mozTocH2"></a><big>Chapter 9. Custom data
        types</big></h2>
    <big><br>
      Almost all custom data types are declared in the <i>EUGENEGDK</i>
      namespace.<br>
    </big>
    <h1><a id="mozTocId390952" class="mozTocH1"></a><big>Part 2. Base things</big></h1>
    <h2><a id="mozTocId620810" class="mozTocH2"></a><big>Chapter 1. Coordinate
        system</big></h2>
    <big><br>
      The engine uses the standard coordinate system by default. The
      coordinates start at the top-left corner. Look at this picture to
      understand it.<br>
      <br>
      <img alt="" src="coordinate_system.png" height="111" width="107"><br>
    </big>
    <h2><a id="mozTocId977477" class="mozTocH2"></a><big>Chapter 2. Game loop</big></h2>
    <big><br>
      What is the main point in your game? A game loop. You can see the
      structure of a typical game loop below.<br>
      <br>
      <img alt="" src="game_loop.png" height="354" width="379"><br>
      <br>
    </big>
    <h1><a id="mozTocId775315" class="mozTocH1"></a><big>Part 3. Graphics</big></h1>
    <h2><a id="mozTocId660835" class="mozTocH2"></a><big>Chapter 1. The
        sub-namespace</big></h2>
    <big><br>
      All classes in this section are declared in the <i>Graphics</i>
      sub-namespace.<br>
    </big>
    <h2><a id="mozTocId42831" class="mozTocH2"></a><big>Chapter 2. Base graphics
        subsystem</big></h2>
    <big><br>
      <u>Introduce</u><br>
      <br>
      The base graphics subsystem does render a game scene. This subsystem uses
      <a href="http://opengl.org">OPENGL</a> for rendering. All modern video cards support hardware-accelerated
      OPENGL. The software OPENGL will be activated if the acceleration is
      not available.<br>
      <br>
      <u>Render performance</u><br>
      <br>
      Always use the latest video card drivers. It may increase rendering
      performance. You can also try to change the screen resolution if you
      have low rendering performance.<br>
      <br>
      <u>FPS limitation</u><br>
      <br>
      FPS is an important thing. Many FPS are needed for good animation, but
      it also needs high processor usage. The FPS limit is 60 by default. It
      has an ideal value.<br>
      <br>
      <u>Work with the base graphics subsystem</u><br>
      <br>
      The <i>Screen</i> class provides access to the base graphics subsystem.
      Let's look at the publicly available methods.<br>
      <br>
      <i>void Screen::clear_screen(); -</i> Clear the screen. Fill it with black color.<br>
      <br>
      <i>void Screen::initialize(); -</i> Initialize the base graphic subsystem
      with the default screen resolution.<br>
      <i><br>
        void Screen::initialize(const unsigned int width, const unsigned int
        height); -</i> Initialize the base graphic subsystem with the custom
      screen resolution.<br>
      <br>
      <i>bool Screen::sync(); -</i> Show the current content of the back
      buffer on the screen. Return false if a game is terminated. This method
      uses the FPS limits and waits between frames.<br>
      <br>
      <i>bool Screen::update(); -</i> Show the current content of the back
      buffer on the screen. Return false if a game is terminated. This method
      ignores the FPS limit and needs high processor usage.<br>
      <i><br>
        bool Screen::sync(const bool limit); </i>- Show the current content of
      the back buffer on the screen. Return false if a game is terminated.<br>
      <i><br>
        bool Screen::is_ready(); -</i> Return true if the subsystem has already
      been initialized.<br>
      <br>
      <i>bool Screen::is_accelerated() const; -</i> Return true if the render is
      hardware-accelerated.<br>
      <br>
      <i>bool Screen::is_software() const; -</i> Return true if the software
      render is active.<br>
      <br>
      <i>unsigned int Screen::get_fps() const; -</i> Return the current FPS
      value.<br>
      <i><br>
        unsigned int Screen::get_color() const; -</i> Return the current color
      depth in bits per pixel.<br>
      <br>
      <i>unsigned int Screen::get_width() const; -</i> Return the screen width
      in pixels.<br>
      <i><br>
        unsigned int Screen::get_height() const; -</i> Return the screen height
      in pixels.<br>
      <i><br>
        unsigned int Screen::get_rate() const; -</i> Return the screen refresh rate.<br>
      <i><br>
        bool Screen::check_x(const unsigned int x) const; -</i> Return true if
      the x-coordinate is valid.<br>
      <br>
      <i>bool Screen::check_y(const unsigned int y) const; -</i> Return true if
      the y-coordinate is valid.<br>
      <br>
      <i>bool Screen::check_horizontal_border(const EUGENEGDK::BOX target)
        const; -</i> Return true if a game object has collided with the
      horizontal screen border.<br>
      <br>
      <i>bool Screen::check_vertical_border(const EUGENEGDK::BOX target) const;
        -</i> Return true if a game object has collided with the vertical screen
      border.<br>
      <br>
      <i>Screen *Screen::get_handle(); -</i> Return the handle to the base
      graphics subsystem object.<br>
    </big>
    <h2><a id="mozTocId579031" class="mozTocH2"></a><big>Chapter 3. Picture
        subsystem</big></h2>
    <big><u><br>
        An important subsystem</u><br>
      <br>
      The picture subsystem implements image storage.<br>
      <u><br>
        Work with the picture subsystem</u><br>
      <br>
      The <i>Picture</i> class provides simple access to the picture subsystem.
      Don't use it directly. Let's look at the publicly available methods.<br>
      <i><br>
        unsigned int *Picture::get_image(); -</i> Return the handle to the image storage.<br>
      <i><br>
        void Picture::destroy_image(); -</i> Destroy an image in the storage.<br>
      <i><br>
        bool Picture::is_storage_empty() const; -</i> Return true if the storage
      is empty.<br>
      <i><br>
        unsigned int Picture::get_image_width() const; -</i> Return the image
      width in pixels.<br>
      <br>
      <i>unsigned int Picture::get_image_height() const; -</i> Return the image
      height in pixels.<br>
      <i><br>
        size_t Picture::get_pixel_amount() const; -</i> Return the amount of the
      image pixels.<br>
      <br>
      <i>size_t Picture::get_image_lenght() const; -</i> Return the image length
      in bytes.<br>
    </big>
    <h2><a id="mozTocId377293" class="mozTocH2"></a><big>Chapter 4. Animation
        subsystem</big></h2>
    <big><u><br>
        An important subsystem</u><br>
      <br>
      The animation subsystem lets you control the animation frames.<br>
      <u><br>
        Frame indexing</u><br>
      <br>
      The first frame index is 1.<br>
      <br>
      <u>Work with the animation subsystem</u><br>
      <br>
      The <i>Animation</i> class provides simple access to the animation
      subsystem. Don't use it directly. Let's look at the publicly available
      methods.<br>
      <br>
      <i>unsigned int Animation::get_frames() const; -</i> Return the number of
      the frames.<br>
      <i><br>
        unsigned int Animation::get_frame() const; -</i> Return the current
      frame.<br>
      <br>
      <i>bool Animation::is_last_frame() const; -</i> Return true if the current
      frame is the last frame.<br>
      <br>
      <i>bool Animation::check_frame(const unsigned int target) const; -</i>
      Return true if the target frame is valid.<br>
      <br>
    </big>
    <h2><a id="mozTocId223691" class="mozTocH2"></a><big>Chapter 5. Vertex index</big></h2>
    <big><br>
      The vertex index looks like the predefined constants. You can see it
      below.<br>
      <br>
    </big>
    <table style="width: 358px; height: 139px;" border="1">
      <tbody>
        <tr>
          <td><big>Vertex index<br>
            </big></td>
          <td><big>Description</big></td>
        </tr>
        <tr>
          <td><big>FIRST_VERTEX<br>
            </big></td>
          <td><big>The first vertex<br>
            </big></td>
        </tr>
        <tr>
          <td><big>SECOND_VERTEX</big></td>
          <td><big>The second vertex<br>
            </big></td>
        </tr>
        <tr>
          <td style="vertical-align: top;"><big>THIRD_VERTEX</big></td>
          <td style="vertical-align: top;"><big>The third vertex<br>
            </big></td>
        </tr>
        <tr>
          <td style="vertical-align: top;"><big>LAST_VERTEX</big></td>
          <td style="vertical-align: top;"><big>The last vertex</big></td>
        </tr>
      </tbody>
    </table>
    <big><br>
    </big>
    <h2><a id="mozTocId293242" class="mozTocH2"></a><big>Chapter 6. Image kind</big></h2>
    <big><br>
      The image types look like the predefined constants. You can see it below.<br>
      <br>
    </big>
    <table style="width: 723px; height: 106px;" border="1">
      <tbody>
        <tr>
          <td><big>Image kind<br>
            </big></td>
          <td><big>Description</big></td>
        </tr>
        <tr>
          <td><big>HORIZONTAL_ANIMATED</big></td>
          <td><big>The horizontal animated background or the horizontal strip</big></td>
        </tr>
        <tr>
          <td><big>VERTICAL_ANIMATED</big></td>
          <td><big>The vertical animated background or the vertical strip</big></td>
        </tr>
      </tbody>
    </table>
    <big><br>
    </big>
    <h2><a id="mozTocId901350" class="mozTocH2"></a><big>Chapter 7. Background</big></h2>
    <big><br>
      <u>Level decoration</u><br>
      <br>
      A background is a big image with a few frames. Any game has a
      background. The background will be stretched to the screen resolution
      before rendering the game scene. The background transparency is always
      disabled.<br>
      <br>
      The horizontal animated backgrounds look like the horizontal photo
      ribbons. The vertical animated backgrounds look like the vertical photo
      ribbons.<br>
      <br>
      <u>Work with the background</u><br>
      <br>
      Just use the <i>Background</i> class to work with the background. Let's
      look at the publicly available methods.<br>
      <br>
      <i>Background *Background::get_handle(); -</i> Return the handle to the
      background object.<br>
      <br>
      <i>void Background::prepare(const Screen *screen); -</i> Prepare for drawing.<br>
      <i><br>
        void Background::prepare(Screen &amp;screen); -</i> Prepare for drawing.<br>
      <i><br>
        void Background::prepare(const unsigned int width, const unsigned int
        height); -</i> Prepare for drawing.<br>
      <br>
      <i>void Background::disable_mirror(); -</i> Disable background mirroring
      mode.<br>
      <i><br>
        void Background::horizontal_mirror(); -</i> Set horizontal background
      mirroring mode.<br>
      <br>
      <i>void Background::vertical_mirror(); -</i> Set vertical background
      mirroring mode.<br>
      <br>
      <i>void Background::complex_mirror(); -</i> Set both horizontal and
      vertical background mirroring modes.<br>
      <br>
      <i>void Background::set_target(const unsigned int target); -</i> Set the
      target frame.<br>
      <br>
      <i>void Background::step(); -</i> Increase the target frame. Set it to 1
      if the target is more than the number of frames.<br>
      <br>
      <i>void Background::set_settings(const EUGENEGDK::IMAGE_KIND kind, const
        unsigned int frames); -</i> Set the background settings.<br>
      <br>
      <i>void Background::load(Image *background,const EUGENEGDK::IMAGE_KIND
        kind, const unsigned int frames); -</i> Load a background from the
      buffer.<br>
      <br>
      <i>void Background::load(Image &amp;background,const EUGENEGDK::IMAGE_KIND
        kind, const unsigned int frames); -</i> Load a background from the
      buffer.<br>
      <br>
      <i>void Background::load(const char *name,const EUGENEGDK::IMAGE_KIND
        kind, const unsigned int frames); -</i> Load a background from the
      target file.<br>
      <i><br>
        void Background::draw(); -</i> Draw a background.<br>
      <br>
      <i>void Background::draw(const unsigned int target); -</i> Draw the target frame.<br>
      <i><br>
        void Background::destroy_image(); -</i> Destroy a background image.<br>
      <br>
      <i>void Background::destroy(); -</i> Destroy a background image and the
      texture.<br>
      <br>
      <i>bool Background::is_load() const; -</i> Return true if a background has
      already been loaded.<br>
      <br>
      <i>bool Background::is_last_frame() const; -</i> Return true if the
      current frame is the last frame.<br>
      <br>
      <i>bool Background::check_frame(const unsigned int target) const; -</i>
      Return true if the target frame is valid.<br>
      <br>
      <i>unsigned int Background::get_frame() const; -</i> Return the current frame.<br>
      <i><br>
        unsigned int Background::get_frames() const; -</i> Return the number of
      the frames.<br>
      <i><br>
        unsigned int Background::get_width() const; -</i> Return the width of
      the background.<br>
      <i><br>
        unsigned int Background::get_height() const; -</i> Return the height of
      the background.<br>
      <i><br>
        EUGENEGDK::IMAGE_KIND Background::get_kind() const; -</i> Get the
      background kind.<br>
      <br>
      <u>A background texture</u><br>
      <br>
      The background doesn't draw if the background texture doesn't exist. It
      will automatically be created when you load an image.<br>
      <br>
      Important notice<br>
      <br>
      Always call the <i>prepare</i> after the background has been loaded.<br>
    </big>
    <h2><a id="mozTocId85917" class="mozTocH2"></a><big>Chapter 8. Static
        background</big></h2>
    <big><u><br>
        A few words about static background</u><br>
      <br>
      The static background is a simple kind of background. It contains one
      frame only.<br>
      <u><br>
        Work with the background</u><br>
      <br>
      Just use the <i>Scene</i> class to work with the static background. Let's
      look at the publicly available methods.<br>
      <br>
      <i>Scene *Scene::get_handle(); -</i> Return the handle to the background object.<br>
      <i><br>
        void Scene::prepare(const Screen *screen); -</i> Prepare for drawing.<br>
      <br>
      <i>void Scene::prepare(Screen &amp;screen); -</i> Prepare for drawing.<br>
      <br>
      <i>void Scene::prepare(const unsigned int width, const unsigned int
        height); -</i> Prepare for drawing.<br>
      <br>
      <i>void Scene::disable_mirror(); -</i> Disable background mirroring mode.<br>
      <br>
      <i>void Scene::horizontal_mirror(); -</i> Set horizontal background
      mirroring mode.<br>
      <i><br>
        void Scene::vertical_mirror(); -</i> Set vertical background mirroring
      mode.<br>
      <br>
      <i>void Scene::complex_mirror(); -</i> Set both horizontal and vertical
      background mirroring modes.<br>
      <br>
      <i>void Scene::load(Image *background); -</i> Load a background from the
      buffer.<br>
      <br>
      <i>void Scene::load(Image &amp; background); -</i> Load a background from
      the buffer.<br>
      <br>
      <i>void Scene::load(const char *name); -</i> Load a background from the
      target file.<br>
      <br>
      <i>void Scene::draw(); -</i> Draw a background.<br>
      <br>
      <i>void Scene::destroy_image(); -</i> Destroy a background image.<br>
      <br>
      <i>void Scene::destroy(); -</i> Destroy a background image and destroy the
      texture.<br>
      <br>
      <i>bool Scene::is_load() const; -</i> Return true if a static background
      has already been loaded.<br>
      <br>
      <i>unsigned int Scene::get_width() const; -</i> Return the width of the
      background.<br>
      <i><br>
        unsigned int Scene::get_height() const; -</i> Return the height of the
      background.<br>
      <br>
      <u>A background texture</u><br>
      <br>
      The background doesn't draw if the background texture doesn't exist. It
      will automatically be created when you load an image.<br>
      <br>
      <u>Important notice</u><br>
      <br>
      Always call the <i>prepare</i> after the background has been loaded.<br>
    </big>
    <h2><a id="mozTocId440826" class="mozTocH2"></a><big>Chapter 9. Parallax</big></h2>
    <big><u><br>
        A few words about parallax</u><br>
      <br>
      The parallax background is a background with scrolling support.<br>
      <u><br>
        Speed</u><br>
      <br>
      The scrolling speed should be a positive number.<br>
      <br>
      <u>Work with the background</u><br>
      <br>
      Just use the <i>Parallax</i> class to work with the parallax background.
      Let's look at the publicly available methods.<br>
      <i><br>
        Parallax *Parallax::get_handle(); -</i> Return the handle to the
      background object.<br>
      <br>
      <i>void Parallax::prepare(const Screen *screen); -</i> Prepare for drawing.<br>
      <i><br>
        void Parallax::prepare(Screen &amp;screen); -</i> Prepare for drawing.<br>
      <i><br>
        void Parallax::prepare(const unsigned int width, const unsigned int
        height); -</i> Prepare for drawing.<br>
      <br>
      <i>void Parallax::disable_mirror(); -</i> Disable background mirroring mode.<br>
      <i><br>
        void Parallax::horizontal_mirror(); -</i> Set horizontal background
      mirroring mode.<br>
      <i><br>
        void Parallax::vertical_mirror(); -</i> Set vertical background
      mirroring mode.<br>
      <br>
      <i>void Parallax::complex_mirror(); -</i> Set both horizontal and vertical
      background mirroring modes.<br>
      <br>
      <i>void Parallax::load(Image *background); -</i> Load a background from
      the buffer.<br>
      <i><br>
        void Parallax::load(Image &amp; background); -</i> Load a background
      from the buffer.<br>
      <br>
      <i>void Parallax::load(const char *name); -</i> Load a background from the
      target file.<br>
      <br>
      <i>void Parallax::set_horizontal_speed(const float speed);
        -</i> Set the horizontal scrolling speed.<br>
      <br>
       <i>void Parallax::set_vertical_speed(const float speed);
        -</i> Set the vertical scrolling speed.<br>
      <br>
      <i>void Parallax::set_speed(const float horizontal,const float vertical);
        -</i> Set the scrolling speed.<br>
      <br>
      <i>float Parallax::get_horizontal_speed() const; -</i> Return the
      horizontal speed.<br>
      <i><br>
        float Parallax::get_vertical_speed() const; -</i> Return the vertical
      speed.<br>
      <br>
      <i>void Parallax::draw(); -</i> Draw a background.<br>
      <br>
      <i>void Parallax::destroy_image(); -</i> Destroy a background image.<br>
      <br>
      <i>void Parallax::destroy(); -</i> Destroy a background image and destroy the texture.<br>
      <br>
      <i>bool Parallax::is_load() const; -</i> Return true if a parallax
      background has already been loaded.<br>
      <br>
      <i>unsigned int Parallax::get_width() const; -</i> Return the width of the
      background.<br>
      <br>
      <i>unsigned int Parallax::get_height() const; -</i> Return the height of
      the background.<br>
      <u><br>
        A background texture</u><br>
      <br>
      The background doesn't draw if the background texture doesn't exist. It
      will automatically be created when you load an image.<br>
      <br>
      <u>Important notice</u><br>
      <br>
      Always call the <i>prepare</i> after the background has been loaded.<br>
    </big>
    <h2><a id="mozTocId344141" class="mozTocH2"></a><big>Chapter 10. Base sprite
        subsystem</big></h2>
    <big><u><br>
        A small, important thing</u><br>
      <br>
      A sprite is a transparent image. It is useful for many things: enemies,
      bonuses, etc.<br>
      <u><br>
        Work with the base sprite subsystem</u><br>
      <br>
      The <i>Billboard</i> class provides simple access to the base sprite
      subsystem. Don't use it directly. Let's look at the publicly available
      methods.<br>
      <br>
      <i>void Billboard::set_texture_coordinates(const EUGENEGDK::VERTEX_INDEX
        index, const float u, const float v); -</i> Set the texture coordinates.<br>
      <br>
      <i>void Billboard::set_transparent(const bool enabled); -</i> Enable or
      disable the transparent mode.<br>
      <br>
      <i>bool Billboard::get_transparent() const; -</i> Return true if the
      transparent mode is enabled.<br>
      <br>
      <i>void Billboard::set_position(const unsigned int x, const unsigned int
        y); -</i> Set the sprite position.<br>
      <br>
      <i>void Billboard::set_start(const unsigned int x, const unsigned int y);
        -</i> Set the start position of the sprite.<br>
      <br>
      <i>void Billboard::set_size(const unsigned int width, const unsigned int
        height); -</i> Change the sprite size.<br>
      <br>
      <i>void Billboard::set_x(const unsigned int x); -</i> Set the x-coordinate
      of the sprite position.<br>
      <br>
      <i>void Billboard::set_y(const unsigned int y); -</i> Set the y-coordinate
      of the sprite position.<br>
      <i><br>
        void Billboard::set_width(const unsigned int width); -</i> Change the
      sprite width.<br>
      <br>
      <i>void Billboard::set_height(const unsigned int height); -</i> Change the
      sprite height.<br>
      <br>
      <i>unsigned int Billboard::increase_x(); -</i> Increase the x-coordinate
      and return it.<br>
      <br>
      <i>unsigned int Billboard::decrease_x(); -</i> Decrease the x-coordinate
      and return it.<br>
      <br>
      <i>unsigned int Billboard::increase_y(); -</i> Increase the y-coordinate
      and return it.<br>
      <i><br>
        unsigned int Billboard::decrease_y(); -</i> Decrease the y-coordinate
      and return it.<br>
      <br>
      <i>unsigned int Billboard::increase_x(const unsigned int increment); -</i>
      Increase the x-coordinate with the user value and return it.<br>
      <br>
      <i>unsigned int Billboard::decrease_x(const unsigned int decrement); -</i>
      Decrease the x-coordinate with the user value and return it.<br>
      <br>
      <i>unsigned int Billboard::increase_y(const unsigned int increment); -</i>
      Increase the y-coordinate with the user value and return it.<br>
      <br>
      <i>unsigned int Billboard::decrease_y(const unsigned int decrement); -</i>
      Decrease the y-coordinate with the user value and return it.<br>
      <br>
      <i>unsigned int Billboard::get_start_x() const; -</i> Return the
      x-coordinate of the start position.<br>
      <br>
      <i>unsigned int Billboard::get_start_y() const; -</i> Return the
      y-coordinate of the start position.<br>
      <i><br>
        unsigned int Billboard::get_x() const; -</i> Return the x-coordinate of
      the sprite position.<br>
      <br>
      <i>unsigned int Billboard::get_y() const; -</i> Return the y-coordinate of
      the sprite position.<br>
      <br>
      <i>unsigned int Billboard::get_width() const; -</i> Return the width of
      the sprite.<br>
      <i><br>
        unsigned int Billboard::get_height() const; -</i> Return the height of
      the sprite.<br>
      <br>
      <i>bool Billboard::is_load() const; -</i> Return true if the sprite has
      already been loaded.<br>
      <i><br>
        EUGENEGDK::BOX Billboard::get_box() const; -</i> Return the
      collision-related information.<br>
      <br>
      <i>void Billboard::disable_mirror(); -</i> Disable sprite mirroring mode.<br>
      <br>
      <i>void Billboard::horizontal_mirror(); -</i> Set horizontal sprite
      mirroring mode.<br>
      <i><br>
        void Billboard::vertical_mirror(); -</i> Set vertical sprite mirroring
      mode.<br>
      <br>
      <i>void Billboard::complex_mirror(); -</i> Set both horizontal and
      vertical sprite mirroring modes.<br>
      <br>
      <i>void Billboard::go_start(); -</i> Set the sprite position to the start
      position.<br>
      <br>
      <i>void Billboard::go_start_x(); -</i> Set the x-coordinate of the sprite
      position to the x-coordinate of the start position.<br>
      <br>
      <i>void Billboard::go_start_y(); -</i> Set the y-coordinate of the sprite
      position to the y-coordinate of the start position.<br>
      <br>
      <i>void Billboard::draw(); -</i> Draw a sprite.<br>
      <br>
      <i>void Billboard::draw(const unsigned int x, const unsigned int y); -</i>
      Set the sprite position and draw it.<br>
      <br>
      <i>void Billboard::draw(const bool transparency); -</i> Set the
      transparent mode and draw a sprite.<br>
      <br>
      <i>void Billboard::draw(const bool transparency, const unsigned int x,
        const unsigned int y); -</i> Set the transparent mode and draw a sprite
      at the target position.<br>
    </big>
    <h2><a id="mozTocId805483" class="mozTocH2"></a><big>Chapter 11. Ordinary
        sprites</big></h2>
    <big><br>
      <u>Sprite types</u><br>
      <br>
      There are two kinds of ordinary sprites: the horizontal strips and the
      vertical strips. It is a small image with a few frames.<br>
      The horizontal strip looks like the horizontal photo ribbon. The vertical
      strip looks like the vertical photo ribbon.<br>
      <br>
      <u>Work with the sprites</u><br>
      <br>
      Just use the <i>Sprite</i> class to work with a sprite. It is derived
      from three classes: <i>Billboard</i>, <i>Animation</i>, and <i>Picture</i>.
      Let's look at the publicly available methods.<br>
      <br>
      <i>void Sprite::set_settings(const EUGENEGDK::IMAGE_KIND kind, const
        unsigned int frames); -</i> Set the sprite settings.<br>
      <br>
      <i>void Sprite::load(Image *buffer,const EUGENEGDK::IMAGE_KIND kind, const
        unsigned int frames); -</i> Load a sprite from the buffer.<br>
      <br>
      <i>void Sprite::load(Image &amp;buffer,const EUGENEGDK::IMAGE_KIND kind,
        const unsigned int frames); -</i> Load a sprite from the buffer.<br>
      <br>
      <i>void Sprite::load(const char *name,const EUGENEGDK::IMAGE_KIND kind,
        const unsigned int frames); -</i> Load a sprite from the target file.<br>
      <br>
      <i>void Sprite::set_target(const unsigned int target); </i>- Set the
      target frame.<br>
      <br>
      <i>void Sprite::step(); -</i> Increase the target frame. Set it to 1 if
      the target is more than the number of frames.<br>
      <br>
      <i>EUGENEGDK::IMAGE_KIND Sprite::get_kind() const; -</i> Get the sprite
      kind.<br>
      <i><br>
        Sprite *Sprite::get_handle(); -</i> Return the handle to the sprite
      object.<br>
      <i><br>
        void Sprite::clone(Sprite *target); -</i> Create a copy of the sprite if
      the storage of the target sprite is not empty.<br>
      <br>
      <i>void Sprite::clone(Sprite &amp;target); -</i> Create a copy of the
      sprite if the storage of the target sprite is not empty.<br>
      <br>
      <i>void Sprite::destroy(); -</i> Destroy a sprite image and destroy the
      texture.<br>
      <br>
      <u>A sprite texture</u><br>
      <br>
      A sprite doesn't draw if the sprite texture doesn't exist. It will
      automatically be created when you load or clone a sprite.<br>
    </big>
    <h2><a id="mozTocId425033" class="mozTocH2"></a><big>Chapter 12. Static
        sprites</big></h2>
    <big><u><br>
        A few words about static sprites</u><br>
      <br>
      The static sprite is a simple kind of sprite. It contains one frame only.<br>
      <u><br>
        Work with the static sprites</u><br>
      <br>
      Just use the <i>Cartoon</i> class to work with a static sprite. It is
      derived from two classes: billboard and picture. Let's look at the
      publicly available methods.<br>
      <br>
      <i>void Cartoon::load(Image *buffer); -</i> Load a sprite from the buffer.<br>
      <i><br>
        void Cartoon::load(Image &amp;buffer); -</i> Load a sprite from the
      buffer.<br>
      <br>
      <i>void Cartoon::load(const char *name); -</i> Load a sprite from the
      target file.<br>
      <br>
      <i>Cartoon *Cartoon::get_handle(); -</i> Return the handle to the sprite
      object.<br>
      <br>
      <i>void Cartoon::clone(Cartoon *target); -</i> Create a copy of the sprite
      if the storage of the target sprite is not empty.<br>
      <br>
      <i>void Cartoon::clone(Cartoon &amp;target); -</i> Create a copy of the
      sprite if the storage of the target sprite is not empty.<br>
      <br>
      <i>void Cartoon::destroy(); -</i> Destroy a sprite image and the texture.<br>
      <u><br>
        A sprite texture</u><br>
      <br>
      A sprite doesn't draw if the sprite texture doesn't exist. It will
      automatically be created when you load or clone a sprite.<br>
    </big>
    <h2><a id="mozTocId825989" class="mozTocH2"></a><big>Chapter 13. Sprite
        sheet</big></h2>
    <big><br>
      <u>Some words about a sprite sheet</u><br>
      <br>
      A sprite sheet is a special kind of animated sprite. Each frame has a
      fixed size. The sheet is a matrix of frames. Look at this picture to
      understand it.<br>
      <br>
      <img alt="" src="sheet.png" height="249" width="380"><br>
      <u><br>
        Rows and columns</u><br>
      <br>
      The first row index is 1. The first column index is 1.<br>
      <br>
      <u>Work with the sheet</u><br>
      <br>
      The <i>Sheet</i> class provides access to the sprite sheet subsystem. It
      is derived from three classes: <i>Billboard</i>, <i>Picture</i>, and <i>Animation</i>.
      Let's look at the publicly available methods.<br>
      <i><br>
        bool Sheet::check_row(const unsigned int target) const; -</i> Return
      true if the target row is valid.<br>
      <br>
      <i>bool Sheet::check_column(const unsigned int target) const; -</i> Return
      true if the target column is valid.<br>
      <i><br>
        unsigned int Sheet::get_row(const unsigned int target) const; -</i>
      Return row of the target frame.<br>
      <br>
      <i>unsigned int Sheet::get_column(const unsigned int target) const; -</i>
      Return column of the target frame.<br>
      <br>
      <i>unsigned int Sheet::calculate(const unsigned int row, const unsigned
        int column) const; -</i> Calculate the frame by row and column.<br>
      <br>
      <i>unsigned int Sheet::get_rows() const; -</i> Return the number of rows.<br>
      <br>
      <i>unsigned int Sheet::get_columns() const; -</i> Return the number of
      columns.<br>
      <br>
      <i>void Sheet::destroy(); -</i> Destroy a sprite sheet image and the
      texture.<br>
      <br>
      <i>void Sheet::select(const unsigned int row,const unsigned int column); -</i>
      Select the target frame by row and column.<br>
      <br>
      <i>void Sheet::set_target(const unsigned int target); -</i> Set the target
      frame.<br>
      <br>
      <i>void Sheet::step(); -</i> Increase the target frame. Set it to 1 if the
      target is more than the number of frames.<br>
      <br>
      <i>void Sheet::load(Image *sheet, const unsigned int row_amount, const
        unsigned int column_amount); -</i> Load a sprite sheet from the buffer.<br>
      <br>
      <i>void Sheet::load(Image &amp;sheet, const unsigned int row_amount, const
        unsigned int column_amount); -</i> Load a sprite sheet from the buffer.<br>
      <br>
      <i>void Sheet::load(const char *name, const unsigned int row_amount, const
        unsigned int column_amount); -</i> Load a sprite sheet from a target
      file.<br>
      <br>
      <i>Sheet *Sheet::get_handle(); -</i> Return the handle to the sprite
      sheet.<br>
      <i><br>
        void Sheet::clone(Sheet *target); -</i> Create a copy of the sprite
      sheet if the storage of the target sprite sheet is not empty.<br>
      <br>
      <i>void Sheet::clone(Sheet &amp;target); -</i> Create a copy of the sprite
      sheet if the storage of the target sprite sheet is not empty.<br>
      <br>
      <u>A sprite sheet texture</u><br>
      <br>
      A sprite sheet doesn't draw if the sprite sheet texture doesn't exist. It
      will automatically be created when you load a sheet.<br>
    </big>
    <h2><a id="mozTocId890973" class="mozTocH2"></a><big>Chapter 14. Text</big></h2>
    <big><br>
      <u>How do I draw a text?</u><br>
      <br>
      Just use the text subsystem to draw a text. This subsystem needs a font
      for text drawing. You must load a font before starting to draw the
      text. The font is just a sprite sheet with 16 rows and 16 columns.<br>
      <br>
      <u>Valid characters</u><br>
      <br>
      Only 8-bit characters are supported.<br>
      <br>
      <u>Text orientation</u><br>
      <br>
      The text orientation looks like the predefined constants. You can see it
      below.<br>
      <br>
    </big>
    <table border="1" height="85" width="443">
      <tbody>
        <tr>
          <td><big>Text orientation<br>
            </big></td>
          <td><big>Description</big></td>
        </tr>
        <tr>
          <td><big>HORIZONTAL_TEXT</big></td>
          <td><big>The horizontally oriented text<br>
            </big></td>
        </tr>
        <tr>
          <td><big>VERTICAL_TEXT</big></td>
          <td><big>The vertically oriented text</big></td>
        </tr>
      </tbody>
    </table>
    <big><br>
      <u>Work with the text</u><br>
      <br>
      The <i>Text</i> class provides a simple interface to the text subsystem.
      Let's look at the publicly available methods.<br>
      <br>
      <i>Text *Text::get_handle(); -</i> Return the handle to the text drawing subsystem.<br>
      <br>
      <i>EUGENEGDK::TEXT_KIND Text::get_orientation() const; -</i> Get the
      current text orientation.<br>
      <br>
      <i>void Text::set_orientation(const EUGENEGDK::TEXT_KIND target); -</i>
      Set the current text orientation.<br>
      <br>
      <i>bool Text::is_font_load() const; -</i> Return true if the font has
      already been loaded.<br>
      <br>
      <i>unsigned int Text::get_font_width() const; -</i> Get the current font
      width in pixels.<br>
      <br>
      <i>unsigned int Text::get_font_height() const; -</i> Get the current font
      height in pixels.<br>
      <i><br>
        unsigned int Text::get_x() const; -</i> Get the x-coordinate of the text
      output position.<br>
      <br>
      <i>unsigned int Text::get_y() const; -</i> Get the y-coordinate of the
      text output position.<br>
      <br>
      <i>void Text::set_position(const unsigned int x, const unsigned int y); -</i>
      Set the output position.<br>
      <i><br>
        void Text::set_size(const unsigned int width, const unsigned int
        height); -</i> Change the font size.<br>
      <i><br>
        void Text::set_width(const unsigned int width); -</i> Set the font width.<br>
      <br>
      <i>void Text::set_height(const unsigned int height); -</i> Set the font height.<br>
      <br>
      <i>void Text::set_settings(const unsigned int width, const unsigned int
        height, const EUGENEGDK::TEXT_KIND kind); -</i> Set the text output settings.<br>
      <i><br>
        void Text::load_font(Image *font); -</i> Load a font from the buffer.<br>
      <br>
      <i>void Text::load_font(Image &amp;font); -</i> Load a font from the buffer.<br>
      <i><br>
        void Text::load_font(const char *name); -</i> Load a font from the
      target file.<br>
      <br>
      <i>void Text::print(const char target); -</i> Draw a single character at
      the current position.<br>
      <i><br>
        void Text::print(const unsigned int x, const unsigned int y, const char
        target); -</i> Draw a single character at the specific position.<br>
      <br>
      <i>size_t Text::print(const char *target); -</i> Draw a text at the
      current position and return the text length.<br>
      <br>
      <i>size_t Text::print(const unsigned int x, const unsigned int y, const
        char *target); -</i> Draw a text at the specific position and return the
      text length.<br>
      <br>
      <i>void Text::disable_mirror(); -</i> Disable text mirroring mode.<br>
      <i><br>
        void Text::horizontal_mirror(); -</i> Set horizontal text mirroring mode.<br>
      <i><br>
        void Text::vertical_mirror(); -</i> Set vertical text mirroring mode.<br>
      <br>
      <i>void Text::complex_mirror(); -</i> Set both horizontal and vertical
      text mirroring modes.<br>
      <br>
      <i>void Text::destroy_image(); -</i> Destroy a font image.<br>
      <br>
      <i>void Text::destroy_font(); -</i> Destroy a font image and the texture.<br>
    </big>
    <h2><a id="mozTocId739937" class="mozTocH2"></a><big>Chapter 15. Loading
        images</big></h2>
    <big><u><br>
        Load an image from a file</u><br>
      <br>
      Use the image loader to load an image from a file. The <i>Image</i> class
      provides simple access to the image loader. It is a simple class with a
      few methods.<br>
      <br>
      <i>unsigned char *Image::load(const char *name); -</i> Load a Truevision
      TGA image and return the handle to the image buffer.<br>
      <i><br>
        unsigned char *Image::get_data(); -</i> Return the handle to the image
      buffer.<br>
      <i><br>
        unsigned int Image::get_width() const; -</i> Return the width of the
      current image.<br>
      <br>
      <i>unsigned int Image::get_height() const; -</i> Return the height of the
      current image.<br>
      <br>
      <i>size_t Image::get_length() const; -</i> Return the length of the image
      buffer in bytes.<br>
      <br>
      <i>Image *Image::get_handle(); -</i> Return the handle to the image
      loader.<br>
      <br>
      <i>void Image::destroy_image(); -</i> Destroy the current image and free
      the image buffer.<br>
      <br>
      <u>Important remark</u><br>
      <br>
      A new image will replace the current image if the current image already
      exists. An incorrect image will be ignored and won't load.<br>
      The source image will be converted to <a href="https://en.wikipedia.org/wiki/RGBA">RGBA</a>
      format. Pixels equal to the top-left pixel will be marked as transparent.<br>
      <u><br>
        Supported format</u><br>
      <br>
      All loading images must have the correct specifications. You can load an
      image from a 24-bit <a href="https://en.wikipedia.org/wiki/Truevision_TGA">Truevision TGA</a> picture.<br>
      <br>
      <u>Recommend software</u><br>
      <br>
      You can use a wide range of graphics software to convert your images to
      the correct format. I recommend using <a href="https://www.gimp.org">GIMP</a>
      to do it. It is a powerful image editor.<br>
    </big>
    <h2><a id="mozTocId615578" class="mozTocH2"></a><big>Chapter 16. Camera</big></h2>
    <big><br>
      <u>A few words about the camera</u><br>
      <br>
      The 2D camera defines the size of the visible area. It will be
      stretched to the screen resolution before rendering the game scene.<br>
      <br>
      <u>Work with the camera</u><br>
      <br>
      The <i>Camera</i> class provides simple access to the camera subsystem.
      Let's look at the publicly available methods.<br>
      <i><br>
        Camera *Camera::get_handle(); -</i> Return the handle to the camera subsystem.<br>
      <br>
      <i>unsigned int Camera::increase_x(); -</i> Increase the x-coordinate of
      the camera offset and return it.<br>
      <br>
      <i>unsigned int Camera::decrease_x(); -</i> Decrease the x-coordinate of
      the camera offset and return it.<br>
      <i><br>
        unsigned int Camera::increase_y(); -</i> Increase the y-coordinate of
      the camera offset and return it.<br>
      <i><br>
        unsigned int Camera::decrease_y(); -</i> Decrease the y-coordinate of
      the camera offset and return it.<br>
      <br>
      <i>unsigned int Camera::increase_x(const unsigned int increment); -</i>
      Increase the x-coordinate of the camera offset with the user value and
      return it.<br>
      <br>
      <i>unsigned int Camera::decrease_x(const unsigned int decrement); -</i>
      Decrease the x-coordinate of the camera offset with the user value and
      return it.<br>
      <i><br>
        unsigned int Camera::increase_y(const unsigned int increment); -</i>
      Increase the y-coordinate of the camera offset with the user value and
      return it.<br>
      <i><br>
        unsigned int Camera::decrease_y(const unsigned int decrement); -</i>
      Decrease the y-coordinate of the camera offset with the user value and
      return it.<br>
      <i><br>
        unsigned int Camera::get_x() const; -</i> Return the x-coordinate of the
      camera offset.<br>
      <i><br>
        unsigned int Camera::get_y() const; -</i> Return the y-coordinate of the
      camera offset.<br>
      <br>
      <i>unsigned int Camera::get_screen_width() const; -</i> Return the screen
      width in pixels.<br>
      <br>
      <i>unsigned int Camera::get_screen_height() const; -</i> Return the screen
      height in pixels.<br>
      <br>
      <i>unsigned int Camera::get_viewport_width() const; -</i> Return the
      viewport width in pixels.<br>
      <br>
      <i>unsigned int Camera::get_viewport_height() const; -</i> Return the
      viewport height in pixels.<br>
      <br>
      <i>unsigned int Camera::get_highest_x() const; -</i> Return the highest
      allowable x-coordinate of the current visible area.<br>
      <i><br>
        unsigned int Camera::get_highest_y() const; -</i> Return the highest
      allowable y-coordinate of the current visible area.<br>
      <i><br>
        unsigned int Camera::get_highest_x_offset() const; -</i> Return the
      highest allowable x-offset of the camera.<br>
      <i><br>
        unsigned int Camera::get_highest_y_offset() const; -</i> Return the
      highest allowable y-offset of the camera.<br>
      <i><br>
        unsigned int Camera::get_world_x(const unsigned screen_int x) const; -</i>
      Convert the screen x-coordinate to the world x-coordinate.<br>
      <br>
      <i>unsigned int Camera::get_world_y(const unsigned screen_int y) const; -</i>
      Convert the screen y-coordinate to the world y-coordinate.<br>
      <br>
      <i>unsigned int Camera::set_x(const unsigned int x); -</i> Set the
      x-coordinate of the camera offset and return it.<br>
      <br>
      <i>unsigned int Camera::set_y(const unsigned int y); -</i> Set the
      y-coordinate of the camera offset and return it.<br>
      <i><br>
        void Camera::initialize(const unsigned int width, const unsigned int
        height); -</i> Initialize the subsystem and set the screen size.<br>
      <i><br>
        void Camera::initialize(Screen *screen); -</i> Initialize the subsystem
      and set the screen size.<br>
      <br>
      <i>void Camera::initialize(Screen &amp;screen); -</i> Initialize the
      subsystem and set the screen size.<br>
      <br>
      <i>void Camera::set_viewport(const unsigned int width, const unsigned int
        height); -</i> Set the viewport settings.<br>
      <br>
      <i>void Camera::set_offset(const unsigned int x, const unsigned int y); -</i>
      Set the camera offset.<br>
      <br>
      <i>bool Camera::check_horizontal_border(const EUGENEGDK::BOX target)
        const; -</i> Return true if a game object has collided with the
      horizontal visible area border.<br>
      <i><br>
        bool Camera::check_vertical_border(const EUGENEGDK::BOX target) const; -</i>
      Return true if a game object has collided with the vertical visible area
      border.<br>
      <i><br>
        void Camera::update(); -</i> Update the camera.<br>
      <br>
      <i>void Camera::reset(); -</i> Reset the camera settings.<br>
      <br>
      <u>Important remark</u><br>
      <br>
      Always set the viewport size after initializing the camera. Always update
      the camera before drawing.<br>
    </big>
    <h1><a id="mozTocId311940" class="mozTocH1"></a><big>Part 4. Transformation</big></h1>
    <h2><a id="mozTocId798362" class="mozTocH2"></a><big>Chapter 1. The
        sub-namespace</big></h2>
    <big><br>
      All classes in this section are declared in the <i>Transformation</i>
      sub-namespace.<br>
    </big>
    <h2><a id="mozTocId393371" class="mozTocH2"></a><big>Chapter 2. Cartesian
        coordinates and screen coordinates</big></h2>
    <big><br>
      <u>Cartesian coordinates</u><br>
      <br>
      The Cartesian coordinates start at the center of the screen. Look at this
      picture to understand it.<br>
      <br>
      <img alt="" src="cartesian_system.png" height="111" width="107"><br>
      <br>
      <u>Coordinates conversion</u><br>
      <br>
      You can convert the Cartesian coordinates to the screen coordinates.
      You can also convert the screen coordinates to the Cartesian
      coordinates.<br>
      <br>
      Just use the <i>Coordinates</i> class to do it. Let's look at the
      publicly available methods.<br>
      <i><br>
        Coordinates *Coordinates::get_handle(); -</i> Return the handle to the
      coordinates conversion subsystem.<br>
      <br>
      <i>void Coordinates::initialize(const int viewport_width, const int
        viewport_height); -</i> Initialize the subsystem.<br>
      <br>
      <i>int Coordinates::get_viewport_width() const; -</i> Return the viewport
      width in pixels.<br>
      <br>
      <i>int Coordinates::get_viewport_height() const; -</i> Return the viewport
      height in pixels.<br>
      <br>
      <i>int Coordinates::get_lowest_cartesian_x() const; -</i> Return the
      lowest allowable Cartesian x-coordinate.<br>
      <br>
      <i>int Coordinates::get_highest_cartesian_x() const; -</i> Return the
      highest allowable Cartesian x-coordinate.<br>
      <i><br>
        int Coordinates::get_lowest_cartesian_y() const; -</i> Return the lowest
      allowable Cartesian y-coordinate.<br>
      <i><br>
        int Coordinates::get_highest_cartesian_y() const; -</i> Return the
      highest allowable Cartesian y-coordinate.<br>
      <br>
      <i>bool Coordinates::check_cartesian_x(const int x) const; -</i> Return
      true if the Cartesian x-coordinate is valid.<br>
      <br>
      <i>bool Coordinates::check_cartesian_y(const int y) const; -</i> Return
      true if the Cartesian y-coordinate is valid.<br>
      <i><br>
        int Coordinates::get_screen_x(const int x) const; -</i> Convert the
      Cartesian x-coordinate to the screen x-coordinate.<br>
      <br>
      <i>int Coordinates::get_screen_y(const int y) const; -</i> Convert the
      Cartesian y-coordinate to the screen y-coordinate.<br>
      <i><br>
        int Coordinates::get_cartesian_x(const int x) const; -</i> Convert the
      screen x-coordinate to the Cartesian x-coordinate.<br>
      <i><br>
        int Coordinates::get_cartesian_y(const int y) const; -</i> Convert the
      screen y-coordinate to the Cartesian y-coordinate.<br>
    </big>
    <h2><a id="mozTocId877752" class="mozTocH2"></a><big>Chapter 3. Cartesian
        coordinates and isometric coordinates</big></h2>
    <big><br>
      <u>A few words about isometric games</u><br>
      <br>
      <a href="https://en.wikipedia.org/wiki/Isometric_projection">Isometry</a>
      is a very popular way for pseudo-3D games. Many old-school games are
      isometric games.<br>
      <br>
      <u>Coordinates conversion</u><br>
      <br>
      You can convert the Cartesian coordinates to the isometric coordinates.
      You can also convert the isometric coordinates to the Cartesian
      coordinates. Just use the <i>Isometric</i> class to do it. Let's look at
      the publicly available methods.<br>
      <br>
      <i>static int Isometric::get_isometric_x(const int x, const int y); -</i>
      Convert the x-coordinate from the Cartesian system to the isometric
      system.<br>
      <br>
      <i>static int Isometric::get_isometric_y(const int x, const int y); -</i>
      Convert the y-coordinate from the Cartesian system to the isometric
      system.<br>
      <br>
      <i>static int Isometric::get_cartesian_x(const int x, const int y); -</i>
      Convert the x-coordinate from the isometric system to the Cartesian
      system.<br>
      <br>
      <i>static int Isometric::get_cartesian_y(const int x, const int y); -</i>
      Convert the y-coordinate from the isometric system to the Cartesian
      system.<br>
    </big>
    <h2><a id="mozTocId955439" class="mozTocH2"></a><big>Chapter 4. Isometric
        level</big></h2>
    <big><br>
      The isometric level subsystem is intended to help you create an isometric
      level. Just use the <i>Level</i> class to do it. Let's look at the
      publicly available methods.<br>
      <br>
      <i>Level *Level::get_handle(); -</i> Return the handle to the isometric
      level subsystem.<br>
      <br>
      <i>void Level::initialize(const int tile_width, const int tile_height); -</i>
      Initialize the subsystem.<br>
      <br>
      <i>void Level::set_offset(const int x_offset, const int y_offset); -</i>
      Set the coordinates offset.<br>
      <br>
      <i>int Level::get_x_offset() const; -</i> Return the x-offset.<br>
      <br>
      <i>int Level::get_y_offset() const; -</i> Return the y-offset.<br>
      <br>
      <i>int Level::get_x(const int row, const int column) const; -</i> Return
      the target x-coordinate.<br>
      <br>
      <i>int Level::get_y(const int row, const int column) const; -</i> Return
      the target y-coordinate.<br>
    </big>
    <h1><a id="mozTocId248663" class="mozTocH1"></a><big>Part 5. Common things</big></h1>
    <h2><a id="mozTocId633183" class="mozTocH2"></a><big>Chapter 1. The
        sub-namespace</big></h2>
    <big><br>
      All classes in this section are declared in the <i>Common</i>
      sub-namespace.<br>
    </big>
    <h2><a id="mozTocId379038" class="mozTocH2"></a><big>Chapter 2. Abnormal
        program termination</big></h2>
    <big><br>
      You can use the <i>Halt</i> function to terminate a program. This
      function is declared in the <i>EGENEGDK</i> namespace.<br>
      <i><br>
        void EUGENEGDK::Halt(const char *message); -</i> Terminate the program.
      Write an error message to the log file if logging is enabled.<br>
    </big>
    <h2><a id="mozTocId566528" class="mozTocH2"></a><big>Chapter 3. Timer</big></h2>
    <big><br>
      A timer is a very useful thing. Just use the <i>Timer</i> class to work
      with the timer. Let's look at the publicly available methods.<br>
      <i><br>
        Timer *Timer::get_handle(); -</i> Return the handle to the timer.<br>
      <br>
      <i>void Timer::set_timer(const double seconds); -</i> Set the timer
      interval and initialize the start point.<br>
      <i><br>
        double Timer::get_interval() const; -</i> Return the current timer
      interval.<br>
      <br>
      <i>bool Timer::check_timer(); -</i> Return true and reinitialize the
      start point if the interval between the stop and start points is larger
      than or equal to a specific number of seconds.<br>
    </big>
    <h2><a id="mozTocId908141" class="mozTocH2"></a><big>Chapter 4. Collision</big></h2>
    <big><br>
      <u>An important thing for any game</u><br>
      <br>
      What is an important thing for a video game? A collision.<br>
      <br>
      <u>Collision detail</u><br>
      <br>
      The detector uses the bounding box collision method to detect a
      collision. The collision-related information is stored in a custom data
      type.<br>
      <br>
      <i>typedef struct<br>
        {<br>
        unsigned int x;<br>
        unsigned int y;<br>
        unsigned int width;<br>
        unsigned int height;<br>
        } BOX;</i><br>
      <u><br>
        Work with a collision detector</u><br>
      <br>
      The <i>Collision</i> class provides easy access to collision detectors.
      It is a simple class with a few methods. Let's look at the publicly
      available methods.<br>
      <br>
      <i>Collision *Collision::get_handle(); -</i> Return the handle to the
      collision detector.<br>
      <br>
      <i>void Collision::set_target(const EUGENEGDK::BOX first_target, const
        EUGENEGDK::BOX second_target); -</i> Set the targets for the collision
      detector.<br>
      <br>
      <i>bool Collision::check_collision() const; -</i> Return true if the
      collision between two objects is accepted.<br>
      <br>
      <i>bool Collision::check_collision(const EUGENEGDK::BOX first_target,
        const EUGENEGDK::BOX second_target); -</i> Set the targets and check
      collisions between them.<br>
    </big>
    <h2><a id="mozTocId539746" class="mozTocH2"></a><big>Chapter 5. Tile map</big></h2>
    <big><u><br>
        A few words about tile maps</u><br>
      <br>
      The tile map is a tile matrix. A tile is a small, non-transparent sprite.
      A tile map is a very useful thing for the background.<br>
      <u><br>
        Rows and columns</u><br>
      <br>
      The first row index is 0. The first column index is 0.<br>
      <u><br>
        Work with the tile map</u><br>
      <br>
      The <i>Tilemap</i> class provides easy access to the tile map. It is a
      simple class with few methods. Let's look at the publicly available
      methods.<br>
      <i><br>
        Tilemap *Tilemap::get_handle(); -</i> Return the handle to the tile-map subsystem.<br>
      <i><br>
        void Tilemap::initialize(const unsigned int tile_width, const unsigned
        int tile_height); -</i> Initialize the subsystem.<br>
      <i><br>
        unsigned int Tilemap::get_tile_width() const; -</i> Return the tile
      width in pixels.<br>
      <br>
      <i>unsigned int Tilemap::get_tile_height() const; -</i> Return the tile
      height in pixels.<br>
      <i><br>
        unsigned int Tilemap::get_x(const unsigned int row) const; -</i> Get the
      x-coordinate from the target row.<br>
      <i><br>
        unsigned int Tilemap::get_y(const unsigned int column) const; -</i> Get
      the y-coordinate from the target column.<br>
      <i><br>
        unsigned int Tilemap::get_row(const unsigned int x) const; -</i> Get the
      row from the x-coordinate.<br>
      <i><br>
        unsigned int Tilemap::get_column(const unsigned int y) const; -</i> Get
      the column from the y-coordinate.<br>
      <i><br>
        unsigned int Tilemap::get_row_amount(const unsigned int viewport_width)
        const; -</i> Get the maximum number of the visible rows.<br>
      <i><br>
        unsigned int Tilemap::get_column_amount(const unsigned int
        viewport_width) const; -</i> Get the maximum number of the visible
      columns.<br>
      <br>
      <i>unsigned int Tilemap::get_tile_amount(const unsigned int
        viewport_width, const unsigned int viewport_height) const; -</i> Get the
      maximum number of the visible tiles.<br>
      <i><br>
        bool Tilemap::check_row(const unsigned int row,const unsigned int
        viewport_width) const; -</i> Return true if the row is valid.<br>
      <i><br>
        bool Tilemap::check_column(const unsigned int column,const unsigned int
        viewport_height) const; -</i> Return true if the column is valid.<br>
      <br>
      <i>EUGENEGDK::BOX Tilemap::get_box(const unsigned int row,const unsigned
        int column) const; -</i> Return the collision-related information.<br>
    </big><br>
    <h1><a id="mozTocId181862" class="mozTocH1"></a><big>Part 6. Other important
        things</big></h1>
    <h2><a id="mozTocId605872" class="mozTocH2"></a><big>Chapter 1. The
        sub-namespace</big></h2>
    <big><br>
      All classes in this section are declared in the <i>Misc</i>
      sub-namespace.<br>
    </big>
    <h2><a id="mozTocId983926" class="mozTocH2"></a><big>Chapter 2. Memory</big></h2>
    <big><br>
      RAM is an important resource. Just use the <i>Memory</i> class to get the
      total memory size and free memory size. Let's look at the publicly
      available methods.<br>
      <br>
      <i>unsigned long long int Memory::get_total_physical(); -</i> Return the
      total physical memory size in bytes.<br>
      <br>
      <i>unsigned long long int Memory::get_free_physical(); -</i> Return the
      free physical memory size in bytes.<br>
      <br>
      <i>unsigned long long int Memory::get_total_virtual(); -</i> Return the
      total <a href="https://en.wikipedia.org/wiki/Virtual_memory">virtual
        memory</a> size in bytes.<br>
      <br>
      <i>unsigned long long int Memory::get_free_virtual(); -</i> Return the
      free <a href="https://en.wikipedia.org/wiki/Virtual_memory">virtual
        memory</a> size in bytes.<br>
      <i><br>
        unsigned long long int Memory::get_physical_usge(); -</i> Return the
      physical memory usage in bytes.<br>
      <i><br>
        unsigned long long int Memory::get_virtual_usge(); -</i> Return the
      virtual memory usage in bytes.<br>
      <br>
      <i>unsigned long int Memory::get_usage(); -</i> Return the percentage of
      the physical memory used.<br>
    </big>
    <h2><a id="mozTocId151935" class="mozTocH2"></a><big>Chapter 3. Audio</big></h2>
    <big><br>
      <u>A few words about the audio subsystem</u><br>
      <br>
      This subsystem is intended for playing music and sounds. <a href="https://en.wikipedia.org/wiki/WAV">Waveform
        Audio File Format</a>, <a href="https://en.wikipedia.org/wiki/MP3">MPEG
        Audio Layer 3</a>, and <a href="https://en.wikipedia.org/wiki/Windows_Media_Audio">Windows Media Audio</a> are supported.<br>
      <br>
      <u>Additional formats</u><br>
      <br>
      You can use an additional format if you install third-party codecs.<br>
      <br>
      <u>Working with audio</u><br>
      <br>
      Just use the <i>Audio</i> class to work with audio. Let's look at the
      publicly available methods.<br>
      <br>
      <i>void Audio::initialize(); -</i> Initialize the subsystem.<br>
      <br>
      <i>void Audio::initialize(const char *target); -</i> Initialize the
      subsystem and load a sound file.<br>
      <i><br>
        void Audio::load(const char *target); -</i> Load a sound file.<br>
      <br>
      <i>void Audio::play(); -</i> Play a sound.<br>
      <br>
      <i>void Audio::play_loop(); -</i> Checking the playback status and
      restarting playback if needed.<br>
      <br>
      <i>void Audio::play(const bool loop); -</i> Play a sound. You can set loop
      mode if you want.<br>
      <br>
      <i>void Audio::stop(); -</i> Stop playing the content of the target file.<br>
      <br>
      <i>bool Audio::check_playing(); -</i> Return true if the sound resource is
      playing.<br>
    </big>
    <h1><a id="mozTocId1450" class="mozTocH1"></a><big>Part 7. Misc</big></h1>
    <h2><a id="mozTocId336341" class="mozTocH2"></a><big>Chapter 1. File system</big></h2>
    <big><br>
      This module is implemented as two simple functions. All these functions
      are declared in the <i>Filesystem</i> sub-namespace.<br>
      <br>
      <i>file_exist</i> check the target file to see if one exists.<br>
      <br>
      <i>delete_file</i> delete the target file.<br>
      <br>
      All functions take the target file name as an argument and return false if
      the operation failed.<br>
    </big>
    <h2><a id="mozTocId308918" class="mozTocH2"></a><big>Chapter 2. Tools</big></h2>
    <big><br>
      This module is implemented as a few functions. All these functions are
      declared in the <i>Tools</i> sub-namespace.<br>
      <br>
      <i>void quit(); -</i> Exit from your program and return the user to the
      operating system.<br>
      <br>
      <i>bool enable_logging(const char *name); -</i> Enable redirecting error
      messages to a log file and return false if the operation failed.<br>
      <br>
      <i>void randomize(); -</i> Initialize the random number generator.<br>
      <i><br>
        unsigned int get_random(const unsigned int number); -</i> Return a
      random value between zero and the number.<br>
      <br>
      <i>unsigned int get_texture_size(); -</i> Return the maximum width or
      height of the texture.<br>
      <br>
      <i>EUGENEGDK::BOX generate_box(const unsigned int x,const unsigned int
        y,const unsigned int width,const unsigned int height); -</i> Generate
      the collision-related information.<br>
    </big>
    <h2><a id="mozTocId473447" class="mozTocH2"></a><big>Chapter 3. Resource
        Manager</big></h2>
    <big><br>
      A resource is an instance of a user-defined class or structure. The
      resource manager is implemented as a few template functions. All these
      functions are declared in the <i>Resource</i> sub-namespace.<br>
      <br>
      <i>create</i> creates a resources. The first form of this function
      creates a single resource. It takes a handle to a resource handle as an
      argument. The second form creates an array of resources. It takes a
      handle to a resource handle and a resource amount.<br>
      <br>
      <i>destroy</i> delete a resource if it already exists. This function takes
      a resource handle as an argument.<br>
      <br>
      <i>destroy_array</i> delete the resource array if it already exists. This
      function takes a resource array handle as an argument.<br>
    </big>
    <h1><a id="mozTocId72710" class="mozTocH1"></a><big>Part 8. Binary files</big></h1>
    <h2><a id="mozTocId706443" class="mozTocH2"></a><big>Chapter 1. The
        sub-namespace</big></h2>
    <big><br>
      All classes in this section are declared in the <i>File</i>
      sub-namespace.<br>
    </big>
    <h2><a id="mozTocId168093" class="mozTocH2"></a><big>Chapter 2. Base binary
        file subsystem</big></h2>
    <big><br>
      <u>Work with the binary files</u><br>
      <br>
      The <i>Binary_File</i> class provides simple access to the base binary
      subsystem. Don't use it directly. Let's look at the publicly available
      methods.<br>
      <br>
      <i>void Binary_File::close(); -</i> Close the file.<br>
      <br>
      <i>void Binary_File::set_position(const long int offset); -</i> Set the
      file position.<br>
      <br>
      <i>long int Binary_File::get_position(); -</i> Return the current file
      position.<br>
      <br>
      <i>long int Binary_File::get_length(); -</i> Return the file length in
      bytes.<br>
      <br>
      <i>bool Binary_File::check_error(); -</i> Return true if the last file
      operation failed.<br>
      <br>
      <i>bool Binary_File::is_open() const; -</i> Return true if the file was
      successfully opened.<br>
      <u><br>
        Important notice</u><br>
      <br>
      The target file size limit is 2 gigabytes.<br>
    </big>
    <h2><a id="mozTocId575205" class="mozTocH2"></a><big>Chapter 3. File reader</big></h2>
    <big><br>
      The file reader is intended to read data from the binary files. The <i>Input_File</i>
      class provides access to a file reader. It is derived from the <i>Binary_File</i>
      class. Let's look at the publicly available methods.<br>
      <br>
      <i>Input_File* Input_File::get_handle(); -</i> Return the handle to the
      file reader.<br>
      <br>
      <i>void Input_File::open(const char *name); -</i> Open a file to read.<br>
      <br>
      <i>void Input_File::read(void *buffer,const size_t length); -</i> Read
      data from the file.<br>
    </big>
    <h2><a id="mozTocId140504" class="mozTocH2"></a><big>Chapter 4. File writer</big></h2>
    <big><br>
      The file writer is intended to write data to the binary files. The <i>Output_File</i>
      class provides access to a file writer. It is derived from the <i>Binary_File</i>
      class. Let's look at the publicly available methods.<br>
      <br>
      <i>Output_File* Output_File::get_handle(); -</i> Return the handle to the
      file writer.<br>
      <i><br>
        void Output_File::open(const char *name); -</i> Open a file to write.<br>
      <br>
      <i>void Output_File::create_temp(); -</i> Create a temporary file. This
      file will be deleted when it is closed.<br>
      <br>
      <i>void Output_File::write(const void *buffer,const size_t length); -</i>
      Write data to the file.<br>
      <br>
      <i>void Output_File::flush(); -</i> Force writing internal buffer data to
      the file.<br>
    </big>
    <h1><a id="mozTocId231501" class="mozTocH1"></a><big>Part 9. Input</big></h1>
    <h2><a id="mozTocId524623" class="mozTocH2"></a><big>Chapter 1. The
        sub-namespace</big></h2>
    <big><br>
      All classes in this section are declared in the <i>Input</i>
      sub-namespace.<br>
    </big>
    <h2><a id="mozTocId621333" class="mozTocH2"></a><big>Chapter 2. Keyboard</big></h2>
    <big><u><br>
        Low–level input</u><br>
      <br>
      Any keyboard has a built-in chip. It generates a special code when the
      user presses or releases the key. This code is called a «scan code».<br>
      <br>
      <u>Working with the keyboard</u><br>
      <br>
      Just use the <i>Keyboard</i> class to work with a keyboard. Let's look at
      the publicly available methods.<br>
      <br>
      <i>void Keyboard::initialize(); -</i> Initialize the subsystem.<br>
      <br>
      <i>bool Keyboard::check_hold(const unsigned char code); -</i> Return true
      if a key with a specific scan code is pressed or held.<br>
      <i><br>
        bool Keyboard::check_press(const unsigned char code); -</i> Return true
      if a key with a specific scan code was pressed.<br>
      <br>
      <i>bool Keyboard::check_release(const unsigned char code); -</i> Return
      true if a key with a specific scan code was released.<br>
      <br>
      <i>bool Keyboard::is_ready() const; -</i> Return true if the subsystem has
      already been initialized.<br>
      <br>
      <u>List of supported scan codes</u><br>
      <br>
      You can see a list of scan codes below.<br>
      <br>
    </big>
    <table border="1">
      <tbody>
        <tr>
          <td><big>Key</big></td>
          <td><big>Code</big></td>
          <td><big>Key</big></td>
          <td><big>Code</big></td>
          <td><big>Key</big></td>
          <td><big>Code</big></td>
        </tr>
        <tr>
          <td><big>Escape</big></td>
          <td><big>1</big></td>
          <td><big>A</big></td>
          <td><big>30</big></td>
          <td><big>F1</big></td>
          <td><big>59</big></td>
        </tr>
        <tr>
          <td><big>! or 1</big></td>
          <td><big>2</big></td>
          <td><big>S</big></td>
          <td><big>31</big></td>
          <td><big>F2</big></td>
          <td><big>60</big></td>
        </tr>
        <tr>
          <td><big>@ or 2</big></td>
          <td><big>3</big></td>
          <td><big>D</big></td>
          <td><big>32</big></td>
          <td><big>F3</big></td>
          <td><big>61</big></td>
        </tr>
        <tr>
          <td><big># or 3</big></td>
          <td><big>4</big></td>
          <td><big>F</big></td>
          <td><big>33</big></td>
          <td><big>F4</big></td>
          <td><big>62</big></td>
        </tr>
        <tr>
          <td><big>$ or 4</big></td>
          <td><big>5</big></td>
          <td><big>G</big></td>
          <td><big>34</big></td>
          <td><big>F5</big></td>
          <td><big>63</big></td>
        </tr>
        <tr>
          <td><big>% or 5</big></td>
          <td><big>6</big></td>
          <td><big>H</big></td>
          <td><big>35</big></td>
          <td><big>F6</big></td>
          <td><big>64</big></td>
        </tr>
        <tr>
          <td><big>^ or 6</big></td>
          <td><big>7</big></td>
          <td><big>J</big></td>
          <td><big>36</big></td>
          <td><big>F7</big></td>
          <td><big>65</big></td>
        </tr>
        <tr>
          <td><big>&amp; or 7</big></td>
          <td><big>8</big></td>
          <td><big>K</big></td>
          <td><big>37</big></td>
          <td><big>F8</big></td>
          <td><big>66</big></td>
        </tr>
        <tr>
          <td><big>* or 8</big></td>
          <td><big>9</big></td>
          <td><big>L</big></td>
          <td><big>38</big></td>
          <td><big>F9</big></td>
          <td><big>67</big></td>
        </tr>
        <tr>
          <td><big>( or 9</big></td>
          <td><big>10</big></td>
          <td style="height: 22px;"><big>: or ;</big></td>
          <td><big>39</big></td>
          <td><big>F10</big></td>
          <td><big>68</big></td>
        </tr>
        <tr>
          <td><big>0 or )</big></td>
          <td><big>11</big></td>
          <td><big>" or '</big></td>
          <td><big>40</big></td>
          <td><big>F11</big></td>
          <td><big>133</big></td>
        </tr>
        <tr>
          <td><big>_ or |</big></td>
          <td><big>12</big></td>
          <td><big>~ or `</big></td>
          <td><big>41</big></td>
          <td><big>F12</big></td>
          <td><big>134</big></td>
        </tr>
        <tr>
          <td><big>+ or =</big></td>
          <td><big>13</big></td>
          <td><big>Left Shift</big></td>
          <td><big>42</big></td>
          <td><big>Num Lock</big></td>
          <td><big>69</big></td>
        </tr>
        <tr>
          <td><big>Backspace</big></td>
          <td><big>14</big></td>
          <td><big>| or \</big></td>
          <td><big>43</big></td>
          <td><big>Scroll Lock</big></td>
          <td><big>70</big></td>
        </tr>
        <tr>
          <td><big>Tab</big></td>
          <td><big>15</big></td>
          <td><big>Z</big></td>
          <td><big>44</big></td>
          <td><big>Home or 7</big></td>
          <td><big>71</big></td>
        </tr>
        <tr>
          <td><big>Q</big></td>
          <td><big>16</big></td>
          <td><big>X</big></td>
          <td><big>45</big></td>
          <td><big>Up or 8</big></td>
          <td><big>72</big></td>
        </tr>
        <tr>
          <td><big>W</big></td>
          <td><big>17</big></td>
          <td><big>C</big></td>
          <td><big>46</big></td>
          <td><big>Page up or 9</big></td>
          <td><big>73</big></td>
        </tr>
        <tr>
          <td><big>E</big></td>
          <td><big>18</big></td>
          <td><big>V</big></td>
          <td><big>47</big></td>
          <td><big>Gray -</big></td>
          <td><big>74</big></td>
        </tr>
        <tr>
          <td><big>R</big></td>
          <td><big>19</big></td>
          <td><big>B</big></td>
          <td><big>48</big></td>
          <td><big>Left or 4</big></td>
          <td><big>75</big></td>
        </tr>
        <tr>
          <td><big>T</big></td>
          <td><big>20</big></td>
          <td><big>N</big></td>
          <td><big>49</big></td>
          <td><big>Center or 5</big></td>
          <td><big>76</big></td>
        </tr>
        <tr>
          <td><big>Y</big></td>
          <td><big>21</big></td>
          <td><big>M</big></td>
          <td><big>50</big></td>
          <td><big>Right or 6</big></td>
          <td><big>77</big></td>
        </tr>
        <tr>
          <td><big>U</big></td>
          <td><big>22</big></td>
          <td><big>&lt; or ,</big></td>
          <td><big>51</big></td>
          <td><big>Gray +</big></td>
          <td><big>78</big></td>
        </tr>
        <tr>
          <td><big>I</big></td>
          <td><big>23</big></td>
          <td><big>&gt; or .</big></td>
          <td><big>52</big></td>
          <td><big>End or 1</big></td>
          <td style="height: 22px;"><big>79</big></td>
        </tr>
        <tr>
          <td><big>O</big></td>
          <td><big>24</big></td>
          <td><big>?</big></td>
          <td><big>53</big></td>
          <td><big>Down or 2</big></td>
          <td><big>80</big></td>
        </tr>
        <tr>
          <td><big>P</big></td>
          <td><big>25</big></td>
          <td><big>Right shift</big></td>
          <td><big>54</big></td>
          <td><big>Page down or 3</big></td>
          <td><big>81</big></td>
        </tr>
        <tr>
          <td><big>{ or [</big></td>
          <td><big>26</big></td>
          <td><big>Print Screen or *</big></td>
          <td><big>55</big></td>
          <td><big>Insert or 0</big></td>
          <td><big>82</big></td>
        </tr>
        <tr>
          <td><big>} or ]</big></td>
          <td><big>27</big></td>
          <td><big>Alt</big></td>
          <td><big>56</big></td>
          <td><big>Delete or .</big></td>
          <td><big>83</big></td>
        </tr>
        <tr>
          <td><big>Enter</big></td>
          <td><big>28</big></td>
          <td><big>Spacebar</big></td>
          <td><big>57</big></td>
          <td colspan="1" rowspan="2"><br>
            <br>
          </td>
          <td colspan="1" rowspan="2"><br>
          </td>
        </tr>
        <tr>
          <td><big>Control</big></td>
          <td><big>29</big></td>
          <td><big>Caps Lock</big></td>
          <td><big>58</big></td>
        </tr>
      </tbody>
    </table>
    <big><br>
    </big>
    <h2><a id="mozTocId829188" class="mozTocH2"></a><big>Chapter 3. Mouse</big></h2>
    <big><u><br>
        A few words about mice</u><br>
      <br>
      A mouse is very useful for interaction with a graphical user interface.
      But the mouse can also be used in video games.<br>
      <br>
      <u>Working with the mouse</u><br>
      <br>
      Just use the <i>Mouse</i> class to work with a mouse. Let's look at the
      publicly available methods.<br>
      <i><br>
        void Mouse::show(); -</i> Show the mouse cursor.<br>
      <i><br>
        void Mouse::hide(); -</i> Hide the mouse cursor.<br>
      <i><br>
        unsigned int Mouse::get_x(); -</i> Return the x-position of the mouse.<br>
      <br>
      <i>unsigned int Mouse::get_y(); -</i> Return the y-position of the mouse.<br>
      <br>
      <i>void Mouse::set_position(const unsigned int x,const unsigned int y); -</i>
      Set the position of the mouse.<br>
      <i><br>
        bool Mouse::check_hold(const EUGENEGDK::MOUSE_BUTTON button); -</i>
      Return true if a mouse button is pressed or held.<br>
      <br>
      <i>bool Mouse::check_press(const EUGENEGDK::MOUSE_BUTTON button); -</i>
      Return true if a mouse button was pressed.<br>
      <br>
      <i>bool Mouse::check_release(const EUGENEGDK::MOUSE_BUTTON button); -</i>
      Return true if a mouse button was released.<br>
      <u><br>
        Mouse buttons</u><br>
      <br>
      The mouse button codes look like the predefined constants. You can see it
      below.<br>
      <br>
    </big>
    <table border="1">
      <tbody>
        <tr>
          <td><big>Mouse button code</big></td>
          <td><big>Button</big></td>
        </tr>
        <tr>
          <td><big>MOUSE_LEFT</big></td>
          <td><big>Left button</big></td>
        </tr>
        <tr>
          <td><big>MOUSE_RIGHT</big></td>
          <td><big>Right button</big></td>
        </tr>
        <tr>
          <td><big>MOUSE_MIDDLE</big></td>
          <td><big>Middle button</big></td>
        </tr>
      </tbody>
    </table>
    <big><br>
    </big>
    <h2><a id="mozTocId906897" class="mozTocH2"></a><big>Chapter 4. Gamepad</big></h2>
    <big><br>
      <u>Best friend of a retro gamer</u><br>
      <br>
      What is a good choice for a game control device when the user plays an
      arcade or an old-school style video game? A gamepad. This engine
      provides simple access to it.<br>
      <u><br>
        Number of connected gamepads</u><br>
      <br>
      You can connect a few gamepads. Any connected gamepad has an internal
      index. The first gamepad index is 0. It will be activated by default.<br>
      <br>
      <u>Ordinary button codes</u><br>
      <br>
      Ordinary button codes look like predefined constants. The first button is
      <i>GAMEPAD_BUTTON1</i>. The last button is <i>GAMEPAD_BUTTON32</i>.<br>
      <br>
      <u>D-Pad button codes</u><br>
      <br>
      The D-Pad button codes look like the predefined constants. You can see it
      below.<br>
      <br>
    </big>
    <table border="1">
      <tbody>
        <tr>
          <td><big>D-pad button code</big></td>
          <td><big>D-Pad button</big></td>
        </tr>
        <tr>
          <td><big>GAMEPAD_NONE</big></td>
          <td><big>None of the D-Pad buttons are pressed or held down.</big></td>
        </tr>
        <tr>
          <td><big>GAMEPAD_UP</big></td>
          <td><big>D-Pad up</big></td>
        </tr>
        <tr>
          <td><big>GAMEPAD_DOWN</big></td>
          <td><big>D-Pad down</big></td>
        </tr>
        <tr>
          <td><big>GAMEPAD_LEFT</big></td>
          <td><big>D-Pad left</big></td>
        </tr>
        <tr>
          <td><big>GAMEPAD_RIGHT</big></td>
          <td><big>D-Pad right</big></td>
        </tr>
        <tr>
          <td><big>GAMEPAD_UPLEFT</big></td>
          <td><big>Both D-Pad up and D-Pad left</big></td>
        </tr>
        <tr>
          <td><big>GAMEPAD_UPRIGHT</big></td>
          <td><big>Both D-Pad up and D-Pad right</big></td>
        </tr>
        <tr>
          <td><big>GAMEPAD_DOWNLEFT</big></td>
          <td><big>Both D-Pad down and D-Pad left</big></td>
        </tr>
        <tr>
          <td><big>GAMEPAD_DOWNRIGHT</big></td>
          <td><big>Both D-Pad down and D-Pad right</big></td>
        </tr>
      </tbody>
    </table>
    <big><br>
      <u>Stick identifiers</u><br>
      <br>
      The stick identifiers look like the predefined constants. You can see it
      below.<br>
      <br>
    </big>
    <table border="1">
      <tbody>
        <tr>
          <td><big>Identifiers</big></td>
          <td><big>Description</big></td>
        </tr>
        <tr>
          <td><big>GAMEPAD_LEFT_STICK</big></td>
          <td><big>Left stick</big></td>
        </tr>
        <tr>
          <td><big>GAMEPAD_RIGHT_STICK</big></td>
          <td><big>Right stick</big></td>
        </tr>
      </tbody>
    </table>
    <big><br>
      <u>Stick direction</u><br>
      <br>
      The stick direction looks like the predefined constants. You can see it
      below.<br>
      <br>
    </big>
    <table border="1">
      <tbody>
        <tr>
          <td><big>Value</big></td>
          <td><big>X-direction</big></td>
          <td><big>Y-direction</big></td>
        </tr>
        <tr>
          <td><big>GAMEPAD_NEUTRAL_DIRECTION</big></td>
          <td><big>Neutral</big></td>
          <td><big>Neutral</big></td>
        </tr>
        <tr>
          <td><big>GAMEPAD_POSITIVE_DIRECTION</big></td>
          <td><big>Right</big></td>
          <td><big>Up</big></td>
        </tr>
        <tr>
          <td><big>GAMEPAD_NEGATIVE_DIRECTION</big></td>
          <td><big>Left</big></td>
          <td><big>Down</big></td>
        </tr>
      </tbody>
    </table>
    <big><br>
      <u>Working with a gamepad</u><br>
      <br>
      Just use the <i>Gamepad</i> class to work with the gamepad. Let's look at
      the publicly available methods.<br>
      <br>
      <i>unsigned int Gamepad::get_amount(); -</i> Return the number of
      connected gamepads.<br>
      <i><br>
        unsigned int Gamepad::get_button_amount() const; -</i> Return the number
      of the gamepad buttons.<br>
      <i><br>
        unsigned int Gamepad::get_stick_amount() const; -</i> Return the number
      of the gamepad sticks.<br>
      <i><br>
        void Gamepad::update(); -</i> Update the internal gamepad state.<br>
      <i><br>
        void Gamepad::set_active(const unsigned int gamepad); -</i> Set the
      current active gamepad.<br>
      <br>
      <i>EUGENEGDK::GAMEPAD_DPAD Gamepad::get_dpad() const; -</i> Return the
      code of the pressed or held D-Pad button.<br>
      <i><br>
        bool Gamepad::check_hold(const EUGENEGDK::GAMEPAD_BUTTONS button) const;
        -</i> Return true if the button is pressed or held.<br>
      <i><br>
        bool Gamepad::check_press(const EUGENEGDK::GAMEPAD_BUTTONS button)
        const; -</i> Return true if the button was pressed.<br>
      <br>
      <i>bool Gamepad::check_released(const EUGENEGDK::GAMEPAD_BUTTONS button)
        const; -</i> Return true if the button was released.<br>
      <br>
      <i>EUGENEGDK::GAMEPAD_DIRECTION Gamepad::get_stick_x(const
        EUGENEGDK::GAMEPAD_STICKS stick) const; -</i> Return the x-direction of
      a specific stick.<br>
      <i><br>
        EUGENEGDK::GAMEPAD_DIRECTION Gamepad::get_stick_y(const
        EUGENEGDK::GAMEPAD_STICKS stick) const; -</i> Return the y-direction of
      a specific stick.<br>
      <i><br>
        EUGENEGDK::GAMEPAD_DIRECTION Gamepad::get_left_stick_x() const; -</i>
      Return the x-direction of the left stick.<br>
      <br>
      <i>EUGENEGDK::GAMEPAD_DIRECTION Gamepad::get_left_stick_y() const; -</i>
      Return the y-direction of the left stick.<br>
      <i><br>
        EUGENEGDK::GAMEPAD_DIRECTION Gamepad::get_right_stick_x() const; -</i>
      Return the x-direction of the right stick.<br>
      <i><br>
        EUGENEGDK::GAMEPAD_DIRECTION Gamepad::get_right_stick_y() const; -</i>
      Return the y-direction of the right stick.<br>
    </big>
    <h1><a id="mozTocId768064" class="mozTocH1"></a><big>Part 10. Internal
        details of the engine subsystems</big></h1>
    <h2><a id="mozTocId478780" class="mozTocH2"></a><big>Chapter 1. A few words
        for a curious programmer</big></h2>
    <big><br>
      The engine subsystems have a different internal structure. It has been
      hidden from you, and you don't have access to it. Do you want to know
      about hidden things? Just read the next chapter.<br>
    </big>
    <h2><a id="mozTocId5089" class="mozTocH2"></a><big>Chapter 2. Internal
        classes</big></h2>
    <big><u><br>
        Internal classes</u><br>
      <br>
      Some classes are designed for internal use only. Don't touch them. What
      are these strange classes doing?<br>
      <u><br>
        Microsoft Windows-specific classes</u><br>
      <br>
      All Microsoft Windows-specific classes are declared in the <i>Internal</i>
      sub-namespace.<br>
      <br>
      <i>Engine</i> creates the game window and does message processing.<br>
      <i>Synchronization</i> implements the synchronization timer.<br>
      <i>Display</i> implements the display manager.<br>
      <i>WINGL</i> contains Windows-specific OPENGL initialization code.<br>
      <u><br>
        Core classes</u><br>
      <br>
      All engine core classes and functions are declared in the <i>Core</i>
      sub-namespace.<br>
      <br>
      <i>FPS</i> implements the FPS counter.<br>
      <i>Unicode_Converter</i> implements the system code page to UTF-16
      converter.<br>
      <i>Render</i> implements the OPENGL render.<br>
      <i>Resizer</i> is intended to calculate the correct texture size.<br>
      <i>Rectangle</i> is intended to draw a textured rectangle.<br>
      <i>Shape</i> is the base class of the <i>Rectangle</i> class.<br>
    </big>
    <h2><a id="mozTocId856781" class="mozTocH2"></a><big>Chapter 3. Base
        graphics subsystem</big></h2>
    <big><u><br>
        Visible object</u><br>
      <br>
      Any visible object is a textured rectangle.<br>
      <br>
      <u>Textures</u><br>
      <br>
      A texture width must be a power of two. A texture height also must be a
      power of two. Any image will automatically be resized before uploading.<br>
      <u><br>
        Vertex arrays and texture coordinate arrays</u><br>
      <br>
      Any rectangle needs four vertices and four texture coordinates.<br>
      A single vertex represents the following custom data type:<br>
      <br>
      <i>typedef struct Vertex<br>
        {<br>
        int x;<br>
        int y;<br>
        };</i><br>
      <br>
      A single texture coordinate represents the following custom data type:<br>
      <br>
      <i>typedef struct<br>
        {<br>
        float u;<br>
        float v;<br>
        } Point;</i><br>
      <br>
      All these custom types are declared in the Core sub-namespace.<br>
    </big>
    <h2><a id="mozTocId625163" class="mozTocH2"></a><big>Chapter 4. Gamepad</big></h2>
    <big><br>
      The gamepad subsystem is working over the <a href="https://msdn.microsoft.com/ru-ru/library/windows/desktop/dd757116%28v=vs.85%29.aspx">Joystick
        Multimedia API</a>.<br>
    </big>
    <h2><a id="mozTocId25850" class="mozTocH2"></a><big>Chapter 5. Input</big></h2>
    <big><u><br>
        Input backend</u><br>
      <br>
      The keyboard and mouse input subsystems are simple. It works over a
      standard Microsoft Windows API.<br>
      <br>
      <u>Internal key state</u><br>
      <br>
      The internal states of keyboard keys and mouse buttons look like the
      predefined constants. You can see it below.<br>
      <br>
    </big>
    <table border="1">
      <tbody>
        <tr>
          <td><big>Key/button state</big></td>
          <td><big>Description</big></td>
        </tr>
        <tr>
          <td><big>KEY_PRESSED</big></td>
          <td><big>A key or button is pressed or held.</big></td>
        </tr>
        <tr>
          <td><big>KEY_RELEASED</big></td>
          <td><big>A key or button was released.</big></td>
        </tr>
      </tbody>
    </table>
    <big><br>
    </big>
    <h2><a id="mozTocId248668" class="mozTocH2"></a><big>Chapter 6. Audio</big></h2>
    <big><br>
      The audio subsystem is working over <a href="https://docs.microsoft.com/en-us/windows/desktop/DirectShow/directshow">DirectShow</a>.
      It is available as part of <a href="https://en.wikipedia.org/wiki/DirectX">DirectX</a>.
      DirectX is pre-installed by default under the modern versions of Windows.<br>
    </big>
    <h1><a id="mozTocId928107" class="mozTocH1"></a><big>Version history</big></h1>
    <big><br>
      0.1: Initial version.<br>
      0.1.1-0.7.6: The internal unstable builds.<br>
      0.7.7: The small changes.<br>
      0.7.8: The small bug in the sprite subsystem has been fixed.<br>
      0.7.9-0.8.1: The small changes.<br>
      0.8.2: The sprite subsystem has improved.<br>
      0.8.3: PCX support has been removed.<br>
      0.8.4: The small changes.<br>
      0.8.5: The FPS counter has improved.<br>
      0.8.6-0.8.9: The small changes.<br>
      0.9: TGA support has improved.<br>
      0.9.1: The small bug in the sprite subsystem has been fixed.<br>
      0.9.2: The small changes.<br>
      0.9.3: The new subsystem has been added.<br>
      0.9.4-0.9.5: The graphic primitives subsystem has improved.<br>
      0.9.6-0.9.9: The small changes.<br>
      1.0: The base graphics subsystem has improved.<br>
      1.0.1-1.0.2: The background subsystem has improved.<br>
      1.0.3: The small changes.<br>
      1.0.4: The small bug in the sprite subsystem has been fixed.<br>
      1.0.5-1.1.4: The small changes.<br>
      1.1.5-1.1.6: The small bug has been fixed.<br>
      1.1.7: The unused dependency has been removed.<br>
      1.1.8-1.2.5: The small changes.<br>
      1.2.6: The small bug has been fixed.<br>
      1.2.7: The small changes.<br>
      1.2.8: The rendering performance has increased.<br>
      1.2.9: The Windows 2000 support has been added.<br>
      1.3: The small changes.<br>
      1.3.1: The image resizer has improved.<br>
      1.3.2: The gamepad subsystem has improved.<br>
      1.3.3: The project name changed.<br>
      1.3.4: The sprite subsystem has improved.<br>
      1.3.5: The small changes.<br>
      1.3.6: The tile-set subsystem has improved.<br>
      1.3.7: The small changes.<br>
      1.3.8: The sprite subsystem has improved.<br>
      1.3.9: The tile-set subsystem has improved.<br>
      1.4: The sprite subsystem has improved.<br>
      1.4.1: The text subsystem has improved.<br>
      1.4.2-1.4.5: The small changes.<br>
      1.4.6: The new subsystem has been added. Windows 2000 support has been removed.<br>
      1.4.7-1.4.8: The sprite subsystem has improved.<br>
      1.4.9: The text subsystem has improved.<br>
      1.5: The small changes.<br>
      1.5.1: The optional software rendering has been added.<br>
      1.5.2-1.5.7: The small changes.<br>
      1.5.8: The keyboard input has improved.<br>
      1.5.9: The mouse input has improved.<br>
      1.6: The gamepad support has improved.<br>
      1.6.1: The small bug in the gamepad subsystem has been fixed.<br>
      1.6.2: The small changes.<br>
      1.6.3: The file system subsystem has improved.<br>
      1.6.4-1.6.5: The small changes.<br>
      1.6.6: The base graphics subsystem has improved.<br>
      1.6.7: The small changes.<br>
      1.6.8: The gamepad support has improved.<br>
      1.6.9-1.7: The small changes.<br>
      1.7.1: The small bug in the sprite subsystem has been fixed.<br>
      1.7.2: The graphic primitives subsystem has improved.<br>
      1.7.3-1.7.4: The small changes.<br>
      1.7.5-1.7.6: The picture subsystem has improved.<br>
      1.7.7-1.7.8: The sprite subsystem has improved.<br>
      1.7.9-1.8: The picture subsystem has improved.<br>
      1.8.1: The small changes.<br>
      1.8.2: The tile-set subsystem has improved.<br>
      1.8.3: The small changes.<br>
      1.8.4-1.8.6: The binary file subsystem has improved.<br>
      1.8.7-1.8.8: The image loader has improved.<br>
      1.8.9: The small changes.<br>
      1.9-1.9.1: The image loader has improved.<br>
      1.9.2: The picture subsystem has improved.<br>
      1.9.3: The small changes.<br>
      1.9.4: The tile-set subsystem has improved.<br>
      1.9.5-1.9.8: The small changes.<br>
      1.9.9: The background subsystem has improved.<br>
      2.0-2.0.3: The image loader has improved.<br>
      2.0.4: The sprite subsystem has improved.<br>
      2.0.5: The background subsystem has improved.<br>
      2.0.6-2.1.2: The text drawing subsystem has improved.<br>
      2.1.3: The background subsystem has improved.<br>
      2.1.4-2.1.8: The small changes.<br>
      2.1.9-2.2.7: The multimedia subsystem has improved.<br>
      2.2.8-2.3.1: The small changes.<br>
      2.3.2-2.3.3: The base graphics subsystem has improved.<br>
      2.3.4: The synchronization timer has improved.<br>
      2.3.5-2.3.6: The small changes.<br>
      2.3.7: The multimedia subsystem has improved.<br>
      2.3.8: The keyboard input has improved.<br>
      2.3.9: The small changes.<br>
      2.4: The mouse input has improved.<br>
      2.4.1: The small changes.<br>
      2.4.2: The binary file subsystem has improved.<br>
      2.4.3-2.4.7: The small changes.<br>
      2.4.8: The background subsystem has improved.<br>
      2.4.9: The sprite subsystem has improved.<br>
      2.5: The tile-set subsystem has improved.<br>
      2.5.1-2.5.2: The small changes.<br>
      2.5.3: The sprite subsystem has improved.<br>
      2.5.4-2.5.6: The tile-set subsystem has improved.<br>
      2.5.7: The small changes.<br>
      2.5.8: The sprite subsystem has improved.<br>
      2.5.9-2.6: The small changes.<br>
      2.6.1: The animation subsystem has improved.<br>
      2.6.2: The background subsystem has improved.<br>
      2.6.3-2.6.4: The sprite subsystem has improved.<br>
      2.6.5: The background subsystem has improved.<br>
      2.6.6: The base graphics subsystem has improved.<br>
      2.6.7: The small changes.<br>
      2.6.8: The primitive subsystem has improved.<br>
      2.6.9: The small bug has been fixed.<br>
      2.7: The primitive subsystem was removed.<br>
      2.7.1-2.7.6: The preview release of the next branch.<br>
      2.7.7: The public release of the next branch.<br>
      2.7.8-2.7.9: The small changes.<br>
      2.8: Go back to the old stable branch.<br>
      2.8.1-2.8.5: The small changes.<br>
      2.8.6: Merge the old branch and the new branch.<br>
      2.8.7: The small bug has been fixed.<br>
      2.8.8-2.9.9: The small changes.<br>
      3.0: The basic graphics subsystem has improved.<br>
      3.0.1: The small changes.<br>
      3.0.2: The keyboard subsystem has improved.<br>
      3.0.3-3.0.5: The small changes.<br>
      3.0.6: The operating system interaction subsystem has improved.<br>
      3.0.7-3.1.1: The small changes.<br>
      3.2-3.2.1: A few changes in the engine API.<br>
      3.2.2: The small changes.<br>
      3.3: The new subsystem has been added.<br>
      3.3.1-3.3.4: The small changes.<br>
      3.3.5: The keyboard input has improved.<br>
      3.3.6: The image loader has improved.<br>
      3.3.7-3.3.8: The small changes.<br>
      3.3.9-3.4: The sprite subsystem has improved.<br>
      3.4.1: The background subsystem has improved.<br>
      3.4.2: The image storage has improved.<br>
      3.4.3: The sprite subsystem has improved.<br>
      3.4.4: The image loader has improved.<br>
      3.4.5: The image storage has improved.<br>
      3.4.6: The tile-set subsystem has improved.<br>
      3.4.7: The background subsystem has improved.<br>
      3.4.8-3.4.9: The sprite subsystem has improved.<br>
      3.5-3.5.4: The small changes.<br>
      3.5.5: The tile-set subsystem has improved.<br>
      3.5.6-3.6.4: The small changes.<br>
      3.6.5: The multimedia subsystem has improved.<br>
      3.6.6-3.6.8: The small changes.<br>
      3.6.9: The sprite subsystem has improved.<br>
      3.7: The background subsystem has improved.<br>
      3.7.1: The small changes.<br>
      3.7.2: The binary file subsystem has improved.<br>
      3.7.3: The background subsystem has improved.<br>
      3.7.4-3.7.5: The small changes.<br>
      3.7.6: The small bug has been fixed.<br>
      3.7.7-3.8.5: The small changes.<br>
      3.8.6: The gamepad subsystem has improved.<br>
      3.8.7-3.8.8: The small changes.<br>
      3.8.9: The image resizer has improved.<br>
      3.9-3.9.7: The small changes.<br>
      3.9.8-3.9.9: The keyboard input has improved.<br>
      4.0-4.0.1: The small changes.<br>
      4.0.2: The collision detection subsystem has improved.<br>
      4.0.3: The small bug in the collision detection subsystem has been fixed.<br>
      4.0.4: The collision detection subsystem has improved.<br>
      4.0.5-4.0.6: The small changes.<br>
      4.0.7: The new internal subsystem has been added.<br>
      4.0.8: The small changes in the engine core.<br>
      4.0.9: The image loader has improved.<br>
      4.1: The keyboard input has improved.<br>
      4.1.1: The small bug in the image loader has improved.<br>
      4.1.2: The keyboard input has improved.<br>
      4.1.3-4.2.1: The small changes.<br>
      4.2.2: The image resizer has improved.<br>
      4.2.3: The image storage has improved.<br>
      4.2.4: The image loader has improved.<br>
      4.2.5: The small changes.<br>
      4.2.6: The image storage has improved.<br>
      4.2.7: The mouse input has improved.<br>
      4.2.8: The keyboard input has improved.<br>
      4.2.9: The small changes.<br>
      4.3-4.3.3: The gamepad subsystem has improved.<br>
      4.3.4: The collision detection subsystem has improved.<br>
      4.3.5: The small changes.<br>
      4.3.6-4.3.8: The system interaction subsystem has improved.<br>
      4.3.9-4.4: The collision detection subsystem has improved.<br>
      4.4.1: The new subsystem has been added.<br>
      4.4.1.1: The documentation has been updated.<br>
      4.4.2: The small changes.<br>
      4.4.3-4.4.4: The new supported compiler has been added.<br>
      4.4.4.1: The documentation has been updated.<br>
      4.4.5: The small changes.<br>
      4.4.6: The new subsystem has been added.<br>
      4.4.6.1: The documentation has been updated.<br>
      4.4.7-4.4.8: The small changes.<br>
      4.4.9: The Windows 2000 support has been added.<br>
      4.4.9.1: The documentation has been updated.<br>
      4.5-4.5.3: The small changes.<br>
      4.5.4: The gamepad support has improved.<br>
      4.5.5-4.5.7: The rendering has improved.<br>
      4.5.8-4.6.2: The small changes.<br>
      4.6.3: The image resizer has improved.<br>
      4.6.4: The small changes.<br>
      4.6.5: The small bug in the binary file subsystem has been fixed.<br>
      4.6.6-4.6.8: The small changes.<br>
      4.6.9-4.7: The changes in the engine API.<br>
      4.7.0.1: The documentation has been updated.<br>
      4.7.1-4.7.2: The small changes.<br>
      4.7.3: The changes in the engine API.<br>
      4.7.4-4.8: The small changes.<br>
      4.8.1-4.8.3: The rendering has improved.<br>
      4.8.4-4.8.6: The small changes.<br>
      4.8.7: The keyboard input has improved.<br>
      4.8.8-4.8.9: The display manager has improved.<br>
      4.9-4.9.1: The small changes.<br>
      4.9.2: The display manager has improved.<br>
      4.9.3-4.9.4: The small changes.<br>
      4.9.5: The keyboard input has improved.<br>
      4.9.6: The mouse input has improved.<br>
      4.9.7-5.0.8: The small changes.<br>
      5.0.9-5.2: The experimental branch.<br>
      5.2.1: The small changes.<br>
      5.2.2: The text-drawing subsystem has improved.<br>
      5.2.3-5.2.5: The small changes.<br>
      5.2.6: The changes in the engine API.<br>
      5.2.7: The new subsystem has been added.<br>
      5.2.8-5.2.9: The sprite subsystem has improved.<br>
      5.3: The base sprite subsystem has improved.<br>
      5.3.1-5.3.4: The small changes.<br>
      5.3.5: The new subsystem has been added.<br>
      5.3.6: The small changes.<br>
      5.3.7: The tile-set subsystem was removed.<br>
      5.3.8: The small changes.<br>
      5.3.9: The sprite sheet subsystem has improved.<br>
      5.4-5.4.1: The small changes.<br>
      5.4.2-5.4.5: The text drawing subsystem has improved.<br>
      5.4.6-5.5.2: The background subsystem has improved.<br>
      5.5.3-5.5.7: The small changes.<br>
      5.5.8: The background subsystem has improved.<br>
      5.5.9: The base sprite subsystem has improved.<br>
      5.6-5.6.4: The small changes.<br>
      5.6.5: The background subsystem has improved.<br>
      5.6.6: The text-drawing subsystem has improved.<br>
      5.6.7: The background subsystem has improved.<br>
      5.6.8: The text-drawing subsystem has improved.<br>
      5.6.9: The small changes.<br>
      5.7: The text drawing subsystem has improved.<br>
      5.7.1-5.7.2: The sprite sheet subsystem has improved.<br>
      5.7.3-5.7.4: The small changes.<br>
      5.7.5-5.7.6: The resource manager has improved.<br>
      5.7.7-5.8.2: The small changes.<br>
      5.8.3-5.8.5: The background subsystem has improved.<br>
      5.8.6: The small changes.<br>
      5.8.7-5.9.1: The sprite sheet subsystem has improved.<br>
      5.9.2-5.9.4: The small changes.<br>
      5.9.5: The text-drawing subsystem has improved.<br>
      5.9.6-5.9.8: The small changes.<br>
      5.9.9: The Windows 2000 support has been removed.<br>
      6.0: The changes in the engine API.<br>
      6.0.1: The new subsystem has been added.<br>
      6.0.2: The small changes.<br>
      6.0.3: The background subsystem and sprite subsystem have improved.<br>
      6.0.4: The small changes.<br>
      6.0.5: The picture subsystem has improved.<br>
      6.0.6-6.0.7: The small changes.<br>
      6.0.7.1: The documentation has been updated.<br>
      6.0.8: The base graphics subsystem has improved.<br>
      6.0.8.1: The documentation has been updated.<br>
      6.0.9-6.1.1: The small changes.<br>
      6.1.2: The text drawing subsystem has improved.<br>
      6.1.3: The small changes.<br>
      6.1.3.1: The documentation has been updated.<br>
      6.1.4: The small bug has been fixed.<br>
      6.1.5-6.1.6: The sprite sheet subsystem has improved.<br>
      6.1.7-6.2.1: The small changes.<br>
      6.2.2-6.2.3: The base graphics subsystem has improved.<br>
      6.2.4-6.2.6: The binary file subsystem has improved.<br>
      6.2.6.1: The documentation has been updated.<br>
      6.2.7: The collision detection subsystem has improved.<br>
      6.2.8: The small bug has been fixed.<br>
      6.2.9: The small changes.<br>
      6.3: The base sprite subsystem has improved.<br>
      6.3.1-6.3.2: The small changes.<br>
      6.3.3: The base graphics subsystem is backported from the Neon game development kit 5.8.4.<br>
      6.3.4: The Visual C++ 2005 support has been added.<br>
      6.3.5: The small changes.<br>
      6.3.6: The ordinary sprite subsystem has improved.<br>
      6.3.7: The sprite sheet subsystem has improved.<br>
      6.3.8: The background subsystem has improved.<br>
      6.3.9: The text-drawing subsystem has improved.<br>
      6.4: The small changes.<br>
      6.4.1: The collision detection subsystem has improved.<br>
      6.4.1.1: The documentation has been updated.<br>
      6.4.2: The image loader has improved.<br>
      6.4.3: The base sprite subsystem has improved.<br>
      6.4.4: The ordinary sprite subsystem has improved.<br>
      6.4.5-6.4.6: The background subsystem has improved.<br>
      6.4.7: The sprite sheet subsystem has improved.<br>
      6.4.8-6.4.9: The text drawing subsystem has improved.<br>
      6.5: The ordinary sprite subsystem has improved.<br>
      6.5.1: The background subsystem has improved.<br>
      6.5.2: The sprite sheet subsystem has improved.<br>
      6.5.3-6.5.4: The text-drawing subsystem has improved.<br>
      6.5.5: The resource manager has improved.<br>
      6.5.6: The processor usage has reduced.<br>
      6.5.7-6.5.8: The small changes.<br>
      6.5.9: The small bug in the gamepad subsystem has been fixed.<br>
      6.6: The source code synced with the Gray game development kit 2.2.7.<br>
      6.6.1: The text-drawing subsystem has improved.<br>
      6.6.2: The simple sound subsystem is backported from the Neon game development kit 5.7.8.<br>
      6.6.3: The small bug in the multimedia subsystem has been fixed.<br>
      6.6.4-6.6.6: The small changes.<br>
      6.6.7: The multimedia subsystem has improved.<br>
      6.6.8: The simple sound subsystem has been removed.<br>
      6.6.9-6.7: The multimedia subsystem has improved.<br>
      6.7.1: The timer subsystem has improved.<br>
      6.7.2-6.7.3: The sprite subsystem has improved.<br>
      6.7.4: The background subsystem has improved.<br>
      6.7.5: The text-drawing subsystem has improved.<br>
      6.7.6: The sprite subsystem has improved.<br>
      6.7.7: The rendering performance has increased.<br>
      6.7.8-6.7.9: The image loader has improved.<br>
      6.8: The small changes.<br>
      6.8.1: The ordinary sprite subsystem has improved.<br>
      6.8.2: The small changes.<br>
      6.8.3: An audio subsystem replaces the multimedia subsystem.<br>
      6.8.4: The image loader has improved.<br>
      6.8.5: The rendering performance has increased.<br>
      6.8.6: The audio subsystem has improved.<br>
      6.8.7: The small changes.<br>
      6.8.8-6.9.1: The gamepad subsystem has improved.<br>
      6.9.2: The small changes.<br>
      6.9.3: The source code synced with the Neon game development kit 6.2.6.<br>
      6.9.4: The sprite sheet subsystem has improved.<br>
      6.9.5: The source code synced with the Neon game development kit 6.3.4.<br>
      6.9.6: The source code synced with the Gray game development kit 2.5.7.<br>
      6.9.7: The gamepad support has improved.<br>
      6.9.8: The source code synced with the Gray game development kit 2.6.<br>
      6.9.9: The image resizer has improved.<br>
      7.0: The source code synced with the Neon game development kit 6.3.6.<br>
      7.0.1: The image resizer has improved.<br>
      7.0.2: The small changes.<br>
      7.0.3: The small bug has been fixed.<br>
      7.0.4-7.0.6: The gamepad support has improved.<br>
      7.0.7: The small changes.<br>
      7.0.8-7.1.6: The gamepad support has improved.<br>
      7.1.7: The small changes.<br>
      7.1.8-7.2: The image resizer has improved.<br>
      7.2.1-7.2.2: The small changes.<br>
      7.2.3-7.2.4: The image resizer has improved.<br>
      7.2.5: The small changes.<br>
      7.2.6-7.2.9: The image resizer has improved.<br>
      7.3-7.3.1: The small changes.<br>
      7.3.2: The small rendering bug has been fixed.<br>
      7.3.3: The animation subsystem is backported from the Eugene game development kit 5.6.2.<br>
      7.3.4: The background subsystem has improved.<br>
      7.3.5: The small changes.<br>
      7.3.6: The source code synced with the Simple Windows Game Framework 7.3.5.<br>
      7.3.7: The image resizer has improved.<br>
      7.3.8-7.4: The experimental branch.<br>
      7.4.1: The new subsystem has been added.<br>
      7.4.2-7.4.4: The tile-map subsystem has improved.<br>
      7.4.5: The image resizer is backported from the Eugene game development kit 7.3.5.<br>
      7.4.6: The image resizer is backported from the Eugene game development kit 7.3.6.<br>
      7.4.7-7.5: The image resizer has improved.<br>
      7.5.1: The new subsystem has been added.<br>
      7.5.2: The small changes.<br>
      7.5.3: The small bug has been fixed.<br>
      7.5.4: The coordinates conversion subsystem has improved.<br>
      7.5.5: The new subsystem has been added.<br>
      7.5.6-7.5.7: The isometric subsystem has improved.<br>
      7.5.8: The coordinates conversion subsystem has improved.<br>
      7.5.9-7.6.1: The isometric subsystem has improved.<br>
      7.6.2: The tile-map subsystem has improved.<br>
      7.6.3: The image resizer is backported from the Eugene game development kit 7.4.5.<br>
      7.6.4: The small bug in the tile-map subsystem has been fixed.<br>
      7.6.5: The coordinates conversion subsystem has improved.<br>
      7.6.6: The base graphics subsystem has improved.<br>
      7.6.7-7.7.1: The image resizer has improved.<br>
      7.7.2 - 7.7.3: The small changes.<br>
      7.7.4: The small bug has been fixed.<br>
      7.7.5-7.7.6: The image resizer has improved.<br>
      7.7.7: The small changes.<br>
      7.7.8: The isometric level subsystem has improved.<br>
      7.7.9: The isometric subsystem has improved.<br>
      7.8: The small changes.<br>
      7.8.1: The isometric subsystem has improved.<br>
      7.8.2-7.8.3: The small changes.<br>
      7.8.4: The isometric level subsystem has improved.<br>
      7.8.5: The small changes.<br>
      7.8.6: The animation subsystem has improved.<br>
      7.8.7: The sprite sheet subsystem has improved.<br>
      7.8.8: The small changes.<br>
      7.8.9: The base sprite subsystem has improved.<br>
      7.9: The text drawing subsystem has improved.<br>
      7.9.1: The base sprite subsystem has improved.<br>
      7.9.2: The background subsystem has improved.<br>
      7.9.3: The new subsystem has been added.<br>
      7.9.4: The new subsystem has been added.<br>
      7.9.5-7.9.6: The small changes.<br>
      7.9.7: The base sprite subsystem has improved.<br>
      7.9.8: The image loader has improved.<br>
      7.9.9: The small changes.<br>
      8.0-8.0.2: The image resizer has improved.<br>
      8.0.3-8.0.5: The small changes.<br>
      8.0.6: The image resizer is backported from the Eugene game development kit 7.9.9.<br>
      8.0.7: The image resizer has improved.<br>
      8.0.8-8.0.9: The texture loader has improved.<br>
      8.1-8.1.1: The picture subsystem has improved.<br>
      8.1.2: The image resizer is backported from the Eugene game development kit 8.0.5.<br>
      8.1.3: The texture loader has improved.<br>
      8.1.4: The small changes.<br>
      8.1.5: The image resizer has improved.<br>
      8.1.6-8.1.7: The small changes.<br>
      8.1.8: The small bug in the tile-map subsystem has been fixed.<br>
      8.1.9: The small bug with the keyboard and mouse input subsystem has been fixed.<br>
      8.2: The ordinary sprite subsystem has improved.<br>
      8.2.1: The background subsystem has improved.<br>
      8.2.2: The rendering performance has increased.<br>
      8.2.3-8.2.8: The small changes.<br>
      8.2.9: The rendering performance has increased.<br>
      8.3: The small bug has been fixed.<br>
      8.3.1: The small changes.<br>
      8.3.2: The rendering performance has increased.<br>
      8.3.3: The animation subsystem has improved.<br>
      8.3.4: The background subsystem has improved.<br>
      8.3.5: The source code synced with the Neon game development kit 7.2.9.<br>
      8.3.6: The small changes.<br>
      8.3.7: The source code synced with the Neon game development kit 7.3.<br>
      8.3.8: The source code synced with the Neon game development kit 7.3.1.<br>
      8.3.9: The source code synced with the Neon game development kit 7.3.2.<br>
      8.4: The source code synced with the Neon game development kit 7.3.3.<br>
      8.4.1: The small changes.<br>
      8.4.2: The base graphics subsystem has improved.<br>
      8.4.3-8.4.5: The small changes.<br>
      8.4.5.1: The documentation has been updated.<br>
      8.4.6: The small changes.<br>
      8.4.7-8.4.8: The picture subsystem has improved.<br>
      8.4.9: The image loader has improved.<br>
      8.5: The small changes.<br>
      8.5.0.1: The documentation has been updated.<br>
      8.5.1-8.5.5: The small changes.<br>
      8.5.6-8.5.7: The image loader has improved.<br>
      8.5.8-8.6.4: The small changes.<br>
      8.6.5: The rendering has improved.<br>
      8.6.6: The collision detection subsystem has improved.<br>
      8.6.7-8.6.9: The small changes.<br>
      8.7: The sprite sheet subsystem has improved.<br>
      8.7.1: The small bug has been fixed.<br>
      8.7.2: The small changes.<br>
      8.7.3: The small bug has been fixed.<br>
      8.7.4: The source code synced with the Black Game Development Kit 5.6.8.<br>
      8.7.5: The source code synced with the Black Game Development Kit 5.6.9.<br>
      8.7.6-8.7.9: The small changes.<br>
      8.8: The source code synced with the Black Game Development Kit 5.7.6.<br>
      8.8.1: The synchronization timer is backported from the Neon game development kit 7.5.8.<br>
      8.8.2: The synchronization timer is backported from the Neon game development kit 7.7.7.<br>
      8.8.3: The memory subsystem has improved.<br>
      8.8.4: The small bug has been fixed.<br>
      8.8.5: The small changes.<br>
      8.8.6: The source code synced with the Black Game Development Kit 5.8.2.<br>
      8.8.7: The image resizer has improved.<br>
      8.8.8: The animation subsystem has improved.<br>
      8.8.9: The source code synced with the Black Game Development Kit 5.8.7.<br>
      8.9: The source code synced with the Black Game Development Kit 5.8.8.<br>
      8.9.0.1: The documentation has been updated.<br>
      8.9.1: The synchronization timer is backported from the Eugene game development kit 8.8.1.<br>
      8.9.2: The source code synced with the Black Game Development Kit 5.9.<br>
      8.9.3: The source code synced with the Black Game Development Kit 5.9.4.<br>
      8.9.4: The source code synced with the Black Game Development Kit 5.9.6.<br>
      8.9.5: The keyboard input subsystem is backported from the Neon game development kit 7.9.1.<br>
      8.9.6-8.9.7: The code page converter has improved.<br>
      8.9.8-8.9.9: The small changes.<br>
      9.0: The small bug has been fixed.<br>
      9.0.1: The small changes.<br>
      9.0.2: The source code synced with the Black Game Development Kit 6.0.3.<br>
      9.0.3: The small changes.<br>
      9.0.4: The base sprite subsystem has improved.<br>
      9.0.5: The background subsystem has improved.<br>
      9.0.6: The text-drawing subsystem has improved.<br>
      9.0.7-9.0.8: The small changes.<br>
      9.0.9: The image resizer has improved.<br>
      9.1: The small changes.<br>
      9.1.0.1-9.1.0.9: The documentation has been updated.<br>
      9.2: The small changes.<br>
      9.2.0.1-9.2.0.3: The documentation has been updated.<br>
      9.2.1: The image resizer has improved.<br>
      9.2.2: The small changes.<br>
      9.2.2.1: The documentation has been updated.<br>
      9.2.3: The small changes.<br>
      9.2.4: The small bug has been fixed.<br>
      9.2.4.1-9.2.4.4: The documentation has been updated.<br>
      9.2.5: The source code synced with the Gray Game Development Kit 4.2.<br>
      9.2.6-9.2.7: The text drawing subsystem has improved.<br>
      9.2.7.1: The documentation has been updated.<br>
      9.2.8: The small bug has been fixed.<br>
      9.2.9: The small changes.<br>
      9.3: The isometric subsystem has improved.<br>
      9.3.1: The new subsystem has been added.<br>
      9.3.2-9.3.5: The isometric map subsystem has improved.<br>
      9.3.6: The small changes.<br>
      9.3.7-9.3.9: The isometric level subsystem has improved.<br>
      9.4: The isometric coordinates subsystem has improved.<br>
      9.4.1: The tile map subsystem has improved.<br>
      9.4.2: The small changes.<br>
      9.4.3: The sprite sheet subsystem has improved.<br>
      9.4.4: The resource manager has improved.<br>
      9.4.5: The small changes.<br>
      9.4.6: The image resizer has improved.<br>
      9.4.7-9.4.8: The small changes.<br>
      9.4.9: The base sprite subsystem has improved.<br>
      9.5: The source code synced with the Black game development kit 6.4.7.<br>
      9.5.1: The source code synced with the Black game development kit 6.4.9.<br>
      9.5.2: The source code synced with the Black game development kit 6.5.1.<br>
      9.5.3: The small changes.<br>
      9.5.4: The parallax background subsystem has improved.<br>
      9.5.5-9.5.6: The base sprite subsystem has improved.<br>
      9.5.7: The base graphics subsystem has improved.<br>
      9.5.8: The source code synced with the Black game development kit 7.3.3.<br>
      9.5.9: The source code synced with the Black game development kit 7.3.5.<br>
      9.6: The source code synced with the Black game development kit 7.3.8.<br>
      9.6.1: The source code synced with the Black game development kit 7.3.9.<br>
      9.6.2: The small bug has been fixed.<br>
      9.6.3: The source code synced with the Black game development kit 7.4.8.<br>
      9.6.4: The source code synced with the Black game development kit 7.5.<br>
      9.6.5: The source code synced with the Black game development kit 7.5.1.<br>
      9.6.5.1: The documentation has been updated.<br>
      9.6.6: The source code synced with the Black game development kit 7.5.2.<br>
      9.6.7-9.6.8: The small changes.<br>
      9.6.9: The base graphics subsystem has improved.<br>
      9.6.9.1-9.6.9.4: The documentation has been updated.<br>
    </big>
  </body>
</html>