<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=us-ascii">
    <title>Programmer Reference</title>
  </head>
  <body>
    <div>
      <div style="text-align: center;"> <big>Eugene game development kit:
          Programmer Reference</big> </div>
    </div>
    <p><big><br>
        Table of contents<br>
      </big></p>
    <ul id="mozToc">
      <!--mozToc h1 1 h2 2 h3 3 h4 4 h5 5 h6 6-->
      <li><a href="#mozTocId665557">Part 1. Welcome to Eugene game development
          kit</a>
        <ul>
          <li><a href="#mozTocId471990">Chapter 1. Introduction</a></li>
          <li><a href="#mozTocId85003">Chapter 2. A special thanks</a></li>
          <li><a href="#mozTocId810132">Chapter 3. License</a></li>
          <li><a href="#mozTocId336772">Chapter 4. System requirements</a></li>
          <li><a href="#mozTocId928115">Chapter 5. Troubleshooting Guide</a></li>
          <li><a href="#mozTocId491993">Chapter 6. Compilers</a></li>
          <li><a href="#mozTocId56069">Chapter 7. Platform-specific notes</a></li>
          <li><a href="#mozTocId914689">Chapter 8. The engine namespace</a></li>
          <li><a href="#mozTocId417277">Chapter 9. Custom data types</a></li>
        </ul>
      </li>
      <li><a href="#mozTocId859712">Part 2. Base things</a>
        <ul>
          <li><a href="#mozTocId312970">Chapter 1. Coordinate system</a></li>
          <li><a href="#mozTocId544184">Chapter 2. A game loop</a></li>
        </ul>
      </li>
      <li><a href="#mozTocId749937">Part 3. Graphics</a>
        <ul>
          <li><a href="#mozTocId182571">Chapter 1. The sub-namespace</a></li>
          <li><a href="#mozTocId552078">Chapter 2. Base graphics subsystem</a></li>
          <li><a href="#mozTocId289525">Chapter 3. Picture subsystem</a></li>
          <li><a href="#mozTocId501089">Chapter 4. Animation subsystem</a></li>
          <li><a href="#mozTocId102258">Chapter 5. Vertex index</a></li>
          <li><a href="#mozTocId904725">Chapter 6. Image kind</a></li>
          <li><a href="#mozTocId738557">Chapter 7. Background</a></li>
          <li><a href="#mozTocId946803">Chapter 8. Static background</a></li>
          <li><a href="#mozTocId33595">Chapter 9. Parallax</a></li>
          <li><a href="#mozTocId309905">Chapter 10. Base sprite subsystem</a></li>
          <li><a href="#mozTocId662651">Chapter 11. Ordinary sprites</a></li>
          <li><a href="#mozTocId656897">Chapter 12. Static sprites</a></li>
          <li><a href="#mozTocId146800">Chapter 13. Sprite sheet</a></li>
          <li><a href="#mozTocId752257">Chapter 14. Text</a></li>
          <li><a href="#mozTocId67980">Chapter 15. Loading images</a></li>
          <li><a href="#mozTocId450">Chapter 16. Camera</a></li>
        </ul>
      </li>
      <li><a href="#mozTocId130685">Part 4. Transformation</a>
        <ul>
          <li><a href="#mozTocId679493">Chapter 1. The sub-namespace</a></li>
          <li><a href="#mozTocId29297">Chapter 2. Cartesian coordinates and
              screen coordinates</a></li>
          <li><a href="#mozTocId122919">Chapter 3. Cartesian coordinates and
              isometric coordinates</a></li>
          <li><a href="#mozTocId175651">Chapter 4. Isometric level</a></li>
        </ul>
      </li>
      <li><a href="#mozTocId64443">Part 5. Common things</a>
        <ul>
          <li><a href="#mozTocId597525">Chapter 1. The sub-namespace</a></li>
          <li><a href="#mozTocId853711">Chapter 2. Abnormal program termination</a></li>
          <li><a href="#mozTocId656377">Chapter 3. Timer</a></li>
          <li><a href="#mozTocId381935">Chapter 4. Collision</a></li>
          <li><a href="#mozTocId429738">Chapter 5. Tile map</a></li>
        </ul>
      </li>
      <li><a href="#mozTocId611237">Part 6. Other important things</a>
        <ul>
          <li><a href="#mozTocId648026">Chapter 1. The sub-namespace</a></li>
          <li><a href="#mozTocId909723">Chapter 2. Memory</a></li>
          <li><a href="#mozTocId950985">Chapter 3. Audio</a></li>
        </ul>
      </li>
      <li><a href="#mozTocId209024">Part 7. Misc</a>
        <ul>
          <li><a href="#mozTocId608755">Chapter 1. File system</a></li>
          <li><a href="#mozTocId59386">Chapter 2. Tools</a></li>
          <li><a href="#mozTocId573582">Chapter 3. Resource Manager</a></li>
        </ul>
      </li>
      <li><a href="#mozTocId590919">Part 8. Binary files</a>
        <ul>
          <li><a href="#mozTocId200879">Chapter 1. The sub-namespace</a></li>
          <li><a href="#mozTocId961921">Chapter 2. Base binary file subsystem</a></li>
          <li><a href="#mozTocId424835">Chapter 3. File reader</a></li>
          <li><a href="#mozTocId511135">Chapter 4. File writer</a></li>
        </ul>
      </li>
      <li><a href="#mozTocId291572">Part 9. Input</a>
        <ul>
          <li><a href="#mozTocId783369">Chapter 1. The sub-namespace</a></li>
          <li><a href="#mozTocId685403">Chapter 2. Keyboard</a></li>
          <li><a href="#mozTocId686993">Chapter 3. Mouse</a></li>
          <li><a href="#mozTocId861609">Chapter 4. Gamepad</a></li>
        </ul>
      </li>
      <li><a href="#mozTocId54918">Part 10. Internal details of the engine
          subsystems</a>
        <ul>
          <li><a href="#mozTocId383177">Chapter 1. A few words for a curious
              programmer</a></li>
          <li><a href="#mozTocId318160">Chapter 2. Internal classes</a></li>
          <li><a href="#mozTocId293644">Chapter 3. Base graphics subsystem</a></li>
          <li><a href="#mozTocId472209">Chapter 4. Gamepad</a></li>
          <li><a href="#mozTocId804583">Chapter 5. Input</a></li>
          <li><a href="#mozTocId692266">Chapter 6. Audio</a></li>
        </ul>
      </li>
      <li><a href="#mozTocId670307">Version history</a></li>
    </ul>
    <h1><a class="mozTocH1" name="mozTocId665557" id="mozTocId665557"></a><big>Part
        1. Welcome to Eugene game development kit</big></h1>
    <h2><a class="mozTocH2" name="mozTocId471990" id="mozTocId471990"></a><big>Chapter
        1. Introduction<br>
      </big></h2>
    <p><big><span style="text-decoration: underline;">Introduction</span><br>
        <br>
        Hello from Russia. My name is Popov Evgeniy Alekseyevich. I am the
        individual programmer. I enjoy creating software. I also like the
        old-school video games. Do you want to develop video games for Microsoft
        Windows? You need a good game engine to do it. I made my own engine. I
        hope that my C++ game engine will be useful for many programmers.<br>
        <br>
        <span style="text-decoration: underline;">Features</span><br>
        <br>
        Let me show the engine features. Let's go.</big></p>
    <ul>
      <li><big>Open source code.</big></li>
      <li><big>Easy-to-use object-oriented design.</big></li>
      <li><big>Very fast.</big></li>
      <li><big>Minimum external dependencies: only <a href="https://learn.microsoft.com/en-us/windows/win32/directx">DirectX</a>,
          <a href="https://opengl.org">OPENGL</a>, and standard <a href="https://learn.microsoft.com/en-us/windows/win32/apiindex/windows-api-list">Windows
            API</a> libraries.</big></li>
      <li><big>You don't need to link a main program with the engine binary
          file. The engine is just the source code files.<br>
        </big></li>
    </ul>
    <p><big><span style="text-decoration: underline;">Installation</span><br>
        <br>
        How do I install this engine? Follow these steps:<br>
        <br>
        Copy these files to your project directory:</big></p>
    <ul>
      <li><big>eugenegdk.h</big></li>
      <li><big>eugenegdk.cpp</big></li>
    </ul>
    <p><big>Add it to your project.<br>
        Add this directive to your code: <i>#include "eugenegdk.h"</i><br>
        Yes. This is really all you need to do.<br>
        <br>
        <span style="text-decoration: underline;">Feedback</span><br>
        <br>
        Send me an <a href="mailto:tuzik87@inbox.ru">email</a> if you want to
        contact me.</big></p>
    <h2><a class="mozTocH2" name="mozTocId85003" id="mozTocId85003"></a><big>Chapter
        2. A special thanks</big></h2>
    <p><big>I want to say «Big thanks for technical consultation» to these
        people:</big></p>
    <ul>
      <li><a href="https://github.com/dmitrysmagin"><big>Dmitry Smagin</big></a></li>
      <li><a href="https://bsg.org.ua/"><big>Pavel Samko</big></a></li>
      <li><a href="https://github.com/EXL"><big>EXL</big></a></li>
      <li><a href="http://www.almost-university.com/"><big>Vladimir Mozhenkov</big></a></li>
      <li><a href="https://vk.com/strong666"><big>Vitaliy Molochkov</big></a></li>
      <li><a href="mailto:eyegem@mail.ru"><big>Evgenia Germanova</big></a></li>
      <li><big>DDMZ</big></li>
      <li><big>Anastasiya</big></li>
    </ul>
    <p><big>Thanks to the PVS-Studio team for the <a href="https://www.viva64.com/en/b/0614/">free
          license</a>.</big></p>
    <h2><a class="mozTocH2" name="mozTocId810132" id="mozTocId810132"></a><big>Chapter
        3. License</big></h2>
    <p><big><span style="text-decoration: underline;">Eugene game development
          kit license</span><br>
        <br>
      </big> <big>Copyright (C) 2021 – 2025 Popov Evgeniy Alekseyevich</big></p>
    <p><big>This software is provided 'as–is', without any express or implied<br>
        warranty. In no event will the authors be held liable for any damages<br>
        arising from the use of this software.<br>
        Permission is granted to anyone to use this software for any purpose,<br>
        including commercial applications, and to alter it and redistribute it<br>
        freely, subject to the following restrictions:<br>
        1. The origin of this software must not be misrepresented; you must not<br>
        claim that you wrote the original software. If you use this software<br>
        in a product, an acknowledgment in the product documentation would be<br>
        appreciated but is not required.<br>
        2. Altered source versions must be plainly marked as such, and must not
        be<br>
        misrepresented as being the original software.<br>
        3. This notice may not be removed or altered from any source
        distribution.</big><br>
      <br>
      <big><span style="text-decoration: underline;">Third–party license</span><br>
        <br>
      </big> <big>Copyright (c) 2007 – 2010 The Khronos Group Inc.</big></p>
    <p><big>Permission is hereby granted, free of charge, to any person
        obtaining a<br>
        copy of this software and/or associated documentation files (the<br>
        "Materials"), to deal in the Materials without restriction, including<br>
        without limitation the rights to use, copy, modify, merge, publish,<br>
        distribute, sublicense, and/or sell copies of the Materials, and to<br>
        permit persons to whom the Materials are furnished to do so, subject to<br>
        the following conditions:<br>
        The above copyright notice and this permission notice shall be included<br>
        in all copies or substantial portions of the Materials.<br>
        THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
        EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
        IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
        CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
        TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
        MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.</big></p>
    <h2><a class="mozTocH2" name="mozTocId336772" id="mozTocId336772"></a><big>Chapter
        4. System requirements</big></h2>
    <p><big>You can see the minimum system requirements below.</big></p>
    <table border="1">
      <tbody>
        <tr>
          <td><big>Operating system</big></td>
          <td><big>Windows XP or higher</big></td>
        </tr>
        <tr>
          <td><big>Minimum color depth</big></td>
          <td><big>16 bits</big></td>
        </tr>
        <tr>
          <td><big>Sound card</big></td>
          <td><big>Any sound card</big></td>
        </tr>
        <tr>
          <td colspan="1" rowspan="2"><big>Processor</big></td>
          <td><big>Intel Pentium II 400 MHz for 32-bit systems</big></td>
        </tr>
        <tr>
          <td><big>Intel Core 2 Duo for 64-bit systems</big></td>
        </tr>
      </tbody>
    </table>
    <h2><a class="mozTocH2" name="mozTocId928115" id="mozTocId928115"></a><big>Chapter
        5. Troubleshooting Guide</big></h2>
    <p><big>You need <a href="https://support.microsoft.com/en-us/help/2977003/the-latest-supported-visual-c-downloads">Visual
          C++ Redistributable packages</a> if your game code is compiled under
        Visual C++.</big></p>
    <h2><a class="mozTocH2" name="mozTocId491993" id="mozTocId491993"></a><big>Chapter
        6. Compilers</big></h2>
    <p><big>This engine was successfully tested with these compilers:</big></p>
    <ul>
      <li><a href="https://jmeubank.github.io/tdm-gcc/"><big>TDM-GCC</big></a></li>
      <li><a href="http://mingw-w64.org/"><big>MINGW-w64</big></a></li>
      <li><a href="http://openwatcom.org/"><big>Open Watcom</big></a></li>
      <li><big><a href="https://open-watcom.github.io/">Open Watcom V2 Fork</a><br>
        </big></li>
      <li><big>Visual C++ 2003</big></li>
      <li><big>Visual C++ 2005<br>
        </big></li>
      <li><big>Visual C++ 2008<br>
        </big></li>
      <li><big>Visual C++ 2010</big></li>
      <li><big>Visual C++ 2012</big></li>
      <li><big>Visual C++ 2013</big></li>
      <li><big>Visual C++ 2015</big></li>
      <li><big>Visual C++ 2017</big></li>
      <li><big>Visual C++ 2019</big></li>
      <li><big>Visual C++ 2022</big></li>
      <li><big>C++ Builder 2010</big></li>
      <li><big>C++ Builder XE</big></li>
      <li><big>C++ Builder XE2</big></li>
      <li><big>C++ Builder XE3</big></li>
      <li><big>C++ Builder XE4</big></li>
      <li><big>C++ Builder XE5</big></li>
      <li><big>C++ Builder XE6</big></li>
      <li><big>C++ Builder XE7</big></li>
      <li><big>C++ Builder XE8</big></li>
      <li><big>C++ Builder 10 Seattle</big></li>
      <li><big>C++ Builder 10.1 Berlin</big></li>
      <li><big>C++ Builder 10.2 Tokyo</big></li>
      <li><big>C++ Builder 10.3 Rio</big></li>
      <li><big>C++ Builder 10.4 Sydney</big></li>
      <li><big>C++ Builder 11 Alexandria</big></li>
    </ul>
    <h2><a class="mozTocH2" name="mozTocId56069" id="mozTocId56069"></a><big>Chapter
        7. Platform-specific notes</big></h2>
    <p><big><span style="text-decoration: underline;">The old processors support</span><br>
        <br>
        You need one of the following compilers for the old processors support:<br>
      </big></p>
    <ul>
      <li><big>Open Watcom</big></li>
      <li><big>Open Watcom V2 Fork</big></li>
      <li><big>Visual C++ 2003</big></li>
      <li><big>Visual C++ 2005</big></li>
    </ul>
    <p><big><span style="text-decoration: underline;">Windows XP support</span><br>
        <br>
        You need one of the following compilers for <a href="https://en.wikipedia.org/wiki/Windows_XP">Windows
          XP</a> support:<br>
      </big></p>
    <ul>
      <li><big>TDM–GCC</big></li>
      <li><big>Open Watcom</big></li>
      <li><big>Open Watcom V2 Fork</big></li>
      <li><big>Visual C++ 2003</big></li>
      <li><big>Visual C++ 2005<br>
        </big></li>
      <li><big>Visual C++ 2008</big></li>
    </ul>
    <p><big><span style="text-decoration: underline;">Windows SDK and DirectX
          SDK</span><br>
        <br>
        You need <a href="https://www.microsoft.com/en-us/download/details.aspx?id=15656">Windows
          Server 2003 SP1 Platform SDK</a> and <a href="https://archive.org/details/dxsdk_feb2005">DirectX
          SDK February 2005</a> if you are using Visual C++ 2005 Express.<br>
        <br>
        <span style="text-decoration: underline;">Notes for Visual C++ users</span></big></p>
    <p><big>Disable pre-compiled headers before starting compilation. Old Visual
        C++ users can do it via the project creation wizard.<br>
        Visual C++ 2017 or higher users must follow these steps:<br>
      </big></p>
    <ul>
      <li><big>Go to «Project Properties — C/C++ — Precompiled Headers»</big></li>
      <li><big>Set the «Precomiled Header» option to «Not Using Precompiled
          Headers».</big></li>
    </ul>
    <p><big><span style="text-decoration: underline;">Notes for MINGW-w64 and
          TDM-GCC users</span></big></p>
    <p><big>Don't forget to link your program with these files:</big></p>
    <ul>
      <li><big>user32.lib</big></li>
      <li><big>kernel32.lib</big></li>
      <li><big>gdi32.lib</big></li>
      <li><big>opengl32.lib</big></li>
      <li><big>ole32.lib</big></li>
      <li><big>strmiids.lib</big></li>
      <li><big>winmm.lib</big></li>
    </ul>
    <p><big>See the documentation of the compiler for more information about
        linking.</big></p>
    <h2><a class="mozTocH2" name="mozTocId914689" id="mozTocId914689"></a><big>Chapter
        8. The engine namespace</big></h2>
    <p><big><span style="font-style: italic;">EUGENEGDK</span> is the main
        namespace.</big> <big>All the engine classes are declared in a few
        nested namespaces.<br>
      </big></p>
    <h2><a class="mozTocH2" name="mozTocId417277" id="mozTocId417277"></a><big>Chapter
        9. Custom data types</big></h2>
    <p><big>Almost all custom data types are declared in the <span style="font-style: italic;">EUGENEGDK</span>
        namespace.<br>
      </big></p>
    <h1><a class="mozTocH1" name="mozTocId859712" id="mozTocId859712"></a><big>Part
        2. Base things</big></h1>
    <h2><a class="mozTocH2" name="mozTocId312970" id="mozTocId312970"></a><big>Chapter
        1. Coordinate system</big></h2>
    <p><big>The engine uses the standard coordinate system by default. The
        coordinates start at the top-left corner. Look at this picture to
        understand it.</big></p>
    <p><img style="width: 107px; height: 111px;" src="coordinate_system.png"><br>
    </p>
    <h2><a class="mozTocH2" name="mozTocId544184" id="mozTocId544184"></a><big>Chapter
        2. A game loop</big></h2>
    <p><big>What is the main point in your game? A game loop. You can see the
        structure of a typical game loop below.</big></p>
    <p><big><img style="width: 379px; height: 354px;" src="game_loop.png"><br>
      </big></p>
    <h1><a class="mozTocH1" name="mozTocId749937" id="mozTocId749937"></a><big>Part
        3. Graphics</big></h1>
    <h2><a class="mozTocH2" name="mozTocId182571" id="mozTocId182571"></a><big>Chapter
        1. The sub-namespace</big></h2>
    <p><big>All classes in this section are declared in the <em>Graphics</em>
        sub-namespace.</big></p>
    <h2><a class="mozTocH2" name="mozTocId552078" id="mozTocId552078"></a><big>Chapter
        2. Base graphics subsystem</big></h2>
    <p><big><span style="text-decoration: underline;">Introduce</span></big></p>
    <p><big>The base graphics subsystem does render a game scene. This subsystem
        uses <a href="http://opengl.org/">OPENGL</a> for rendering. All modern
        video cards support hardware-accelerated OPENGL. The software OPENGL
        will be activated if</big> <big>the acceleration is not available.</big><br>
      <br>
      <big><span style="text-decoration: underline;">Render performance</span><br>
        <br>
        Always use the latest video card drivers. It may increase rendering
        performance. You can also try to change the screen resolution if you
        have low rendering performance.<br>
        <br>
        <span style="text-decoration: underline;">FPS limitation</span><br>
        <br>
        FPS is an important thing. Many FPS are needed for good animation, but
        it also needs high processor usage. The FPS limit is 60 by default. It
        has an ideal value.<br>
        <br>
        <span style="text-decoration: underline;">Work with the base graphics
          subsystem</span><br>
        <br>
        The <span style="font-style: italic;">Screen</span> class provides
        access to the base graphics subsystem. Let's look at the publicly
        available methods.<br>
        <br>
        <span style="font-style: italic;">void Screen::clear_screen(); -</span>
        Clear the screen. Fill it with black color.<br>
        <br>
        <span style="font-style: italic;">void Screen::initialize(); -</span>
        Initialize the base graphic subsystem with the default screen
        resolution.<br>
        <br>
      </big> <big style="font-style: italic;">void Screen::initialize(const
        unsigned int width,</big> <big style="font-style: italic;">const
        unsigned int height</big><big><span style="font-style: italic;">); -</span>
        Initialize the base graphic subsystem with the custom screen resolution.<br>
        <br>
      </big> <big><span style="font-style: italic;">bool Screen::sync(); -</span>
        Show the current content of the back buffer on the screen. Return false
        if a game is terminated. This method uses the FPS limits and waits
        between frames.<br>
        <br>
        <span style="font-style: italic;">bool Screen::update(); -</span> Show
        the current content of the back buffer on the screen. Return false if a
        game is terminated. This method ignores the FPS limit and needs high
        processor usage.<br>
        <br>
        <span style="font-style: italic;">bool Screen::sync(const bool limit); -</span>
        Show the current content of the back buffer on the screen. Return false
        if a game is terminated.<br>
        <br>
        <span style="font-style: italic;">bool Screen::is_ready(); -</span>
        Return true if the subsystem has already been initialized.<br>
        <br>
        <span style="font-style: italic;">bool Screen::is_accelerated() const; -</span>
        Return true if the render is hardware-accelerated.<br>
        <br>
        <span style="font-style: italic;">bool Screen::is_software() const; -</span>
        Return true if the software render is active.<br>
        <br>
        <span style="font-style: italic;">unsigned int Screen::get_fps() const;
          -</span> Return the current FPS value.<br>
        <br>
        <span style="font-style: italic;">unsigned int Screen::get_color()
          const; -</span> Return the current color depth in bits per pixel.<br>
        <br>
        <span style="font-style: italic;">unsigned int Screen::get_width()
          const; -</span> Return the screen width in pixels.<br>
        <br>
        <span style="font-style: italic;">unsigned int Screen::get_height()
          const; -</span> Return the screen height in pixels.<br>
        <br>
        <span style="font-style: italic;">bool Screen::check_x(const unsigned
          int x) const; -</span> Return true if the x-coordinate is valid.<br>
        <br>
      </big> <big><span style="font-style: italic;">bool Screen::check_y(const
          unsigned int y) const; -</span> Return true if the y-coordinate is
        valid.<br>
      </big></p>
    <p><big><span style="font-style: italic;">bool
          Screen::check_horizontal_border(const EUGENEGDK::BOX target) const; -</span>
        Return true if a game object is collided with the horizontal screen
        border.<br>
      </big></p>
    <p><big><span style="font-style: italic;">bool
          Screen::check_vertical_border(const EUGENEGDK::BOX target) const; -</span>
        Return true if a game object is collided with the vertical screen
        border.</big><br>
      <br>
      <big><span style="font-style: italic;">Screen *Screen::get_handle(); -</span>
        Return the handle to the base graphics subsystem object.</big></p>
    <h2><a class="mozTocH2" name="mozTocId289525" id="mozTocId289525"></a><big>Chapter
        3. Picture subsystem</big></h2>
    <p><big><span style="text-decoration: underline;">An important subsystem</span><br>
        <br>
        The picture subsystem implements image storage.<br>
        <br>
      </big> <big><span style="text-decoration: underline;">Work with the
          picture subsystem</span><br>
        <br>
        The <span style="font-style: italic;">Picture</span> class provides
        simple access to the picture subsystem. Don't use it directly. Let's
        look at the publicly available methods.<br>
        <br>
        <span style="font-style: italic;">unsigned int *Picture::get_image(); -</span>
        Return the handle to the image storage.<br>
        <br>
      </big> <big><span style="font-style: italic;">void
          Picture::destroy_image(); -</span> Destroy an image in the storage.<br>
        <br>
      </big> <big><span style="font-style: italic;">bool
          Picture::is_storage_empty() const; -</span> Return true if the storage
        is empty.<br>
        <br>
        <span style="font-style: italic;">unsigned int
          Picture::get_image_width() const; -</span> Return the image width in
        pixels.<br>
        <br>
        <span style="font-style: italic;">unsigned int
          Picture::get_image_height() const; -</span> Return the image height in
        pixels.<br>
        <br>
        <span style="font-style: italic;">size_t Picture::get_pixel_amount()
          const; -</span> Return the amount of the image pixels.<br>
        <br>
      </big> <big><span style="font-style: italic;">size_t
          Picture::get_image_lenght() const; -</span> Return the image length in
        bytes.</big></p>
    <h2><a class="mozTocH2" name="mozTocId501089" id="mozTocId501089"></a><big>Chapter
        4. Animation subsystem</big></h2>
    <p><big><span style="text-decoration: underline;">An important subsystem</span><br>
        <br>
        The animation subsystem lets you control the animation frames.<br>
        <br>
        <span style="text-decoration: underline;">Frame indexing</span></big></p>
    <p><big>The first frame index is 1.<br>
        <br>
        <span style="text-decoration: underline;">Work with the animation
          subsystem</span><br>
        <br>
        <span style="font-style: italic;">The Animation</span> class provides
        simple access to the animation subsystem. Don't use it directly. Let's
        look at the publicly available methods.<br>
        <br>
        <span style="font-style: italic;">unsigned int Animation::get_frames()
          const; -</span> Return the number of the frames.<br>
        <br>
        <span style="font-style: italic;">unsigned int Animation::get_frame()
          const; -</span> Return the current frame.<br>
        <br>
      </big> <big><span style="font-style: italic;">bool
          Animation::is_last_frame() const; -</span> Return true if the current
        frame is the last frame.<br>
        <br>
      </big> <big><span style="font-style: italic;">bool
          Animation::check_frame(const unsigned int target) const; -</span>
        Return true if the target frame is valid.<br>
      </big></p>
    <h2><a id="mozTocId102258" class="mozTocH2" name="mozTocId102258"></a><big>Chapter
        5. Vertex index<br>
      </big></h2>
    <p><big>The vertex index looks like the predefined constants. You can see it
        below.</big></p>
    <table style="width: 358px; height: 139px;" border="1">
      <tbody>
        <tr>
          <td><big>Vertex index<br>
            </big></td>
          <td><big>Description</big></td>
        </tr>
        <tr>
          <td><big>FIRST_VERTEX<br>
            </big></td>
          <td><big>The first vertex<br>
            </big></td>
        </tr>
        <tr>
          <td><big>SECOND_VERTEX</big></td>
          <td><big>The second vertex<br>
            </big></td>
        </tr>
        <tr>
          <td style="vertical-align: top;"><big>THIRD_VERTEX</big></td>
          <td style="vertical-align: top;"><big>The third vertex<br>
            </big></td>
        </tr>
        <tr>
          <td style="vertical-align: top;"><big>LAST_VERTEX</big></td>
          <td style="vertical-align: top;"><big>The last vertex</big></td>
        </tr>
      </tbody>
    </table>
    <h2><a class="mozTocH2" name="mozTocId904725" id="mozTocId904725"></a><big>Chapter
        6. Image kind</big></h2>
    <p><big>The image types look like the predefined constants. You can see it
        below.</big></p>
    <table style="width: 723px; height: 106px;" border="1">
      <tbody>
        <tr>
          <td><big>Image kind<br>
            </big></td>
          <td><big>Description</big></td>
        </tr>
        <tr>
          <td><big>HORIZONTAL_ANIMATED</big></td>
          <td><big>The horizontal animated background or the horizontal strip</big></td>
        </tr>
        <tr>
          <td><big>VERTICAL_ANIMATED</big></td>
          <td><big>The vertical animated background or the vertical strip<br>
            </big></td>
        </tr>
      </tbody>
    </table>
    <h2><a class="mozTocH2" name="mozTocId738557" id="mozTocId738557"></a><big>Chapter
        7. Background</big></h2>
    <p><big><span style="text-decoration: underline;">Level decoration</span><br>
        <br>
        A background is a big image</big> <big>with a few frames</big><big>.
        Any game has a background. The background will be stretched to the
        screen resolution before rendering the game scene. The background
        transparency is always disabled.<br>
        <br>
        The horizontal animated backgrounds look like the horizontal photo
        ribbons. The vertical animated backgrounds look like the vertical photo
        ribbons.<span style="text-decoration: underline;"><br>
        </span></big></p>
    <p><big><span style="text-decoration: underline;">Work with the background</span><br>
        <br>
        Just use the <span style="font-style: italic;">Background</span> class
        to work with the background. Let's look at the publicly available
        methods.<br>
        <br>
        <span style="font-style: italic;">Background *Background::get_handle();
          -</span> Return the handle to the background object.<br>
        <br>
      </big> <big><span style="font-style: italic;">void
          Background::prepare(const Screen *screen); -</span> Prepare for
        drawing.<br>
        <br>
        <span style="font-style: italic;">void Background::prepare(Screen
          &amp;screen); -</span> Prepare for drawing.<br>
        <br>
        <span style="font-style: italic;">void Background::prepare(const
          unsigned int width, const unsigned int height); -</span> Prepare for
        drawing.<br>
        <br>
        <span style="font-style: italic;">void Background::disable_mirror(); -</span>
        Disable background mirroring mode.<br>
        <br>
        <span style="font-style: italic;">void Background::horizontal_mirror();
          -</span> Set horizontal background mirroring mode.<br>
        <br>
        <span style="font-style: italic;">void Background::vertical_mirror(); -</span>
        Set vertical background mirroring mode.<br>
        <br>
        <span style="font-style: italic;">void Background::complex_mirror(); -</span>
        Set both horizontal and vertical background mirroring modes.</big></p>
    <p><big><span style="font-style: italic;">void Background::set_target(const
          unsigned int target); -</span> Set the target frame.<br>
        <br>
        <span style="font-style: italic;">void Background::step(); -</span>
        Increase the target frame. Set it to 1 if the target is more than the
        number of frames.<br>
        <br>
        <span style="font-style: italic;">void Background::set_settings(const
          EUGENEGDK::IMAGE_KIND kind, const unsigned int frames); -</span> Set
        the background settings.<br>
        <br>
        <span style="font-style: italic;">void Background::load(Image
          *background,const EUGENEGDK::IMAGE_KIND kind, const unsigned int
          frames); -</span> Load a background</big> <big>from the buffer</big><big>.<br>
        <br>
        <span style="font-style: italic;">void Background::load(Image
          &amp;background,const EUGENEGDK::IMAGE_KIND kind, const unsigned int
          frames); -</span> Load a background</big> <big>from the buffer.</big><big><br>
      </big> <big><br>
        <span style="font-style: italic;">void Background::load(const char
          *name,const EUGENEGDK::IMAGE_KIND kind, const unsigned int frames); -</span>
        Load a background</big> <big>from the target file</big><big>.<br>
      </big> <big><br>
        <span style="font-style: italic;">void Background::draw(); -</span> Draw
        a background.<br>
        <br>
        <span style="font-style: italic;">void Background::draw(const unsigned
          int target); -</span> Draw the target frame.<br>
        <br>
        <span style="font-style: italic;">void Background::destroy_image(); -</span>
        Destroy a background image.<br>
        <br>
        <span style="font-style: italic;">void Background::destroy(); -</span>
        Destroy a background image and the texture.<br>
        <br>
      </big> <big><span style="font-style: italic;">bool Background::is_load()
          const; -</span> Return true if a background has already been loaded.</big><br>
      <big><br>
        <span style="font-style: italic;">bool Background::is_last_frame()
          const; -</span> Return true if the current frame is the last frame.<br>
        <br>
      </big> <big><span style="font-style: italic;">bool
          Background::check_frame(const unsigned int target) const; -</span>
        Return true if the target frame is valid.</big><br>
      <br>
      <big><span style="font-style: italic;">unsigned int
          Background::get_frame() const; -</span> Return the current frame.<br>
        <br>
        <span style="font-style: italic;">unsigned int Background::get_frames()
          const; -</span> Return the number of the frames.<br>
        <br>
        <span style="font-style: italic;">unsigned int Background::get_width()
          const; -</span> Return the width of the background.<br>
        <br>
        <span style="font-style: italic;">unsigned int Background::get_height()
          const; -</span> Return the height of the background.<br>
        <br>
        <span style="font-style: italic;">EUGENEGDK::IMAGE_KIND
          Background::get_kind() const; -</span> Get the background kind.<br>
        <br>
        <span style="text-decoration: underline;">A background texture</span><br>
        <br>
        The background doesn't draw if the background texture doesn't exist. It
        will automatically be created when you load an image.<br>
        <br>
        <span style="text-decoration: underline;">Important notice</span><br>
        <br>
        Always call the <span style="font-style: italic;">prepare</span> after
        the background has been loaded.<br>
      </big></p>
    <h2><a class="mozTocH2" name="mozTocId946803" id="mozTocId946803"></a><big>Chapter
        8. Static background</big></h2>
    <p><big><span style="text-decoration: underline;">A few words about static
          background</span><br>
        <br>
        The static background is a simple kind of background. It contains one
        frame only.<br>
      </big> <big><br>
        <span style="text-decoration: underline;">Work with the background</span><br>
        <br>
        Just use the <span style="font-style: italic;">Scene</span> class to
        work with the static background. Let's look at the publicly available
        methods.<br>
        <br>
        <span style="font-style: italic;">Scene *Scene::get_handle(); -</span>
        Return the handle to the background object.<br>
        <br>
      </big> <big><span style="font-style: italic;">void Scene::prepare(const
          Screen *screen); -</span> Prepare for drawing.<br>
        <br>
        <span style="font-style: italic;">void Scene::prepare(Screen
          &amp;screen); -</span> Prepare for drawing.<br>
        <br>
        <span style="font-style: italic;">void Scene::prepare(const unsigned int
          width, const unsigned int height); -</span> Prepare for drawing.<br>
        <br>
        <span style="font-style: italic;">void Scene::disable_mirror(); -</span>
        Disable background mirroring mode.<br>
        <br>
        <span style="font-style: italic;">void Scene::horizontal_mirror(); -</span>
        Set horizontal background mirroring mode.<br>
        <br>
        <span style="font-style: italic;">void Scene::vertical_mirror(); -</span>
        Set vertical background mirroring mode.<br>
        <br>
        <span style="font-style: italic;">void Scene::complex_mirror(); -</span>
        Set both horizontal and vertical background mirroring modes.<br>
      </big> <big><br>
        <span style="font-style: italic;">void Scene::load(Image *background); -</span>
        Load a background from the buffer.<br>
        <br>
        <span style="font-style: italic;">void Scene::load(Image &amp;
          background); -</span> Load a background</big> <big>from the buffer.</big><big><br>
        <br>
      </big> <big><span style="font-style: italic;">void Scene::load(</span></big><big

        style="font-style: italic;">const char *name</big><big><span style="font-style: italic;">);
          -</span> Load a background from the target file.</big><br>
      <big><br>
        <span style="font-style: italic;">void Scene::draw(); -</span> Draw a
        background.<br>
        <br>
        <span style="font-style: italic;">void Scene::destroy_image(); -</span>
        Destroy a background image.<br>
        <br>
        <span style="font-style: italic;">void Scene::destroy(); -</span>
        Destroy a background image and destroy the texture.<br>
        <br>
      </big> <big><span style="font-style: italic;">bool Scene::is_load()
          const; -</span> Return true if a static background has already been
        loaded.</big><br>
      <br>
      <big><span style="font-style: italic;">unsigned int Scene::get_width()
          const; -</span> Return the width of the background.<br>
        <br>
        <span style="font-style: italic;">unsigned int Scene::get_height()
          const; -</span> Return the height of the background.<br>
        <br>
        <span style="text-decoration: underline;">A background texture</span><br>
        <br>
        The background doesn't draw if the background texture doesn't exist. It
        will automatically be created when you load an image.<br>
        <br>
        <span style="text-decoration: underline;">Important notice</span></big></p>
    <p><big>Always call the <span style="font-style: italic;">prepare</span>
        after the background has been loaded.<br>
      </big></p>
    <h2><a id="mozTocId33595" class="mozTocH2" name="mozTocId33595"></a><big>Chapter
        9. Parallax<br>
      </big></h2>
    <p><big><span style="text-decoration: underline;">A few words about parallax</span><br>
        <br>
        The parallax background is a background with scrolling support.</big></p>
    <p style="text-decoration: underline;"><big>Speed</big></p>
    <p><big>The scrolling speed should be a positive number.</big><br>
      <big><br>
        <span style="text-decoration: underline;">Work with the background</span><br>
        <br>
        Just use the <span style="font-style: italic;">Parallax</span> class to
        work with the parallax background. Let's look at the publicly available
        methods.<br>
        <br>
        <span style="font-style: italic;">Parallax *Parallax::get_handle(); -</span>
        Return the handle to the background object.<br>
        <br>
      </big> <big><span style="font-style: italic;">void
          Parallax::prepare(const Screen *screen); -</span> Prepare for drawing.<br>
        <br>
        <span style="font-style: italic;">void Parallax::prepare(Screen
          &amp;screen); -</span> Prepare for drawing.<br>
        <br>
        <span style="font-style: italic;">void Parallax::prepare(const unsigned
          int width, const unsigned int height); -</span> Prepare for drawing.<br>
        <br>
        <span style="font-style: italic;">void Parallax::disable_mirror(); -</span>
        Disable background mirroring mode.<br>
        <br>
        <span style="font-style: italic;">void Parallax::horizontal_mirror(); -</span>
        Set horizontal background mirroring mode.<br>
        <br>
        <span style="font-style: italic;">void Parallax::vertical_mirror(); -</span>
        Set vertical background mirroring mode.<br>
        <br>
        <span style="font-style: italic;">void Parallax::complex_mirror(); -</span>
        Set both horizontal and vertical background mirroring modes.<br>
      </big> <big><br>
        <span style="font-style: italic;">void Parallax::load(Image
          *background); -</span> Load a background from the buffer.<br>
        <br>
        <span style="font-style: italic;">void Parallax::load(Image &amp;
          background); -</span> Load a background</big> <big>from the buffer.</big><big><br>
        <br>
      </big> <big><span style="font-style: italic;">void Parallax::load(</span></big><big

        style="font-style: italic;">const char *name</big><big><span style="font-style: italic;">);
          -</span> Load a background from the target file.<br>
      </big></p>
    <p><big><span style="font-style: italic;">void Parallax::set_speed(const
          float horizontal,const float vertical);</span> - Set the scrolling
        speed.<br>
        <br>
        <span style="font-style: italic;">float Parallax::get_horizontal_speed()
          const; -</span> Return the horizontal speed.<br>
        <br>
        <span style="font-style: italic;">float Parallax::get_vertical_speed()
          const; -</span> Return the vertical speed.<br>
      </big> <big><br>
        <span style="font-style: italic;">void Parallax::draw(); -</span> Draw a
        background.<br>
        <br>
        <span style="font-style: italic;">void Parallax::destroy_image(); -</span>
        Destroy a background image.<br>
        <br>
        <span style="font-style: italic;">void Parallax::destroy(); -</span>
        Destroy a background image and destroy the texture.<br>
        <br>
      </big> <big><span style="font-style: italic;">bool Parallax::is_load()
          const; -</span> Return true if a parallax background has already been
        loaded.</big><br>
      <br>
      <big><span style="font-style: italic;">unsigned int Parallax::get_width()
          const; -</span> Return the width of the background.<br>
        <br>
        <span style="font-style: italic;">unsigned int Parallax::get_height()
          const; -</span> Return the height of the background.<br>
        <br>
        <span style="text-decoration: underline;">A background texture</span><br>
        <br>
        The background doesn't draw if the background texture doesn't exist. It
        will automatically be created when you load an image.<br>
        <br>
        <span style="text-decoration: underline;">Important notice</span></big></p>
    <p><big>Always call the <span style="font-style: italic;">prepare</span>
        after the background has been loaded.</big></p>
    <h2><a class="mozTocH2" name="mozTocId309905" id="mozTocId309905"></a><big>Chapter
        10. Base sprite subsystem</big></h2>
    <p><big><span style="text-decoration: underline;">A small, important thing</span><br>
        <br>
        A sprite is a transparent image. It is useful for many things: enemies,
        bonuses, etc.<br>
      </big> <big><br>
        <span style="text-decoration: underline;">Work with the base sprite
          subsystem</span><br>
        <br>
        The <span style="font-style: italic;">Billboard</span> class provides
        simple access to the base sprite subsystem. Don't use it directly. Let's
        look at the publicly available methods.</big></p>
    <p><big><span style="font-style: italic;">void
          Billboard::set_texture_coordinates(const EUGENEGDK::VERTEX_INDEX
          index, const float u, const float v);</span> - Set the texture
        coordinates.<br>
      </big> <big><br>
      </big> <big><span style="font-style: italic;">void
          Billboard::set_transparent(const bool enabled); -</span> Enable or
        disable the transparent mode.<br>
        <br>
        <span style="font-style: italic;">bool Billboard::get_transparent()
          const; -</span> Return true if the transparent mode is enabled.<br>
        <br>
      </big> <big><span style="font-style: italic;">void
          Billboard::set_position(const unsigned int x, const unsigned int y); -</span>
        Set the sprite position.<br>
        <br>
        <span style="font-style: italic;">void Billboard::set_start(const
          unsigned int x, const unsigned int y); -</span> Set the start position
        of the sprite.<br>
        <br>
        <span style="font-style: italic;">void Billboard::set_size(const
          unsigned int width, const unsigned int height); -</span> Change the
        sprite size.<br>
        <br>
      </big> <big><span style="font-style: italic;">void Billboard::set_x(const
          unsigned int x); -</span> Set the x-coordinate of the sprite position.<br>
        <br>
      </big> <big><span style="font-style: italic;">void Billboard::set_y(const
          unsigned int y); -</span> Set the y-coordinate of the sprite position.<br>
        <br>
      </big> <big><span style="font-style: italic;">void
          Billboard::set_width(const unsigned int width); -</span> Change the
        sprite width.<br>
        <br>
        <span style="font-style: italic;">void Billboard::set_height(const
          unsigned int height); -</span> Change the sprite height.<br>
        <br>
      </big> <big><em>unsigned int Billboard::increase_x(); -</em> Increase the
        x-coordinate and return it</big><big>.<br>
        <br>
      </big> <big><em>unsigned int Billboard::decrease_x(); -</em> Decrease the
        x-coordinate and return it</big><big>.<br>
        <br>
      </big> <big><span style="font-style: italic;">unsigned int
          Billboard::increase_y(); -</span> Increase the y-coordinate and return
        it.<br>
        <br>
      </big> <big><em>unsigned int Billboard::decrease_y(); -</em> Decrease the
        y-coordinate and return it</big><big>.<br>
        <br>
      </big> <big><em>unsigned int Billboard::increase_x(const unsigned int
          increment); -</em> Increase</big> <big>the</big> <big>x-coordinate
        with the user value and return</big> <big>it.<br>
        <br>
      </big> <big><em>unsigned int Billboard::decrease_x(const unsigned int
          decrement); -</em> Decrease</big> <big>the</big> <big>x-coordinate
        with the user value and return</big> <big>it</big><big>.<br>
        <br>
      </big> <big><em>unsigned int Billboard::increase_y(const unsigned int
          increment); -</em> Increase</big> <big>the</big> <big>y-coordinate
        with the user value and return</big> <big>it</big><big>.<br>
        <br>
      </big> <big><em>unsigned int Billboard::decrease_y(const unsigned int
          decrement);</em> - Decrease</big> <big>the</big> <big>y-coordinate
        with the user value and return</big> <big>it</big><big>.<br>
        <br>
        <span style="font-style: italic;">unsigned int Billboard::get_start_x()
          const; -</span> Return</big> <big>the</big> <big>x-coordinate of</big>
      <big>the</big> <big>start position.<br>
        <br>
        <span style="font-style: italic;">unsigned int Billboard::get_start_y()
          const; -</span> Return</big> <big>the</big> <big>y-coordinate of</big>
      <big>the</big> <big>start position.<br>
        <br>
      </big> <big><span style="font-style: italic;">unsigned int
          Billboard::get_x() const; -</span> Return the x-coordinate of the
        sprite position.<br>
        <br>
        <span style="font-style: italic;">unsigned int Billboard::get_y() const;
          -</span> Return the y-coordinate of the sprite position.<br>
        <br>
        <span style="font-style: italic;">unsigned int Billboard::get_width()
          const; -</span> Return the width of the sprite.<br>
        <br>
        <span style="font-style: italic;">unsigned int Billboard::get_height()
          const; -</span> Return the height of the sprite.<br>
        <br>
      </big> <big><span style="font-style: italic;">bool Billboard::is_load()
          const; -</span> Return true if the sprite has already been loaded.</big><br>
      <big><br>
      </big> <big><span style="font-style: italic;">EUGENEGDK::BOX
          Billboard::get_box() const; -</span> Return the collision-related
        information.<br>
        <br>
        <span style="font-style: italic;">void Billboard::disable_mirror(); -</span>
        Disable sprite mirroring mode.<br>
        <br>
        <span style="font-style: italic;">void Billboard::horizontal_mirror(); -</span>
        Set horizontal sprite mirroring mode.<br>
        <br>
        <span style="font-style: italic;">void Billboard::vertical_mirror(); -</span>
        Set vertical sprite mirroring mode.<br>
        <br>
        <span style="font-style: italic;">void Billboard::complex_mirror(); -</span>
        Set both horizontal and vertical sprite mirroring modes.<br>
        <br>
        <span style="font-style: italic;">void Billboard::go_start(); -</span>
        Set the sprite position to the start position.<br>
        <br>
      </big> <big><span style="font-style: italic;">void
          Billboard::go_start_x(); -</span> Set</big> <big>the x-coordinate of</big>
      <big>the sprite position to the</big> <big>x-coordinate of</big> <big>the
        start position.<br>
        <br>
      </big> <big><span style="font-style: italic;">void
          Billboard::go_start_y(); -</span> Set the</big> <big>y-coordinate of
        the</big> <big>sprite position to the</big> <big>y-coordinate of the</big>
      <big>start position.</big><br>
      <br>
      <big><span style="font-style: italic;">void Billboard::draw(); -</span>
        Draw a sprite.<br>
        <br>
      </big> <big><span style="font-style: italic;">void Billboard::draw(const
          unsigned int x, const unsigned int y); -</span> Set the sprite
        position and draw it.<br>
        <br>
      </big> <big><em>void Billboard::draw(const bool transparency); -</em> Set
        the transparent mode and draw a sprite.<br>
        <br>
      </big> <big><em>void Billboard::draw(const bool transparency, const
          unsigned int x, const unsigned int y); -</em> Set the transparent mode
        and draw a sprite at the target position.</big></p>
    <h2><a class="mozTocH2" name="mozTocId662651" id="mozTocId662651"></a><big>Chapter
        11. Ordinary sprites</big></h2>
    <p><big><span style="text-decoration: underline;">Sprite types</span><br>
        <br>
        There are two kinds of ordinary sprites: the horizontal strips and the
        vertical strips. It is a small image with a few frames.<br>
        The horizontal strip looks like the horizontal photo ribbon. The
        vertical strip looks like the vertical photo ribbon.<br>
      </big> <big><br>
      </big> <big><span style="text-decoration: underline;">Work with the
          sprites</span><br>
        <br>
        Just use the <span style="font-style: italic;">Sprite</span> class to
        work with a sprite. It is derived from three classes:</big> <big><span

          style="font-style: italic;">Billboard</span>, <span style="font-style: italic;">Animation,</span>
        and <span style="font-style: italic;">Picture.</span></big> <big>Let's
        look at the publicly available methods.<br>
        <br>
        <span style="font-style: italic;">void Sprite::set_settings(const
          EUGENEGDK::IMAGE_KIND kind, const unsigned int frames); -</span> Set
        the sprite settings.<br>
        <br>
        <span style="font-style: italic;">void Sprite::load(Image *buffer,const
          EUGENEGDK::IMAGE_KIND kind, const unsigned int frames); -</span> Load
        a sprite from the buffer.<br>
      </big> <big><br>
        <span style="font-style: italic;">void Sprite::load(Image
          &amp;buffer,const EUGENEGDK::IMAGE_KIND kind, const unsigned int
          frames); -</span> Load a sprite</big> <big>from the buffer.</big><big><br>
      </big> <big><br>
        <span style="font-style: italic;">void Sprite::load(const char
          *name,const EUGENEGDK::IMAGE_KIND kind, const unsigned int frames); -</span>
        Load a sprite</big> <big>from the target file</big><big>.<br>
      </big> <big><br>
        <span style="font-style: italic;">void Sprite::set_target(const unsigned
          int target); -</span> Set the target frame.<br>
        <br>
        <span style="font-style: italic;">void Sprite::step(); -</span> Increase
        the target frame. Set it to 1 if the target is more than the number of
        frames.<br>
        <br>
        <span style="font-style: italic;">EUGENEGDK::IMAGE_KIND
          Sprite::get_kind() const; -</span> Get the sprite kind.<br>
        <br>
      </big> <big><span style="font-style: italic;">Sprite
          *Sprite::get_handle(); -</span> Return the handle to the sprite
        object.<br>
        <br>
        <span style="font-style: italic;">void Sprite::clone(Sprite *target); -</span>
        Create a copy of the sprite if the storage of the target sprite is not
        empty.<br>
        <br>
        <span style="font-style: italic;">void Sprite::clone(Sprite
          &amp;target); -</span> Create a copy of the sprite if the storage of
        the target sprite is not empty.<br>
        <br>
        <span style="font-style: italic;">void Sprite::destroy(); -</span>
        Destroy a sprite image and destroy the texture.</big><big><br>
      </big> <big><br>
        <span style="text-decoration: underline;">A sprite texture</span><br>
        <br>
        A sprite doesn't draw if the sprite texture doesn't exist. It will
        automatically be created when you load or clone a sprite.<br>
      </big></p>
    <h2><a class="mozTocH2" name="mozTocId656897" id="mozTocId656897"></a><big>Chapter
        12. Static sprites</big></h2>
    <p><big><span style="text-decoration: underline;">A few words about static
          sprite</span><br>
        <br>
        The static sprite is a simple kind of sprite. It contains one frame
        only.<br>
        <br>
      </big> <big><span style="text-decoration: underline;">Work with the
          static sprites</span><br>
        <br>
        Just use the <span style="font-style: italic;">Cartoon</span> class to
        work with a static sprite. It is derived from two classes:</big> <big><span

          style="font-style: italic;">billboard</span> and <span style="font-style: italic;">picture.</span></big>
      <big>Let's look at the publicly available methods.<br>
        <br>
        <span style="font-style: italic;">void Cartoon::load(Image *buffer); -</span>
        Load a sprite</big> <big>from the buffer</big><big>.<br>
      </big> <big><br>
        <span style="font-style: italic;">void Cartoon::load(Image &amp;buffer);
          -</span> Load a sprite</big> <big>from the buffer.</big><big><br>
      </big> <big><br>
        <span style="font-style: italic;">void Cartoon::load(</span></big><big style="font-style: italic;">const
        char *name</big><big><span style="font-style: italic;">); -</span> Load
        a sprite from the target file.<br>
        <br>
      </big> <big><span style="font-style: italic;">Cartoon
          *Cartoon::get_handle(); -</span> Return the handle to the sprite
        object.<br>
        <br>
        <span style="font-style: italic;">void Cartoon::clone(Cartoon *target);
          -</span> Create a copy of the sprite if the storage of the target
        sprite is not empty.<br>
        <br>
        <span style="font-style: italic;">void Cartoon::clone(Cartoon
          &amp;target); -</span> Create a copy of the sprite if the storage of
        the target sprite is not empty.<br>
        <br>
        <span style="font-style: italic;">void Cartoon::destroy(); -</span>
        Destroy a sprite image and the texture.</big><big><br>
      </big> <big><br>
        <span style="text-decoration: underline;">A sprite texture</span><br>
        <br>
        A sprite doesn't draw if the sprite texture doesn't exist. It will
        automatically be created when you load or clone a sprite.</big></p>
    <h2><a class="mozTocH2" name="mozTocId146800" id="mozTocId146800"></a><big>Chapter
        13. Sprite sheet</big></h2>
    <p><big><span style="text-decoration: underline;">Some words about a sprite
          sheet</span><br>
        <br>
        A sprite sheet is a special kind of animated sprite. Each frame has a
        fixed size. The sheet is a matrix of frames. Look at this picture to
        understand it.<br>
        <br>
        <img style="width: 380px; height: 249px;" src="sheet.png"><br>
        <br>
        <span style="text-decoration: underline;">Rows and columns</span><br>
        <br>
        The first row index is 1. The first column index is 1.<br>
      </big> <big><br>
      </big> <big><span style="text-decoration: underline;">Work with the sheet</span><br>
        <br>
        The <span style="font-style: italic;">Sheet</span> class provides
        access to the sprite sheet subsystem.</big> <big>It is derived from
        three</big> <big>classes: <span style="font-style: italic;">Billboard</span>,
        <span style="font-style: italic;">Picture,</span> and <span style="font-style: italic;">Animation.</span>
        Let's look at the publicly available methods.<br>
        <br>
        <span style="font-style: italic;">bool Sheet::check_row(const unsigned
          int target) const; -</span> Return true if the target row is valid.<br>
        <br>
        <span style="font-style: italic;">bool Sheet::check_column(const
          unsigned int target) const; -</span> Return true if the target column
        is valid.<br>
        <br>
      </big> <big style="font-style: italic;">unsigned int Sheet::get_row(</big><big

        style="font-style: italic;">const unsigned int target</big><big><span style="font-style: italic;">)
          const; -</span> Return row of the target frame.<br>
        <br>
        <span style="font-style: italic;">unsigned int Sheet::get_column(</span></big><big

        style="font-style: italic;">const unsigned int target</big><big><span style="font-style: italic;">)
          const; -</span> Return</big> <big>column</big> <big>of the target
        frame</big><big>.<br>
        <br>
      </big> <big><span style="font-style: italic;">unsigned int
          Sheet::calculate(const unsigned int row, const unsigned int column)
          const; -</span> Calculate the frame by row and column.<br>
        <br>
      </big> <big><span style="font-style: italic;">unsigned int
          Sheet::get_rows() const; -</span> Return the number of rows.<br>
        <br>
        <span style="font-style: italic;">unsigned int Sheet::get_columns()
          const; -</span> Return</big> <big>the number of column</big><big>s.<br>
        <br>
      </big> <big><span style="font-style: italic;">void Sheet::destroy()</span></big><big><span

          style="font-style: italic;">; -</span></big> <big>Destroy a sprite
        sheet image and the texture.<br>
        <br>
      </big> <big><span style="font-style: italic;">void Sheet::select(const
          unsigned int row,const unsigned int column); -</span> Select the
        target frame by row and column.<br>
        <br>
      </big> <big><span style="font-style: italic;">void
          Sheet::set_target(const unsigned int target); -</span> Set the target
        frame.<br>
        <br>
      </big> <big><span style="font-style: italic;">void Sheet::step(); -</span>
        Increase the target frame. Set it to 1 if the target is more than the
        number of frames.<br>
        <br>
      </big> <big><span style="font-style: italic;">void Sheet::load(Image
          *sheet, const unsigned int row_amount, const unsigned int
          column_amount); -</span> Load a sprite sheet from the buffer.<br>
        <br>
        <span style="font-style: italic;">void Sheet::load(Image &amp;sheet,
          const unsigned int row_amount, const unsigned int column_amount); -</span>
        Load a sprite sheet from the buffer.<br>
        <br>
        <span style="font-style: italic;">void Sheet::load(const char *name,
          const unsigned int row_amount, const unsigned int column_amount); -</span>
        Load a sprite sheet from a target file.</big></p>
    <p><big><span style="font-style: italic;">Sheet *Sheet::get_handle(); -</span>
        Return the handle to the sprite sheet.<br>
        <br>
        <span style="font-style: italic;">void Sheet::clone(Sheet *target); -</span>
        Create a copy of the sprite sheet if the storage of the target sprite
        sheet is not empty.<br>
        <br>
        <span style="font-style: italic;">void Sheet::clone(Sheet &amp;target);
          -</span> Create a copy of the sprite sheet if the storage of the
        target sprite sheet is not empty.<br>
        <br>
        <span style="text-decoration: underline;">A sprite sheet texture</span><br>
        <br>
        A sprite sheet doesn't draw if the sprite sheet texture doesn't exist.
        It will automatically be created when you load a sheet.<br>
      </big></p>
    <h2><a class="mozTocH2" name="mozTocId752257" id="mozTocId752257"></a><big>Chapter
        14. Text</big></h2>
    <p><big><span style="text-decoration: underline;">How do I draw a text?</span><br>
        <br>
        Just use the text subsystem to draw a text. This subsystem needs a font
        for text drawing. You must load a font before starting to draw the text.
        The font is just a sprite sheet with 16 rows and 16 columns.<br>
        <br>
        <span style="text-decoration: underline;">Valid characters</span><br>
        <br>
        Only 8-bit</big> <big>characters are</big> <big>supported.<br>
        <br>
      </big> <big style="text-decoration: underline;">Text orientation</big><br>
      <br>
      <big>The text orientation looks like the predefined constants. You can see
        it below.<br>
      </big></p>
    <table style="width: 420px; height: 85px;" border="1">
      <tbody>
        <tr>
          <td><big>Text orientation<br>
            </big></td>
          <td><big>Description</big></td>
        </tr>
        <tr>
          <td><big>HORIZONTAL_TEXT</big></td>
          <td><big>The horizontally oriented text<br>
            </big></td>
        </tr>
        <tr>
          <td><big>VERTICAL_TEXT</big></td>
          <td><big>The vertically oriented text</big></td>
        </tr>
      </tbody>
    </table>
    <p><big><span style="text-decoration: underline;">Work with the text</span><br>
        <br>
        The <span style="font-style: italic;">Text</span> class provides a
        simple interface to the text subsystem. Let's look at the publicly
        available methods.<br>
        <br>
        <span style="font-style: italic;">Text *Text::get_handle(); -</span>
        Return the handle to the text drawing subsystem.<br>
        <br>
        <span style="font-style: italic;">EUGENEGDK::TEXT_KIND
          Text::get_orientation() const; -</span> Get the current text
        orientation.<br>
        <br>
        <span style="font-style: italic;">void Text::set_orientation(const
          EUGENEGDK::TEXT_KIND target); -</span> Set the current text
        orientation.<br>
        <br>
      </big> <big><span style="font-style: italic;">bool Text::is_font_load()
          const; -</span> Return true if the font has already been loaded.</big><br>
      <br>
      <big><span style="font-style: italic;">unsigned int Text::get_font_width()
          const; -</span> Get the current font width in pixels.<br>
        <br>
        <span style="font-style: italic;">unsigned int Text::get_font_height()
          const; -</span> Get the current font height in pixels.<br>
      </big></p>
    <big><span style="font-style: italic;">unsigned int Text::get_x() const; -</span>
      Get the x-coordinate of the text output position.<br>
      <br style="font-style: italic;">
      <span style="font-style: italic;">unsigned int Text::get_y() const; -</span>
      Get the y-coordinate of the text output position.</big>
    <p><big><span style="font-style: italic;">void Text::set_position(const
          unsigned int x, const unsigned int y); -</span> Set the output
        position.<br>
        <br style="font-style: italic;">
        <span style="font-style: italic;">void Text::set_size(const unsigned int
          width, const unsigned int height); -</span> Change the font size.<br>
        <br>
      </big> <big><span style="font-style: italic;">void Text::set_width(const
          unsigned int width); -</span> Set the font width.<br>
        <br>
      </big> <big><span style="font-style: italic;">void Text::set_height(const
          unsigned int height); -</span> Set the font height.</big><br>
      <big><br>
        <span style="font-style: italic;">void Text::set_settings(const unsigned
          int width, const unsigned int height, const EUGENEGDK::TEXT_KIND
          kind); -</span> Set the text output settings.<br>
        <br>
        <span style="font-style: italic;">void Text::load_font(Image *font); -</span>
        Load a font from the buffer.<br>
        <br>
        <span style="font-style: italic;">void Text::load_font(Image &amp;font);
          -</span> Load a font from the buffer.<br>
        <br>
        <span style="font-style: italic;">void Text::load_font(const char
          *name); -</span> Load a font from the target file.<br>
        <br>
        <span style="font-style: italic;">void Text::print(const char target); -</span>
        Draw a single character at the current position.<br>
        <br>
        <span style="font-style: italic;">void Text::print(const unsigned int x,
          const unsigned int y, const char target); -</span> Draw a single
        character at the specific position.<br>
      </big></p>
    <big><span style="font-style: italic;">size_t Text::print(const char
        *target); -</span> Draw a text at the current position and return the
      text length.</big>
    <p><big><span style="font-style: italic;">size_t Text::print(const unsigned
          int x, const unsigned int y, const char *target); -</span> Draw a text
        at the specific position and return the text length.<br>
        <br>
        <span style="font-style: italic;">void Text::disable_mirror(); -</span>
        Disable text mirroring mode.<br>
        <br>
        <span style="font-style: italic;">void Text::horizontal_mirror(); -</span>
        Set horizontal text mirroring mode.<br>
        <br>
        <span style="font-style: italic;">void Text::vertical_mirror(); -</span>
        Set vertical text mirroring mode.<br>
        <br>
        <span style="font-style: italic;">void Text::complex_mirror(); -</span>
        Set both horizontal and vertical text mirroring modes.<br>
        <br>
        <span style="font-style: italic;">void Text::destroy_image(); -</span>
        Destroy a font image.<br>
        <br>
        <span style="font-style: italic;">void Text::destroy_font(); -</span>
        Destroy a font image and the texture.<br>
      </big></p>
    <h2><a class="mozTocH2" name="mozTocId67980" id="mozTocId67980"></a><big>Chapter
        15. Loading images</big></h2>
    <p><big><span style="text-decoration: underline;">Load an image from a file</span><br>
        <br>
        Use the image loader to load an image from a file. The <span style="font-style: italic;">Image</span>
        class provides simple access to the image loader. It is a simple class
        with a few methods.<br>
        <br>
      </big> <big><span style="font-style: italic;">unsigned char *</span></big><big><span

          style="font-style: italic;">Image::load(const char *name); -</span>
        Load a Truevision TGA image and return the handle to the image buffer.<br>
        <br>
        <span style="font-style: italic;">unsigned char *Image::get_data(); -</span>
        Return the handle to the image buffer.<br>
        <br>
        <span style="font-style: italic;">unsigned int Image::get_width() const;
          -</span> Return the width of the current image.<br>
        <br>
        <span style="font-style: italic;">unsigned int Image::get_height()
          const; -</span> Return the height of the current image.<br>
        <br>
        <span style="font-style: italic;">size_t Image::get_length() const; -</span>
        Return the length of the image buffer in bytes.<br>
        <br>
        <span style="font-style: italic;">Image *Image::get_handle(); -</span>
        Return the handle to the image loader.<br>
        <br>
        <span style="font-style: italic;">void Image::destroy_image(); -</span>
        Destroy the current image and free the image buffer.<br>
        <br>
        <span style="text-decoration: underline;">Important remark</span><br>
        <br>
        A new image will replace the current image if the current image already
        exists. An incorrect image will be ignored and won't load.<br>
        The source image will be converted to <a href="https://en.wikipedia.org/wiki/RGBA">RGBA</a>
        format. Pixels equal to the top-left pixel will be marked as
        transparent.<br>
        <br>
        <span style="text-decoration: underline;">Supported format</span><br>
      </big></p>
    <p><big>All loading images must have the correct specifications. You can
        load an image from a 24-bit</big> <big><a href="https://en.wikipedia.org/wiki/Truevision_TGA">Truevision
          TGA</a> picture.</big></p>
    <p><big><span style="text-decoration: underline;">Recommend software</span><br>
        <br>
        You can use a wide range of graphics software to convert your images to
        the correct format. I recommend using <a href="https://www.gimp.org/">GIMP</a>
        to do it. It is a powerful image editor.<br>
      </big></p>
    <h2><a id="mozTocId450" class="mozTocH2" name="mozTocId450"></a><big>Chapter
        16. Camera</big></h2>
    <big><span style="text-decoration: underline;">A few words about the camera</span><br>
      <br>
      The 2D camera defines a size of visible area. It will be stretched to the
      screen resolution before rendering the game scene.<br>
      <br style="text-decoration: underline;">
      <span style="text-decoration: underline;">Work with the camera</span><br>
      <br>
      The <span style="font-style: italic;">Camera</span> class provides simple
      access to the camera subsystem. Let's look at the publicly available
      methods.<br>
      <br>
      <span style="font-style: italic;">Camera *Camera::get_handle(); -</span>
      Return the handle to the camera subsystem.<br>
      <br>
      <span style="font-style: italic;">unsigned int Camera::increase_x(); -</span>
      Increase the x-coordinate of the camera offset and return it.<br>
      <br>
      <span style="font-style: italic;">unsigned int Camera::decrease_x(); -</span>
      Decrease the x-coordinate of the camera offset and return it.<br>
      <br style="font-style: italic;">
      <span style="font-style: italic;">unsigned int Camera::increase_y(); -</span>
      Increase the y-coordinate of the camera offset and return it.<br>
      <br>
      <span style="font-style: italic;">unsigned int Camera::decrease_y(); -</span>
      Decrease the y-coordinate of the camera offset and return it.<br>
      <br>
      <span style="font-style: italic;">unsigned int Camera::increase_x(const
        unsigned int increment); -</span> Increase the x-coordinate of the
      camera offset with the user value and return it.<br>
      <br style="font-style: italic;">
      <span style="font-style: italic;">unsigned int Camera::decrease_x(const
        unsigned int decrement); -</span> Decrease the x-coordinate of the
      camera offset with the user value and return it.<br>
      <br>
      <span style="font-style: italic;">unsigned int Camera::increase_y(const
        unsigned int increment); -</span> Increase the y-coordinate of the
      camera offset with the user value and return it.<br>
      <br>
      <span style="font-style: italic;">unsigned int Camera::decrease_y(const
        unsigned int decrement); -</span> Decrease the y-coordinate of the
      camera offset with the user value and return it.<br>
      <br>
      <span style="font-style: italic;">unsigned int Camera::get_x() const; -</span>
      Return the x-coordinate of the camera offset.<br>
      <br style="font-style: italic;">
      <span style="font-style: italic;">unsigned int Camera::get_y() const; -</span>
      Return the y-coordinate of the camera offset.<br>
      <br style="font-style: italic;">
      <span style="font-style: italic;">unsigned int Camera::get_screen_width()
        const; -</span> Return the screen width in pixels.<br>
      <br>
      <span style="font-style: italic;">unsigned int Camera::get_screen_height()
        const; -</span> Return the screen height in pixels.<br>
      <br>
      <span style="font-style: italic;">unsigned int
        Camera::get_viewport_width() const; -</span> Return the viewport width
      in pixels.<br>
      <br>
      <span style="font-style: italic;">unsigned int
        Camera::get_viewport_height() const; -</span> Return the viewport height
      in pixels.<br>
      <br>
      <span style="font-style: italic;">unsigned int Camera::get_highest_x()
        const; -</span> Return the highest allowable x-coordinate of the current
      visible area.<br>
      <br style="font-style: italic;">
      <span style="font-style: italic;">unsigned int Camera::get_highest_y()
        const; -</span> Return the highest allowable y-coordinate of the current
      visible area.<br>
      <br>
      <span style="font-style: italic;">unsigned int Camera::get_lowest_x()
        const; -</span> Return the lowest allowable x-coordinate of the current
      visible area.<br>
      <br>
      <span style="font-style: italic;">unsigned int Camera::get_lowest_y()
        const; -</span> Return the lowest allowable y-coordinate of the current
      visible area.<br>
      <br>
      <span style="font-style: italic;">unsigned int
        Camera::get_highest_x_offset() const; -</span> Return the highest
      allowable x-offset of the camera.<br>
      <br style="font-style: italic;">
      <span style="font-style: italic;">unsigned int
        Camera::get_highest_y_offset() const; -</span> Return the highest
      allowable y-offset of the camera.<br>
      <br>
      <span style="font-style: italic;">unsigned int Camera::get_world_x(const
        unsigned screen_int x) const; -</span> Convert the screen x-coordinate
      to the world x-coordinate.<br>
      <br>
      <span style="font-style: italic;">unsigned int Camera::get_world_y(const
        unsigned screen_int y) const; -</span> Convert the screen y-coordinate
      to the world y-coordinate.<br>
      <br>
      <span style="font-style: italic;">unsigned int Camera::set_x(const
        unsigned int x); -</span> Set the x-coordinate of the camera offset and
      return it.<br>
      <br style="font-style: italic;">
      <span style="font-style: italic;">unsigned int Camera::set_y(const
        unsigned int y); -</span> Set the y-coordinate of the camera offset and
      return it.<br>
      <br>
      <span style="font-style: italic;">void Camera::initialize(const unsigned
        int width, const unsigned int height); -</span> Initialize the subsystem
      and set the screen size.<br>
      <br style="font-style: italic;">
      <span style="font-style: italic;">void Camera::initialize(Screen *screen);
        -</span> Initialize the subsystem and set the screen size.<br>
      <br style="font-style: italic;">
      <span style="font-style: italic;">void Camera::initialize(Screen
        &amp;screen); -</span> Initialize the subsystem and set the screen size.<br>
      <br>
      <span style="font-style: italic;">void Camera::set_viewport(const unsigned
        int width, const unsigned int height); -</span> Set the viewport
      settings.<br>
      <br>
      <span style="font-style: italic;">void Camera::set_offset(const unsigned
        int x, const unsigned int y); -</span> Set the camera offset.<br>
      <br>
      <span style="font-style: italic;">bool
        Camera::check_horizontal_border(const EUGENEGDK::BOX target) const; -</span>
      Return true if a game object is collided with the horizontal visible area
      border.<br>
      <br>
      <span style="font-style: italic;">bool Camera::check_vertical_border(const
        EUGENEGDK::BOX target) const; -</span> Return true if a game object is
      collided with the vertical visible area border.<br>
      <br>
      <span style="font-style: italic;">void Camera::update(); -</span> Update
      the camera.<br>
      <br>
      <span style="font-style: italic;">void Camera::reset(); -</span> Reset the
      camera settings.<br>
      <br>
      <span style="text-decoration: underline;">Important remark</span><br>
      <br>
      Always set the viewport size after initializing the camera. Always update
      the camera before drawing.</big>
    <h1><a class="mozTocH1" name="mozTocId130685" id="mozTocId130685"></a><big>Part
        4. Transformation</big></h1>
    <h2><a class="mozTocH2" name="mozTocId679493" id="mozTocId679493"></a><a id="mozTocId833933"

        class="mozTocH2" name="mozTocId833933"></a><big>Chapter 1. The
        sub-namespace</big></h2>
    <p><big>All classes in this section are declared in the <span style="font-style: italic;">Transformation</span>
        sub-namespace.<br>
      </big></p>
    <h2><a class="mozTocH2" name="mozTocId29297" id="mozTocId29297"></a><a id="mozTocId979980"

        class="mozTocH2" name="mozTocId979980"></a><big>Chapter 2. Cartesian
        coordinates and screen coordinates</big></h2>
    <p><big><span style="text-decoration: underline;">Cartesian coordinates</span><br>
        <br>
        The Cartesian coordinates start at the center of the screen. Look at
        this picture to understand it.<br>
      </big></p>
    <p><big><img style="width: 107px; height: 111px;" src="cartesian_system.png"><br>
        <br>
        <span style="text-decoration: underline;">Coordinates conversion</span><br>
        <br>
        You can convert the Cartesian coordinates to the screen coordinates. You
        can also convert the screen coordinates to the Cartesian coordinates.<br>
        <br>
        Just use the <span style="font-style: italic;">Coordinates</span> class
        to do it. Let's look at the publicly available methods.<br>
        <br>
        <span style="font-style: italic;">Coordinates
          *Coordinates::get_handle(); -</span> Return the handle to the
        coordinates conversion subsystem.<br>
        <br>
        <span style="font-style: italic;">void Coordinates::initialize(const int
          viewport_width, const int viewport_height); -</span> Initialize the
        subsystem.<br>
        <br>
        <span style="font-style: italic;">int Coordinates::get_viewport_width()
          const; -</span> Return</big> <big>the</big> <big>viewport width in
        pixels.<br>
        <br>
        <span style="font-style: italic;">int Coordinates::get_viewport_height()
          const; -</span> Return</big> <big>the</big> <big>viewport height in
        pixels.<br>
        <br>
        <span style="font-style: italic;">int
          Coordinates::get_lowest_cartesian_x() const; -</span> Return the
        lowest allowable Cartesian x-coordinate.<br>
        <br>
        <span style="font-style: italic;">int
          Coordinates::get_highest_cartesian_x() const; -</span> Return</big> <big>the</big>
      <big>highest allowable Cartesian x-coordinate.<br>
        <br>
        <span style="font-style: italic;">int
          Coordinates::get_lowest_cartesian_y() const; -</span> Return</big> <big>the</big>
      <big>lowest allowable Cartesian y-coordinate.<br>
        <br>
        <span style="font-style: italic;">int
          Coordinates::get_highest_cartesian_y() const; -</span> Return</big> <big>the</big>
      <big>highest allowable Cartesian y-coordinate.<br>
        <br>
      </big> <big><span style="font-style: italic;">bool
          Coordinates::check_cartesian_x(const int x) const; -</span> Return
        true if the Cartesian x-coordinate is valid.<br>
        <br>
        <span style="font-style: italic;">bool
          Coordinates::check_cartesian_y(const int y) const; -</span> Return
        true if the Cartesian y-coordinate is valid.</big><br>
      <big><br>
        <span style="font-style: italic;">int Coordinates::get_screen_x(const
          int x) const; -</span> Convert the Cartesian x-coordinate to the
        screen x-coordinate.<br>
        <br>
        <span style="font-style: italic;">int Coordinates::get_screen_y(const
          int y) const; -</span> Convert the Cartesian y-coordinate to the
        screen y-coordinate.<br>
        <br>
        <span style="font-style: italic;">int Coordinates::get_cartesian_x(const
          int x) const; -</span> Convert the screen x-coordinate to the
        Cartesian x-coordinate.<br>
        <br>
        <span style="font-style: italic;">int Coordinates::get_cartesian_y(const
          int y) const; -</span> Convert the screen y-coordinate to the
        Cartesian y-coordinate.<br>
      </big></p>
    <h2><a class="mozTocH2" name="mozTocId122919" id="mozTocId122919"></a><big>Chapter
        3. Cartesian coordinates and isometric coordinates</big></h2>
    <p><big><span style="text-decoration: underline;">A few words about
          isometric games</span><br>
        <br>
        <a href="https://en.wikipedia.org/wiki/Isometric_projection">Isometry</a>
        is a very popular way for pseudo-3D games. Many old-school games are
        isometric games.<br>
        <br>
      </big> <big><span style="text-decoration: underline;">Coordinates
          conversion</span><br>
        <br>
        You can convert the Cartesian coordinates to the isometric coordinates.
        You can also convert the isometric coordinates to the Cartesian
        coordinates. Just use the <span style="font-style: italic;">Isometric</span>
        class to do it. Let's look at the publicly available methods.<br>
      </big> <big><br>
        <span style="font-style: italic;">static int
          Isometric::get_isometric_x(const int x, const int y); -</span> C</big><big>onvert
        the x-coordinate from</big> <big>the</big> <big>Cartesian system to</big>
      <big>the</big> <big>isometric system.<br>
        <br>
        <span style="font-style: italic;">static int
          Isometric::get_isometric_y(const int x, const int y); -</span></big> <big>C</big><big>onvert
        the y-coordinate from</big> <big>the</big> <big>Cartesian system to</big>
      <big>the</big> <big>isometric system.<br>
        <br>
        <span style="font-style: italic;">static int
          Isometric::get_cartesian_x(const int x, const int y); -</span></big> <big>C</big><big>onvert
        the x-coordinate from</big> <big>the</big> <big>isometric system to</big>
      <big>the</big> <big>Cartesian system.<br>
        <br>
        <span style="font-style: italic;">static int
          Isometric::get_cartesian_y(const int x, const int y); -</span></big> <big>C</big><big>onvert
        the y-coordinate from</big> <big>the</big> <big>isometric system to</big>
      <big>the</big> <big>Cartesian system.</big></p>
    <h2><a id="mozTocId175651" class="mozTocH2" name="mozTocId175651"></a><big>Chapter
        4. Isometric level<br>
      </big></h2>
    <p><big>The isometric level subsystem is intended to help you create an
        isometric level. Just use the <span style="font-style: italic;">Level</span>
        class to do it. Let's look at the publicly available methods.</big></p>
    <p><big><span style="font-style: italic;">Level *Level::get_handle(); -</span>
        Return the handle to the isometric level subsystem.<br>
        <br>
        <span style="font-style: italic;">void Level::initialize(const int
          tile_width, const int tile_height); -</span> Initialize the subsystem.<br>
      </big></p>
    <p><big><span style="font-style: italic;">void Level::set_offset(const int
          x_offset, const int y_offset); -</span> Set the coordinates offset.<br>
      </big></p>
    <p><big><span style="font-style: italic;">int Level::get_x_offset() const; -</span>
        Return the x-offset.<br>
        <br>
        <span style="font-style: italic;">int Level::get_y_offset() const; -</span>
        Return the y-offset.<br>
      </big></p>
    <p><big><span style="font-style: italic;">int Level::get_x(const int row,
          const int column) const; -</span> Return the target x-coordinate.<br>
        <br>
        <span style="font-style: italic;">int Level::get_y(const int row, const
          int column) const; -</span> Return the target y-coordinate.</big></p>
    <h1><a class="mozTocH1" name="mozTocId64443" id="mozTocId64443"></a><big>Part
        5. Common things</big></h1>
    <h2><a class="mozTocH2" name="mozTocId597525" id="mozTocId597525"></a><big>Chapter
        1. The sub-namespace</big></h2>
    <p><big>All classes in this section are declared in the <span style="font-style: italic;">Common</span>
        sub-namespace.<br>
      </big></p>
    <h2><a class="mozTocH2" name="mozTocId853711" id="mozTocId853711"></a><big>Chapter
        2. Abnormal program termination</big></h2>
    <p><big>You can use the <span style="font-style: italic;">Halt</span>
        function to terminate a program. This function is declared in the <em>EGENEGDK</em>
        namespace.<br>
        <br>
        <span style="font-style: italic;">void EUGENEGDK::Halt(const char
          *message); -</span> Terminate the program. Write an error message to
        the log file if logging is enabled.</big></p>
    <h2><a class="mozTocH2" name="mozTocId656377" id="mozTocId656377"></a><big>Chapter
        3. Timer</big></h2>
    <p><big>A timer is a very useful thing. Just use the <span style="font-style: italic;">Timer</span>
        class to work with the timer. Let's look at the publicly available
        methods.<br>
        <br>
        <span style="font-style: italic;">Timer *Timer::get_handle(); -</span>
        Return the handle to the timer.<br>
        <br>
        <span style="font-style: italic;">void Timer::set_timer(const double
          seconds); -</span> Set the timer interval and initialize the start
        point.<br>
        <br>
        <span style="font-style: italic;">double Timer::get_interval() const; -</span>
        Return the current timer interval.<br>
        <br>
        <span style="font-style: italic;">bool Timer::check_timer(); -</span>
        Return true and reinitialize the start point if the interval between the
        stop and start points is large or equal to specific seconds.</big></p>
    <h2><a class="mozTocH2" name="mozTocId381935" id="mozTocId381935"></a><big>Chapter
        4. Collision</big></h2>
    <p><big><span style="text-decoration: underline;">An important thing for any
          game</span><br>
        <br>
        What is an important thing for a video game? A collision.<br>
        <br>
        <span style="text-decoration: underline;">Collision detail</span><br>
      </big></p>
    <p><big>The detector uses the bounding box collision method to detect a
        collision. The collision-related information is stored in a custom data
        type.<br>
        <br>
        <span style="font-style: italic;">typedef struct</span><span style="font-style: italic;"><br>
          {</span><br>
        <span style="font-style: italic;">unsigned int x;</span><br>
        <span style="font-style: italic;">unsigned int y;</span><br>
        <span style="font-style: italic;">unsigned int width;</span><br>
        <span style="font-style: italic;">unsigned int height;</span><span style="font-style: italic;"><br>
          } BOX;</span><br>
        <br>
        <span style="text-decoration: underline;">Work with a collision detector</span><br>
        <br>
        The <span style="font-style: italic;">Collision</span> class provides
        easy access to collision detectors. It is a simple class with a few
        methods. Let's look at the publicly available methods.<br>
        <br>
        <span style="font-style: italic;">Collision *Collision::get_handle(); -</span>
        Return the handle to the collision detector.<br>
      </big><br>
      <big><span style="font-style: italic;">void Collision::set_target(const
          EUGENEGDK::BOX first_target, const EUGENEGDK::BOX second_target); -</span>
        Set the targets for the collision detector.<br>
        <br>
        <span style="font-style: italic;">bool Collision::check_collision()
          const; -</span> Return true if the collision between two objects is
        accepted.<br>
        <br>
        <span style="font-style: italic;">bool Collision::check_collision(const
          EUGENEGDK::BOX first_target, const EUGENEGDK::BOX second_target); -</span>
        Set the targets and check collisions between them.<br>
      </big></p>
    <h2><a class="mozTocH2" name="mozTocId429738" id="mozTocId429738"></a><big>Chapter
        5. Tile</big> <big>map</big></h2>
    <p><big><span style="text-decoration: underline;">A few words about tile
          maps</span><br>
        <br>
        The tile</big> <big>map is a tile matrix. A tile is a small, non</big><big>-</big><big>transparent
        sprite. A tile</big> <big>map is a very useful thing for the
        background.<br>
        <br>
        <span style="text-decoration: underline;">Rows and columns</span><br>
        <br>
        The first row index is 0. The first column index is 0.<br>
        <br>
        <span style="text-decoration: underline;">Work with the tile map</span><br>
        <br>
        The <span style="font-style: italic;">Tilemap</span> class provides
        easy access to the tile map.</big> <big>It is a simple class with few
        methods. Let's look at the publicly available methods.<br>
        <br>
        <span style="font-style: italic;">Tilemap *Tilemap::get_handle(); -</span>
        Return the handle to the tile-map subsystem.<br>
        <br>
        <span style="font-style: italic;">void Tilemap::initialize(const
          unsigned int tile_width, const unsigned int tile_height); -</span>
        Initialize the subsystem.<br>
        <br>
      </big> <big style="font-style: italic;">unsigned int</big> <big><span style="font-style: italic;">Tilemap::get_tile_width()
          const; -</span> Return the tile width in pixels.<br>
        <br>
      </big> <big style="font-style: italic;">unsigned int</big> <big><span style="font-style: italic;">Tilemap::get_tile_height()
          const; -</span> Return the tile height in pixels.<br>
        <br>
      </big> <big style="font-style: italic;">unsigned int</big> <big style="font-style: italic;">Tilemap::get_x(const</big>
      <big style="font-style: italic;">unsigned int row</big><big><span style="font-style: italic;">)
          const; -</span> Get the x-coordinate from the target row.<br>
        <br>
      </big> <big style="font-style: italic;">unsigned int</big> <big style="font-style: italic;">Tilemap::get_y(const</big>
      <big style="font-style: italic;">unsigned int column</big><big><span style="font-style: italic;">)
          const; -</span> Get the y-coordinate from the target column.<br>
        <br>
      </big> <big style="font-style: italic;">unsigned int</big> <big style="font-style: italic;">Tilemap::get_row(const</big>
      <big style="font-style: italic;">unsigned int x</big><big><span style="font-style: italic;">)
          const; -</span> Get the row from the x-coordinate.<br>
        <br>
      </big> <big style="font-style: italic;">unsigned int</big> <big style="font-style: italic;">Tilemap::get_column(const</big>
      <big style="font-style: italic;">unsigned int y</big><big><span style="font-style: italic;">)
          const; -</span> Get the column from the y-coordinate.<br>
        <br>
      </big> <big style="font-style: italic;">unsigned int</big> <big style="font-style: italic;">Tilemap::get_row_amount(const</big>
      <big style="font-style: italic;">unsigned int viewport_width</big><big><span

          style="font-style: italic;">) const; -</span> Get the maximum number
        of the visible rows.<br>
        <br>
      </big> <big style="font-style: italic;">unsigned int</big> <big style="font-style: italic;">Tilemap::get_column_amount(const</big>
      <big style="font-style: italic;">unsigned int viewport_width</big><big><span

          style="font-style: italic;">) const; -</span> Get the maximum number
        of the visible columns.<br>
        <br>
        <span style="font-style: italic;">unsigned int
          Tilemap::get_tile_amount(const unsigned int viewport_width, const
          unsigned int viewport_height) const; -</span> Get the maximum number
        of the visible tiles.<br>
        <br>
        <span style="font-style: italic;">bool Tilemap::check_row(const unsigned
          int row,const unsigned int viewport_width) const; -</span> Return true
        if the row is valid.<br>
        <br>
        <span style="font-style: italic;">bool Tilemap::check_column(const
          unsigned int column,const unsigned int viewport_height) const; -</span>
        Return true if the column is valid.<br>
        <br>
        <span style="font-style: italic;">EUGENEGDK::BOX Tilemap::get_box(</span></big><big

        style="font-style: italic;">const</big> <big style="font-style: italic;">unsigned
        int row,const unsigned int column</big><big><span style="font-style: italic;">)
          const; -</span> Return the collision-related information.</big></p>
    <h1><a class="mozTocH1" name="mozTocId611237" id="mozTocId611237"></a><big>Part
        6. Other important things</big></h1>
    <h2><a class="mozTocH2" name="mozTocId648026" id="mozTocId648026"></a><big>Chapter
        1. The sub-namespace</big></h2>
    <p><big>All classes in this section are declared in the <span style="font-style: italic;">Misc</span>
        sub-namespace.<br>
      </big></p>
    <h2><a class="mozTocH2" name="mozTocId909723" id="mozTocId909723"></a><big>Chapter
        2. Memory</big></h2>
    <p><big>RAM is an important resource. Just use the <span style="font-style: italic;">Memory</span>
        class to get the total memory size and free memory size. Let's look at
        the publicly available methods.<br>
        <br>
        <span style="font-style: italic;">unsigned long long int
          Memory::get_total_physical(); -</span> Return the total physical
        memory size in bytes.<br>
        <br>
        <span style="font-style: italic;">unsigned long long int
          Memory::get_free_physical(); -</span> Return the free physical memory
        size in bytes.<br>
        <br>
        <span style="font-style: italic;">unsigned long long int
          Memory::get_total_virtual(); -</span> Return the total <a href="https://en.wikipedia.org/wiki/Virtual_memory">virtual
          memory</a> size in bytes.<br>
        <br>
        <span style="font-style: italic;">unsigned long long int
          Memory::get_free_virtual(); -</span> Return the free <a href="https://en.wikipedia.org/wiki/Virtual_memory">virtual
          memory</a> size in bytes.<br>
        <br>
        <span style="font-style: italic;">unsigned long long int
          Memory::get_physical_usge(); -</span> Return the physical memory usage
        in bytes.<br>
        <br>
        <span style="font-style: italic;">unsigned long long int
          Memory::get_virtual_usge(); -</span> Return the virtual memory usage
        in bytes.<br>
        <br>
        <span style="font-style: italic;">unsigned long int Memory::get_usage();
          -</span> Return the percentage of the physical memory used.</big><big><br>
      </big></p>
    <h2><a class="mozTocH2" name="mozTocId950985" id="mozTocId950985"></a><big>Chapter
        3. Audio</big></h2>
    <p><big><span style="text-decoration: underline;">A few words about the
          audio subsystem</span><br>
        <br>
        This subsystem is intended for playing music and sounds. <a href="https://en.wikipedia.org/wiki/WAV">Waveform
          Audio File Format</a>, <a href="https://en.wikipedia.org/wiki/MP3">MPEG
          Audio Layer 3,</a> and <a href="https://en.wikipedia.org/wiki/Windows_Media_Audio">Windows
          Media Audio</a> are supported.<br>
      </big> <big><br>
        <span style="text-decoration: underline;">Additional formats</span><br>
        <br>
        You can use an additional format if you install third-party codecs.<br>
        <br>
        <span style="text-decoration: underline;">Working with audio</span><br>
        <br>
        Just use the <span style="font-style: italic;">Audio</span> class to
        work with audio. Let's look at the publicly available methods.<br>
        <br>
        <span style="font-style: italic;">void Audio::initialize(); -</span>
        Initialize the subsystem.<br>
        <br>
        <span style="font-style: italic;">void Audio::initialize(const char
          *target); -</span> Initialize the subsystem and load a sound file.<br>
        <br>
        <span style="font-style: italic;">void Audio::load(const char *target);
          -</span> Load a sound file.<br>
        <br>
        <span style="font-style: italic;">void Audio::play(); -</span> Play a
        sound.<br>
        <br>
        <span style="font-style: italic;">void Audio::play_loop(); -</span>
        Checking the playback status and restarting playback if needed.<br>
        <br>
        <span style="font-style: italic;">void Audio::play(const bool loop); -</span>
        Play a sound. You can set loop mode if you want.<br>
        <br>
        <span style="font-style: italic;">void Audio::stop(); -</span> Stop
        playing the content of the target file.<br>
        <br>
        <span style="font-style: italic;">bool Audio::check_playing(); -</span>
        Return true if the sound resource is playing.</big></p>
    <h1><a class="mozTocH1" name="mozTocId209024" id="mozTocId209024"></a><big>Part
        7. Misc</big></h1>
    <h2><a class="mozTocH2" name="mozTocId608755" id="mozTocId608755"></a><big>Chapter
        1. File system</big></h2>
    <p><big>This module is implemented as two simple functions. All these
        functions are declared in the <span style="font-style: italic;">Filesystem</span>
        sub-namespace.<br>
        <br>
        <span style="font-style: italic;">file_exist</span> check the target
        file to see if one exists.<br>
        <br>
        <span style="font-style: italic;">delete_file</span> delete the target
        file.<br>
        <br>
        All functions take the target file name as an argument and return false
        if the operation failed.</big></p>
    <h2><a class="mozTocH2" name="mozTocId59386" id="mozTocId59386"></a><big>Chapter
        2. Tools</big></h2>
    <p><big>This module is implemented as a few functions</big><big>. All these
        functions are declared in the <span style="font-style: italic;">Tools</span>
        sub-namespace.<br>
        <br>
        <span style="font-style: italic;">void quit(); -</span></big> <big>Exit
        from your program and return the user to the operating system.<br>
        <br>
        <span style="font-style: italic;">bool enable_logging(const char *name);
          -</span></big> <big>Enable redirecting error messages to a log file
        and return false if the operation failed.<br>
        <br>
        <span style="font-style: italic;">void randomize(); -</span></big> <big>Initialize
        the random number generator.<br>
        <br>
        <span style="font-style: italic;">unsigned int get_random(const unsigned
          int number); -</span></big> <big>Return a random value between zero
        and the number.<br>
        <br>
        <span style="font-style: italic;">unsigned int get_texture_size(); -</span></big>
      <big>Return the maximum width or height of the texture.<br>
        <br>
        <span style="font-style: italic;">EUGENEGDK::BOX generate_box(const
          unsigned int x,const unsigned int y,const unsigned int width,const
          unsigned int height); -</span> Generate the collision-related
        information.<br>
      </big></p>
    <h2><a class="mozTocH2" name="mozTocId573582" id="mozTocId573582"></a><big>Chapter
        3. Resource Manager</big></h2>
    <p><big>A resource is an instance of a user-defined class or structure. The
        resource manager is implemented as a few template functions. All these
        functions are declared in the <span style="font-style: italic;">Resource</span>
        sub-namespace.<br>
        <br>
        <span style="font-style: italic;">create</span> creates a resources. The
        first form of this function creates a single resource. It takes a handle
        to a resource handle as an argument. The second form creates an array of
        resources. It takes a handle to a resource handle and a resource amount.<br>
      </big></p>
    <p><big><span style="font-style: italic;">destroy</span> delete a resource
        if it already exists. This function takes a resource handle as an
        argument.</big></p>
    <p><big><span style="font-style: italic;">destroy_array</span> delete the
        resource array if it already exists. This function takes a resource
        array handle as an argument.<br>
      </big></p>
    <h1><a class="mozTocH1" name="mozTocId590919" id="mozTocId590919"></a><big>Part
        8. Binary files</big></h1>
    <h2><a class="mozTocH2" name="mozTocId200879" id="mozTocId200879"></a><big>Chapter
        1. The sub-namespace</big></h2>
    <p><big>All classes in this section are declared in the <span style="font-style: italic;">File</span>
        sub-namespace.</big></p>
    <h2><a class="mozTocH2" name="mozTocId961921" id="mozTocId961921"></a><big>Chapter
        2. Base binary file subsystem</big></h2>
    <p><big><u>Work with the binary files</u><br>
        <br>
        The <em>Binary_File</em> class provides simple access to the base
        binary subsystem. Don't use it directly. Let's look at the publicly
        available methods.<br>
        <br>
        <em>void Binary_File::close(); -</em> Close the file.<br>
        <br>
        <em>void Binary_File::set_position(const long int offset); -</em> Set
        the file position.<br>
        <br>
        <em>long int Binary_File::get_position(); -</em> Return the current file
        position.<br>
        <br>
        <em>long int Binary_File::get_length(); -</em> Return the file length in
        bytes.<br>
        <br>
        <em>bool Binary_File::check_error(); -</em> Return true if the last file
        operation failed.<br>
        <br>
        <span style="font-style: italic;">bool Binary_File::is_open() const; -</span>
        Return true if the file was successfully opened.<br>
        <br>
        <u>Important notice</u><br>
        <br>
        The target file size limit is 2 gigabytes.</big></p>
    <h2><a class="mozTocH2" name="mozTocId424835" id="mozTocId424835"></a><big>Chapter
        3. File reader</big></h2>
    <p><big>File Reader is intended to read data from the binary files. The <em>Input_file</em>
        class provides access to a file reader. It is derived from the <em>Binary_File</em>
        class. Let's look at the publicly available methods.<br>
        <br>
        <span style="font-style: italic;">Input_File* Input_File::get_handle();
          -</span> Return the handle to the file reader.<br>
        <br>
        <em>void Input_File::open(const char *name); -</em> Open a file to read.<br>
        <br>
        <em>void Input_File::read(void *buffer,const size_t length); -</em> Read
        data from the file.</big></p>
    <h2><a class="mozTocH2" name="mozTocId511135" id="mozTocId511135"></a><big>Chapter
        4. File writer</big></h2>
    <p><big>File Writer is intended to write data to the binary files. The <em>Output_File</em>
        class provides access to a file writer. It is derived from the <em>Binary_File</em>
        class. Let's look at the publicly available methods.<br>
        <br>
      </big> <big><span style="font-style: italic;">Output_File*
          Output_File::get_handle(); -</span> Return the handle to the file
        writer.</big><br>
      <br>
      <big><em>void Output_File::open(const char *name); -</em> Open a file to
        write.<br>
        <br>
        <em>void Output_File::create_temp(); -</em> Create a temporary file.
        This file will be deleted when it is closed.<br>
        <br>
      </big> <big><em>void Output_File::write(const void *buffer,const size_t
          length); -</em> Write data to the file.<br>
        <br>
      </big> <big><em>void Output_File::flush(); -</em> Force writing internal
        buffer data to the file.</big></p>
    <h1><a class="mozTocH1" name="mozTocId291572" id="mozTocId291572"></a><big>Part
        9. Input</big></h1>
    <h2><a class="mozTocH2" name="mozTocId783369" id="mozTocId783369"></a><big>Chapter
        1. The sub-namespace</big></h2>
    <p><big>All classes in this section are declared in the <span style="font-style: italic;">Input</span>
        sub-namespace.</big></p>
    <h2><a class="mozTocH2" name="mozTocId685403" id="mozTocId685403"></a><big>Chapter
        2. Keyboard</big></h2>
    <p><big><span style="text-decoration: underline;">Low–level input</span><br>
        <br>
        Any keyboard has a built-in chip. It generates a special code when the
        user presses or releases the key. This code is called a «scan code».<br>
        <br>
        <span style="text-decoration: underline;">Working with the keyboard</span><br>
        <br>
        Just use the <span style="font-style: italic;">Keyboard</span> class to
        work with a keyboard. Let's look at the publicly available methods.<br>
        <br>
        <span style="font-style: italic;">void Keyboard::initialize(); -</span>
        Initialize the subsystem.<br>
        <br>
        <span style="font-style: italic;">bool Keyboard::check_hold(const
          unsigned char code); -</span> Return true if a key with a specific
        scan code is pressed or held.<br>
        <br>
        <span style="font-style: italic;">bool Keyboard::check_press(const
          unsigned char code); -</span> Return true if a key with a specific
        scan code was pressed.<span style="font-style: italic;"><br>
        </span></big></p>
    <p><big><span style="font-style: italic;">bool Keyboard::check_release(const
          unsigned char code); -</span> Return true if a key with a specific
        scan code was released.<span style="font-style: italic;"><br>
        </span></big></p>
    <p><big><span style="font-style: italic;">bool Keyboard::is_ready() const; -</span>
        Return true if the subsystem has already been initialized.<br>
        <br>
        <span style="text-decoration: underline;">List of supported scan codes</span><br>
      </big></p>
    <p><big>You can see a list of scan codes below.</big></p>
    <table border="1">
      <tbody>
        <tr>
          <td><big>Key</big></td>
          <td><big>Code</big></td>
          <td><big>Key</big></td>
          <td><big>Code</big></td>
          <td><big>Key</big></td>
          <td><big>Code</big></td>
        </tr>
        <tr>
          <td><big>Escape</big></td>
          <td><big>1</big></td>
          <td><big>A</big></td>
          <td><big>30</big></td>
          <td><big>F1</big></td>
          <td><big>59</big></td>
        </tr>
        <tr>
          <td><big>! or 1</big></td>
          <td><big>2</big></td>
          <td><big>S</big></td>
          <td><big>31</big></td>
          <td><big>F2</big></td>
          <td><big>60</big></td>
        </tr>
        <tr>
          <td><big>@ or 2</big></td>
          <td><big>3</big></td>
          <td><big>D</big></td>
          <td><big>32</big></td>
          <td><big>F3</big></td>
          <td><big>61</big></td>
        </tr>
        <tr>
          <td><big># or 3</big></td>
          <td><big>4</big></td>
          <td><big>F</big></td>
          <td><big>33</big></td>
          <td><big>F4</big></td>
          <td><big>62</big></td>
        </tr>
        <tr>
          <td><big>$ or 4</big></td>
          <td><big>5</big></td>
          <td><big>G</big></td>
          <td><big>34</big></td>
          <td><big>F5</big></td>
          <td><big>63</big></td>
        </tr>
        <tr>
          <td><big>% or 5</big></td>
          <td><big>6</big></td>
          <td><big>H</big></td>
          <td><big>35</big></td>
          <td><big>F6</big></td>
          <td><big>64</big></td>
        </tr>
        <tr>
          <td><big>^ or 6</big></td>
          <td><big>7</big></td>
          <td><big>J</big></td>
          <td><big>36</big></td>
          <td><big>F7</big></td>
          <td><big>65</big></td>
        </tr>
        <tr>
          <td><big>&amp; or 7</big></td>
          <td><big>8</big></td>
          <td><big>K</big></td>
          <td><big>37</big></td>
          <td><big>F8</big></td>
          <td><big>66</big></td>
        </tr>
        <tr>
          <td><big>* or 8</big></td>
          <td><big>9</big></td>
          <td><big>L</big></td>
          <td><big>38</big></td>
          <td><big>F9</big></td>
          <td><big>67</big></td>
        </tr>
        <tr>
          <td><big>( or 9</big></td>
          <td><big>10</big></td>
          <td style="height: 22px;"><big>: or ;</big></td>
          <td><big>39</big></td>
          <td><big>F10</big></td>
          <td><big>68</big></td>
        </tr>
        <tr>
          <td><big>0 or )</big></td>
          <td><big>11</big></td>
          <td><big>" or '</big></td>
          <td><big>40</big></td>
          <td><big>F11</big></td>
          <td><big>133</big></td>
        </tr>
        <tr>
          <td><big>_ or |</big></td>
          <td><big>12</big></td>
          <td><big>~ or `</big></td>
          <td><big>41</big></td>
          <td><big>F12</big></td>
          <td><big>134</big></td>
        </tr>
        <tr>
          <td><big>+ or =</big></td>
          <td><big>13</big></td>
          <td><big>Left Shift</big></td>
          <td><big>42</big></td>
          <td><big>Num Lock</big></td>
          <td><big>69</big></td>
        </tr>
        <tr>
          <td><big>Backspace</big></td>
          <td><big>14</big></td>
          <td><big>| or \</big></td>
          <td><big>43</big></td>
          <td><big>Scroll Lock</big></td>
          <td><big>70</big></td>
        </tr>
        <tr>
          <td><big>Tab</big></td>
          <td><big>15</big></td>
          <td><big>Z</big></td>
          <td><big>44</big></td>
          <td><big>Home or 7</big></td>
          <td><big>71</big></td>
        </tr>
        <tr>
          <td><big>Q</big></td>
          <td><big>16</big></td>
          <td><big>X</big></td>
          <td><big>45</big></td>
          <td><big>Up or 8</big></td>
          <td><big>72</big></td>
        </tr>
        <tr>
          <td><big>W</big></td>
          <td><big>17</big></td>
          <td><big>C</big></td>
          <td><big>46</big></td>
          <td><big>Page up or 9</big></td>
          <td><big>73</big></td>
        </tr>
        <tr>
          <td><big>E</big></td>
          <td><big>18</big></td>
          <td><big>V</big></td>
          <td><big>47</big></td>
          <td><big>Gray -</big></td>
          <td><big>74</big></td>
        </tr>
        <tr>
          <td><big>R</big></td>
          <td><big>19</big></td>
          <td><big>B</big></td>
          <td><big>48</big></td>
          <td><big>Left or 4</big></td>
          <td><big>75</big></td>
        </tr>
        <tr>
          <td><big>T</big></td>
          <td><big>20</big></td>
          <td><big>N</big></td>
          <td><big>49</big></td>
          <td><big>Center or 5</big></td>
          <td><big>76</big></td>
        </tr>
        <tr>
          <td><big>Y</big></td>
          <td><big>21</big></td>
          <td><big>M</big></td>
          <td><big>50</big></td>
          <td><big>Right or 6</big></td>
          <td><big>77</big></td>
        </tr>
        <tr>
          <td><big>U</big></td>
          <td><big>22</big></td>
          <td><big>&lt; or ,</big></td>
          <td><big>51</big></td>
          <td><big>Gray +</big></td>
          <td><big>78</big></td>
        </tr>
        <tr>
          <td><big>I</big></td>
          <td><big>23</big></td>
          <td><big>&gt; or .</big></td>
          <td><big>52</big></td>
          <td><big>End or 1</big></td>
          <td style="height: 22px;"><big>79</big></td>
        </tr>
        <tr>
          <td><big>O</big></td>
          <td><big>24</big></td>
          <td><big>?</big></td>
          <td><big>53</big></td>
          <td><big>Down or 2</big></td>
          <td><big>80</big></td>
        </tr>
        <tr>
          <td><big>P</big></td>
          <td><big>25</big></td>
          <td><big>Right shift</big></td>
          <td><big>54</big></td>
          <td><big>Page down or 3</big></td>
          <td><big>81</big></td>
        </tr>
        <tr>
          <td><big>{ or [</big></td>
          <td><big>26</big></td>
          <td><big>Print Screen or *</big></td>
          <td><big>55</big></td>
          <td><big>Insert or 0</big></td>
          <td><big>82</big></td>
        </tr>
        <tr>
          <td><big>} or ]</big></td>
          <td><big>27</big></td>
          <td><big>Alt</big></td>
          <td><big>56</big></td>
          <td><big>Delete or .</big></td>
          <td><big>83</big></td>
        </tr>
        <tr>
          <td><big>Enter</big></td>
          <td><big>28</big></td>
          <td><big>Spacebar</big></td>
          <td><big>57</big></td>
          <td><br>
          </td>
          <td><br>
          </td>
        </tr>
        <tr>
          <td><big>Control</big></td>
          <td><big>29</big></td>
          <td><big>Caps Lock</big></td>
          <td><big>58</big></td>
          <td><br>
          </td>
          <td><br>
          </td>
        </tr>
      </tbody>
    </table>
    <h2><a class="mozTocH2" name="mozTocId686993" id="mozTocId686993"></a><big>Chapter
        3. Mouse</big></h2>
    <p><big><span style="text-decoration: underline;">A few words about mice</span><br>
        <br>
        A mouse is very useful for interaction with a graphical user interface.
        But the mouse can also be used in video games.<br>
        <br>
        <span style="text-decoration: underline;">Working with the mouse</span><br>
        <br>
        Just use the <span style="font-style: italic;">Mouse</span> class to
        work with a mouse. Let's look at the publicly available methods.<br>
        <br>
        <span style="font-style: italic;">void Mouse::show(); -</span> Show the
        mouse cursor.<br>
        <br>
        <span style="font-style: italic;">void Mouse::hide(); -</span> Hide the
        mouse cursor.<br>
        <br>
        <span style="font-style: italic;">unsigned int Mouse::get_x(); -</span>
        Return the x-position of the mouse.<br>
        <br>
        <span style="font-style: italic;">unsigned int Mouse::get_y(); -</span>
        Return the y-position of the mouse.<br>
        <br>
        <span style="font-style: italic;">void Mouse::set_position(const
          unsigned int x,const unsigned int y); -</span> Set the position of the
        mouse.<br>
        <br>
        <span style="font-style: italic;">bool Mouse::check_hold(const
          EUGENEGDK::MOUSE_BUTTON button); -</span> Return true if a mouse
        button is pressed or held.<br>
        <br>
        <span style="font-style: italic;">bool Mouse::check_press(const
          EUGENEGDK::MOUSE_BUTTON button); -</span> Return true if a mouse
        button was pressed.</big></p>
    <p><big><span style="font-style: italic;">bool Mouse::check_release(const
          EUGENEGDK::MOUSE_BUTTON button); -</span> Return true if a mouse
        button was released.</big></p>
    <p><big><span style="text-decoration: underline;">Mouse buttons</span><br>
      </big></p>
    <p><big>The mouse button codes look like the predefined constants. You can
        see it below.</big></p>
    <table border="1">
      <tbody>
        <tr>
          <td><big>Mouse button code</big></td>
          <td><big>Button</big></td>
        </tr>
        <tr>
          <td><big>MOUSE_LEFT</big></td>
          <td><big>Left button</big></td>
        </tr>
        <tr>
          <td><big>MOUSE_RIGHT</big></td>
          <td><big>Right button</big></td>
        </tr>
        <tr>
          <td><big>MOUSE_MIDDLE</big></td>
          <td><big>Middle button</big></td>
        </tr>
      </tbody>
    </table>
    <h2><a class="mozTocH2" name="mozTocId861609" id="mozTocId861609"></a><big>Chapter
        4. Gamepad</big></h2>
    <p><big><span style="text-decoration: underline;">Best friend of a retro
          gamer</span><br>
        <br>
        What is a good choice for a game control device when the user plays an
        arcade or an old-school style video game? A gamepad. This engine
        provides simple access to it.</big></p>
    <p><big><span style="text-decoration: underline;">Number of connected
          gamepads</span><br>
        <br>
        You can connect a few gamepads. Any connected gamepad has an internal
        index. The first gamepad index is 0. It will be activated by default.<br>
        <br>
        <span style="text-decoration: underline;">Ordinary button codes</span><br>
        <br>
        Ordinary button codes look like predefined constants. The first button
        is GAMEPAD_BUTTON1. The last button is GAMEPAD_BUTTON32.<br>
        <br>
        <span style="text-decoration: underline;">D-Pad button codes</span><br>
      </big></p>
    <p><big>The D-Pad button codes look like the predefined constants. You can
        see it below.</big></p>
    <table border="1">
      <tbody>
        <tr>
          <td><big>D-pad button code</big></td>
          <td><big>D-Pad button</big></td>
        </tr>
        <tr>
          <td><big>GAMEPAD_NONE</big></td>
          <td><big>None of the D-Pad buttons are pressed or held down.</big></td>
        </tr>
        <tr>
          <td><big>GAMEPAD_UP</big></td>
          <td><big>D-Pad up</big></td>
        </tr>
        <tr>
          <td><big>GAMEPAD_DOWN</big></td>
          <td><big>D-Pad down</big></td>
        </tr>
        <tr>
          <td><big>GAMEPAD_LEFT</big></td>
          <td><big>D-Pad left</big></td>
        </tr>
        <tr>
          <td><big>GAMEPAD_RIGHT</big></td>
          <td><big>D-Pad right</big></td>
        </tr>
        <tr>
          <td><big>GAMEPAD_UPLEFT</big></td>
          <td><big>Both D-Pad up and D-Pad left</big></td>
        </tr>
        <tr>
          <td><big>GAMEPAD_UPRIGHT</big></td>
          <td><big>Both D-Pad up and D-Pad right</big></td>
        </tr>
        <tr>
          <td><big>GAMEPAD_DOWNLEFT</big></td>
          <td><big>Both D-Pad down and D-Pad left</big></td>
        </tr>
        <tr>
          <td><big>GAMEPAD_DOWNRIGHT</big></td>
          <td><big>Both D-Pad down and D-Pad right</big></td>
        </tr>
      </tbody>
    </table>
    <p><big><span style="text-decoration: underline;">Stick identifiers</span><br>
      </big></p>
    <p><big>The stick identifiers look like the predefined constants. You can
        see it below.</big></p>
    <table border="1">
      <tbody>
        <tr>
          <td><big>Identifiers</big></td>
          <td><big>Description</big></td>
        </tr>
        <tr>
          <td><big>GAMEPAD_LEFT_STICK</big></td>
          <td><big>Left stick</big></td>
        </tr>
        <tr>
          <td><big>GAMEPAD_RIGHT_STICK</big></td>
          <td><big>Right stick</big></td>
        </tr>
      </tbody>
    </table>
    <p><big><span style="text-decoration: underline;">Stick direction</span><br>
      </big></p>
    <p><big>The stick direction looks like the predefined constants. You can see
        it below.</big></p>
    <table border="1">
      <tbody>
        <tr>
          <td><big>Value</big></td>
          <td><big>X-direction</big></td>
          <td><big>Y-direction</big></td>
        </tr>
        <tr>
          <td><big>GAMEPAD_NEUTRAL_DIRECTION</big></td>
          <td><big>Neutral</big></td>
          <td><big>Neutral</big></td>
        </tr>
        <tr>
          <td><big>GAMEPAD_POSITIVE_DIRECTION</big></td>
          <td><big>Right</big></td>
          <td><big>Up</big></td>
        </tr>
        <tr>
          <td><big>GAMEPAD_NEGATIVE_DIRECTION</big></td>
          <td><big>Left</big></td>
          <td><big>Down</big></td>
        </tr>
      </tbody>
    </table>
    <p><big><span style="text-decoration: underline;">Working with a gamepad</span><br>
        <br>
        Just use the <span style="font-style: italic;">Gamepad</span> class to
        work with the gamepad. Let's look at the publicly available methods.<br>
        <br>
        <span style="font-style: italic;">unsigned int Gamepad::get_amount(); -</span>
        Return the number of connected gamepads.<span style="font-style: italic;"><br>
        </span></big></p>
    <p><big><span style="font-style: italic;">unsigned int
          Gamepad::get_button_amount() const; -</span> Return the number of the
        gamepad buttons.<br>
        <br>
        <span style="font-style: italic;">unsigned int
          Gamepad::get_stick_amount() const; -</span> Return the number of the
        gamepad sticks.<br>
        <br>
        <span style="font-style: italic;">void Gamepad::update(); -</span>
        Update the internal gamepad state.<span style="font-style: italic;"><br>
        </span></big></p>
    <p><big><span style="font-style: italic;">void Gamepad::set_active(const
          unsigned int gamepad); -</span> Set the current active gamepad.<span style="font-style: italic;"><br>
        </span></big></p>
    <p><big><span style="font-style: italic;">EUGENEGDK::GAMEPAD_DPAD
          Gamepad::get_dpad() const; -</span> Return the code of the pressed or
        held D-Pad button.<br>
        <br>
        <span style="font-style: italic;">bool Gamepad::check_hold(const
          EUGENEGDK::GAMEPAD_BUTTONS button) const; -</span> Return true if the
        button is pressed or held.<br>
        <br>
        <span style="font-style: italic;">bool Gamepad::check_press(const
          EUGENEGDK::GAMEPAD_BUTTONS button) const; -</span> Return true if the
        button was pressed.</big></p>
    <p><big><span style="font-style: italic;">bool Gamepad::check_released(const
          EUGENEGDK::GAMEPAD_BUTTONS button) const; -</span> Return true if the
        button was released.</big></p>
    <p><big><span style="font-style: italic;">EUGENEGDK::GAMEPAD_DIRECTION
          Gamepad::get_stick_x(const EUGENEGDK::GAMEPAD_STICKS stick) const; -</span>
        Return the x-direction of a specific stick.<br>
        <br>
        <span style="font-style: italic;">EUGENEGDK::GAMEPAD_DIRECTION
          Gamepad::get_stick_y(const EUGENEGDK::GAMEPAD_STICKS stick) const; -</span>
        Return the y-direction of a specific stick.<br>
        <br>
        <span style="font-style: italic;">EUGENEGDK::GAMEPAD_DIRECTION
          Gamepad::get_left_stick_x() const; -</span> Return the x-direction of
        the left stick.<br>
        <br>
        <span style="font-style: italic;">EUGENEGDK::GAMEPAD_DIRECTION
          Gamepad::get_left_stick_y() const; -</span> Return the y-direction of
        the left stick.<br>
        <br>
        <span style="font-style: italic;">EUGENEGDK::GAMEPAD_DIRECTION
          Gamepad::get_right_stick_x() const; -</span> Return the x-direction of
        the right stick.<br>
        <br>
        <span style="font-style: italic;">EUGENEGDK::GAMEPAD_DIRECTION
          Gamepad::get_right_stick_y() const; -</span> Return the y-direction of
        the right stick.<br>
      </big></p>
    <h1><a class="mozTocH1" name="mozTocId54918" id="mozTocId54918"></a><big>Part
        10. Internal details of the engine subsystems</big></h1>
    <h2><a class="mozTocH2" name="mozTocId383177" id="mozTocId383177"></a><big>Chapter
        1. A few words for a curious programmer</big></h2>
    <p><big>The engine subsystems have a different internal structure. It has
        been hidden from you, and you don't have access to it. Do you want to
        know about hidden things? Just read the next chapter.</big></p>
    <h2><a class="mozTocH2" name="mozTocId318160" id="mozTocId318160"></a><big>Chapter
        2. Internal classes</big></h2>
    <p><big><span style="text-decoration: underline;">Internal classes</span><br>
        <br>
        Some classes are designed for internal use only. Don't touch them. What
        are these strange classes doing?<br>
        <br>
        <span style="text-decoration: underline;">Microsoft Windows-specific
          classes</span><br>
        <br>
        All Microsoft Windows-specific classes are declared in the <span style="font-style: italic;">Internal</span>
        sub-namespace.<br>
        <br>
      </big> <big><span style="font-style: italic;">Engine</span> creates the
        game window and does message processing.</big><br>
      <big><span style="font-style: italic;">Synchronization</span> implements
        the synchronization timer.</big><br>
      <big><span style="font-style: italic;">Display</span> implements the
        display manager.</big><br>
      <big><span style="font-style: italic;">WINGL</span> contains
        Windows-specific OPENGL initialization code.</big><br>
      <br>
      <big><span style="text-decoration: underline;">Core classes</span></big><br>
      <big><br>
        All engine core classes and functions are declared in the <span style="font-style: italic;">Core</span>
        sub-namespace.<br>
        <br>
      </big> <big><span style="font-style: italic;">FPS</span> implements the
        FPS counter.<br>
      </big> <big><em>Unicode_Converter</em> implements the system code page to
        UTF-16 converter.<br>
      </big> <big><span style="font-style: italic;">Render</span> implements
        the OPENGL render.<br>
        <span style="font-style: italic;">Resizer</span> is intended to
        calculate the correct texture size.<br>
        <span style="font-style: italic;">Rectangle</span> is intended to draw a
        textured rectangle.<br>
        <span style="font-style: italic;">Shape</span> is the base class of the
        <span style="font-style: italic;">Rectangle</span> class.<br>
      </big></p>
    <h2><a class="mozTocH2" name="mozTocId293644" id="mozTocId293644"></a><big>Chapter
        3. Base graphics subsystem</big></h2>
    <p><big style="text-decoration: underline;">Visible object</big><br>
      <br>
      <big>Any visible object is a textured rectangle.</big><br>
      <br>
      <big style="text-decoration: underline;">Textures</big><br>
      <br>
      <big>A texture width must be a power of two. A texture height also must be
        a power of two. Any image will automatically be resized before
        uploading.</big><br>
      <br>
      <big style="text-decoration: underline;">Vertex arrays and texture
        coordinate arrays</big><br>
      <br>
      <big>Any rectangle needs four vertices and four texture coordinates.</big><br>
      <big>A single vertex represents the following custom data type:</big><br>
      <br>
      <big style="font-style: italic;">typedef struct Vertex</big><big style="font-style: italic;"><br>
        {</big><br>
      <big style="font-style: italic;">int x;</big><big style="font-style: italic;"><br>
        int y;<br>
      </big> <big style="font-style: italic;">};</big><br>
      <br>
      <big>A single texture coordinate represents the following custom data
        type:</big><br>
      <br>
      <big style="font-style: italic;">typedef struct</big> <big style="font-style: italic;"><br>
        {<br>
      </big> <big style="font-style: italic;">float u;</big><br>
      <big style="font-style: italic;">float v;</big><big style="font-style: italic;"><br>
        } Point;</big><br>
      <big></big><br>
      <big>All these custom types are declared in the <span style="font-style: italic;">Core</span>
        sub-namespace.</big></p>
    <h2><a class="mozTocH2" name="mozTocId472209" id="mozTocId472209"></a><big>Chapter
        4. Gamepad</big></h2>
    <p><big>The gamepad subsystem is working over the <a href="https://msdn.microsoft.com/ru-ru/library/windows/desktop/dd757116%28v=vs.85%29.aspx">Joystick
          Multimedia API</a>.</big></p>
    <h2><a class="mozTocH2" name="mozTocId804583" id="mozTocId804583"></a><big>Chapter
        5. Input</big></h2>
    <p><big><span style="text-decoration: underline;">Input backend</span><br>
        <br>
        The keyboard and mouse input subsystems are simple. It works over a
        standard Microsoft Windows API.<br>
        <br>
        <span style="text-decoration: underline;">Internal key state</span><br>
      </big></p>
    <p><big>The internal states of keyboard keys and mouse buttons look like the
        predefined constants. You can see it below.<br>
      </big></p>
    <table border="1">
      <tbody>
        <tr>
          <td><big>Key/button state</big></td>
          <td><big>Description</big></td>
        </tr>
        <tr>
          <td><big>KEY_PRESSED</big></td>
          <td><big>A key or button is pressed or held.</big></td>
        </tr>
        <tr>
          <td><big>KEY_RELEASED</big></td>
          <td><big>A key or button was released.</big></td>
        </tr>
      </tbody>
    </table>
    <h2><a class="mozTocH2" name="mozTocId692266" id="mozTocId692266"></a><big>Chapter
        6. Audio</big></h2>
    <p><big>The audio subsystem is working over <a href="https://docs.microsoft.com/en-us/windows/desktop/DirectShow/directshow">DirectShow</a>.
        It is available as part of <a href="https://en.wikipedia.org/wiki/DirectX">DirectX</a>.
        DirectX is pre-installed by default under the modern versions of
        Windows.</big></p>
    <h1><a class="mozTocH1" name="mozTocId670307" id="mozTocId670307"></a><big>Version history<br></big></h1>
    <big>0.1: Initial version.<br>
      0.1.1-0.7.6: The internal unstable builds.<br>
      0.7.7: The small changes.<br>
      0.7.8: The small bug in the sprite subsystem has been fixed.<br>
      0.7.9-0.8.1: The small changes.<br>
      0.8.2: The sprite subsystem has improved.<br>
      0.8.3: PCX support has been removed.<br>
      0.8.4: The small changes.<br>
      0.8.5: The FPS counter has improved.<br>
      0.8.6-0.8.9: The small changes.<br>
      0.9: TGA support has improved.<br>
      0.9.1: The small bug in the sprite subsystem has been fixed.<br>
      0.9.2: The small changes.<br>
      0.9.3: The new subsystem has been added.<br>
      0.9.4-0.9.5: The graphic primitives subsystem has improved.<br>
      0.9.6-0.9.9: The small changes.<br>
      1.0: The base graphics subsystem has improved.<br>
      1.0.1-1.0.2: The background subsystem has improved.<br>
      1.0.3: The small changes.<br>
      1.0.4: The small bug in the sprite subsystem has been fixed.<br>
      1.0.5-1.1.4: The small changes.<br>
      1.1.5-1.1.6: The small bug has been fixed.<br>
      1.1.7: The unused dependency has been removed.<br>
      1.1.8-1.2.5: The small changes.<br>
      1.2.6: The small bug has been fixed.<br>
      1.2.7: The small changes.<br>
      1.2.8: The rendering performance has increased.<br>
      1.2.9: The Windows 2000 support has been added.<br>
      1.3: The small changes.<br>
      1.3.1: The image resizer has improved.<br>
      1.3.2: The gamepad subsystem has improved.<br>
      1.3.3: The project name changed.<br>
      1.3.4: The sprite subsystem has improved.<br>
      1.3.5: The small changes.<br>
      1.3.6: The tile-set subsystem has improved.<br>
      1.3.7: The small changes.<br>
      1.3.8: The sprite subsystem has improved.<br>
      1.3.9: The tile-set subsystem has improved.<br>
      1.4: The sprite subsystem has improved.<br>
      1.4.1: The text subsystem has improved.<br>
      1.4.2-1.4.5: The small changes.<br>
      1.4.6: The new subsystem has been added. Windows 2000 support has been removed.<br>
      1.4.7-1.4.8: The sprite subsystem has improved.<br>
      1.4.9: The text subsystem has improved.<br>
      1.5: The small changes.<br>
      1.5.1: The optional software rendering has been added.<br>
      1.5.2-1.5.7: The small changes.<br>
      1.5.8: The keyboard input has improved.<br>
      1.5.9: The mouse input has improved.<br>
      1.6: The gamepad support has improved.<br>
      1.6.1: The small bug in the gamepad subsystem has been fixed.<br>
      1.6.2: The small changes.<br>
      1.6.3: The file system subsystem has improved.<br>
      1.6.4-1.6.5: The small changes.<br>
      1.6.6: The base graphics subsystem has improved.<br>
      1.6.7: The small changes.<br>
      1.6.8: The gamepad support has improved.<br>
      1.6.9-1.7: The small changes.<br>
      1.7.1: The small bug in the sprite subsystem has been fixed.<br>
      1.7.2: The graphic primitives subsystem has improved.<br>
      1.7.3-1.7.4: The small changes.<br>
      1.7.5-1.7.6: The picture subsystem has improved.<br>
      1.7.7-1.7.8: The sprite subsystem has improved.<br>
      1.7.9-1.8: The picture subsystem has improved.<br>
      1.8.1: The small changes.<br>
      1.8.2: The tile-set subsystem has improved.<br>
      1.8.3: The small changes.<br>
      1.8.4-1.8.6: The binary file subsystem has improved.<br>
      1.8.7-1.8.8: The image loader has improved.<br>
      1.8.9: The small changes.<br>
      1.9-1.9.1: The image loader has improved.<br>
      1.9.2: The picture subsystem has improved.<br>
      1.9.3: The small changes.<br>
      1.9.4: The tile-set subsystem has improved.<br>
      1.9.5-1.9.8: The small changes.<br>
      1.9.9: The background subsystem has improved.<br>
      2.0-2.0.3: The image loader has improved.<br>
      2.0.4: The sprite subsystem has improved.<br>
      2.0.5: The background subsystem has improved.<br>
      2.0.6-2.1.2: The text drawing subsystem has improved.<br>
      2.1.3: The background subsystem has improved.<br>
      2.1.4-2.1.8: The small changes.<br>
      2.1.9-2.2.7: The multimedia subsystem has improved.<br>
      2.2.8-2.3.1: The small changes.<br>
      2.3.2-2.3.3: The base graphics subsystem has improved.<br>
      2.3.4: The synchronization timer has improved.<br>
      2.3.5-2.3.6: The small changes.<br>
      2.3.7: The multimedia subsystem has improved.<br>
      2.3.8: The keyboard input has improved.<br>
      2.3.9: The small changes.<br>
      2.4: The mouse input has improved.<br>
      2.4.1: The small changes.<br>
      2.4.2: The binary file subsystem has improved.<br>
      2.4.3-2.4.7: The small changes.<br>
      2.4.8: The background subsystem has improved.<br>
      2.4.9: The sprite subsystem has improved.<br>
      2.5: The tile-set subsystem has improved.<br>
      2.5.1-2.5.2: The small changes.<br>
      2.5.3: The sprite subsystem has improved.<br>
      2.5.4-2.5.6: The tile-set subsystem has improved.<br>
      2.5.7: The small changes.<br>
      2.5.8: The sprite subsystem has improved.<br>
      2.5.9-2.6: The small changes.<br>
      2.6.1: The animation subsystem has improved.<br>
      2.6.2: The background subsystem has improved.<br>
      2.6.3-2.6.4: The sprite subsystem has improved.<br>
      2.6.5: The background subsystem has improved.<br>
      2.6.6: The base graphics subsystem has improved.<br>
      2.6.7: The small changes.<br>
      2.6.8: The primitive subsystem has improved.<br>
      2.6.9: The small bug has been fixed.<br>
      2.7: The primitive subsystem removed.<br>
      2.7.1-2.7.6: The preview release of the next branch.<br>
      2.7.7: The public release of the next branch.<br>
      2.7.8-2.7.9: The small changes.<br>
      2.8: Go back to the old stable branch.<br>
      2.8.1-2.8.5: The small changes.<br>
      2.8.6: Merge the old branch and the new branch.<br>
      2.8.7: The small bug has been fixed.<br>
      2.8.8-2.9.9: The small changes.<br>
      3.0: The basic graphics subsystem has improved.<br>
      3.0.1: The small changes.<br>
      3.0.2: The keyboard subsystem has improved.<br>
      3.0.3-3.0.5: The small changes.<br>
      3.0.6: The operating system interaction subsystem has improved.<br>
      3.0.7-3.1.1: The small changes.<br>
      3.2-3.2.1: A few changes in the engine API.<br>
      3.2.2: The small changes.<br>
      3.3: The new subsystem has been added.<br>
      3.3.1-3.3.4: The small changes.<br>
      3.3.5: The keyboard input has improved.<br>
      3.3.6: The image loader has improved.<br>
      3.3.7-3.3.8: The small changes.<br>
      3.3.9-3.4: The sprite subsystem has improved.<br>
      3.4.1: The background subsystem has improved.<br>
      3.4.2: The image storage has improved.<br>
      3.4.3: The sprite subsystem has improved.<br>
      3.4.4: The image loader has improved.<br>
      3.4.5: The image storage has improved.<br>
      3.4.6: The tile-set subsystem has improved.<br>
      3.4.7: The background subsystem has improved.<br>
      3.4.8-3.4.9: The sprite subsystem has improved.<br>
      3.5-3.5.4: The small changes.<br>
      3.5.5: The tile-set subsystem has improved.<br>
      3.5.6-3.6.4: The small changes.<br>
      3.6.5: The multimedia subsystem has improved.<br>
      3.6.6-3.6.8: The small changes.<br>
      3.6.9: The sprite subsystem has improved.<br>
      3.7: The background subsystem has improved.<br>
      3.7.1: The small changes.<br>
      3.7.2: The binary file subsystem has improved.<br>
      3.7.3: The background subsystem has improved.<br>
      3.7.4-3.7.5: The small changes.<br>
      3.7.6: The small bug has been fixed.<br>
      3.7.7-3.8.5: The small changes.<br>
      3.8.6: The gamepad subsystem has improved.<br>
      3.8.7-3.8.8: The small changes.<br>
      3.8.9: The image resizer has improved.<br>
      3.9-3.9.7: The small changes.<br>
      3.9.8-3.9.9: The keyboard input has improved.<br>
      4.0-4.0.1: The small changes.<br>
      4.0.2: The collision detection subsystem has improved.<br>
      4.0.3: The small bug in the collision detection subsystem has been fixed.<br>
      4.0.4: The collision detection subsystem has improved.<br>
      4.0.5-4.0.6: The small changes.<br>
      4.0.7: The new internal subsystem has been added.<br>
      4.0.8: The small changes in engine core.<br>
      4.0.9: The image loader has improved.<br>
      4.1: The keyboard input has improved.<br>
      4.1.1: The small bug in the image loader has improved.<br>
      4.1.2: The keyboard input has improved.<br>
      4.1.3-4.2.1: The small changes.<br>
      4.2.2: The image resizer has improved.<br>
      4.2.3: The image storage has improved.<br>
      4.2.4: The image loader has improved.<br>
      4.2.5: The small changes.<br>
      4.2.6: The image storage has improved.<br>
      4.2.7: The mouse input has improved.<br>
      4.2.8: The keyboard input has improved.<br>
      4.2.9: The small changes.<br>
      4.3-4.3.3: The gamepad subsystem has improved.<br>
      4.3.4: The collision detection subsystem has improved.<br>
      4.3.5: The small changes.<br>
      4.3.6-4.3.8: The system interaction subsystem has improved.<br>
      4.3.9-4.4: The collision detection subsystem has improved.<br>
      4.4.1: The new subsystem has been added.<br>
      4.4.1.1: The documentation has been updated.<br>
      4.4.2: The small changes.<br>
      4.4.3-4.4.4: The new supported compiler has been added.<br>
      4.4.4.1: The documentation has been updated.<br>
      4.4.5: The small changes.<br>
      4.4.6: The new subsystem has been added.<br>
      4.4.6.1: The documentation has been updated.<br>
      4.4.7-4.4.8: The small changes.<br>
      4.4.9: The Windows 2000 support has been added.<br>
      4.4.9.1: The documentation has been updated.<br>
      4.5-4.5.3: The small changes.<br>
      4.5.4: The gamepad support has improved.<br>
      4.5.5-4.5.7: The rendering has improved.<br>
      4.5.8-4.6.2: The small changes.<br>
      4.6.3: The image resizer has improved.<br>
      4.6.4: The small changes.<br>
      4.6.5: The small bug in the binary file subsystem has been fixed.<br>
      4.6.6-4.6.8: The small changes.<br>
      4.6.9-4.7: The changes in the engine API.<br>
      4.7.0.1: The documentation has been updated.<br>
      4.7.1-4.7.2: The small changes.<br>
      4.7.3: The changes in the engine API.<br>
      4.7.4-4.8: The small changes.<br>
      4.8.1-4.8.3: The rendering has improved.<br>
      4.8.4-4.8.6: The small changes.<br>
      4.8.7: The keyboard input has improved.<br>
      4.8.8-4.8.9: The display manager has improved.<br>
      4.9-4.9.1: The small changes.<br>
      4.9.2: The display manager has improved.<br>
      4.9.3-4.9.4: The small changes.<br>
      4.9.5: The keyboard input has improved.<br>
      4.9.6: The mouse input has improved.<br>
      4.9.7-5.0.8: The small changes.<br>
      5.0.9-5.2: The experimental branch.<br>
      5.2.1: The small changes.<br>
      5.2.2: The text-drawing subsystem has improved.<br>
      5.2.3-5.2.5: The small changes.<br>
      5.2.6: The changes in the engine API.<br>
      5.2.7: The new subsystem has been added.<br>
      5.2.8-5.2.9: The sprite subsystem has improved.<br>
      5.3: The base sprite subsystem has improved.<br>
      5.3.1-5.3.4: The small changes.<br>
      5.3.5: The new subsystem has been added.<br>
      5.3.6: The small changes.<br>
      5.3.7: The tile-set subsystem removed.<br>
      5.3.8: The small changes.<br>
      5.3.9: The sprite sheet subsystem has improved.<br>
      5.4-5.4.1: The small changes.<br>
      5.4.2-5.4.5: The text drawing subsystem has improved.<br>
      5.4.6-5.5.2: The background subsystem has improved.<br>
      5.5.3-5.5.7: The small changes.<br>
      5.5.8: The background subsystem has improved.<br>
      5.5.9: The base sprite subsystem has improved.<br>
      5.6-5.6.4: The small changes.<br>
      5.6.5: The background subsystem has improved.<br>
      5.6.6: The text-drawing subsystem has improved.<br>
      5.6.7: The background subsystem has improved.<br>
      5.6.8: The text-drawing subsystem has improved.<br>
      5.6.9: The small changes.<br>
      5.7: The text drawing subsystem has improved.<br>
      5.7.1-5.7.2: The sprite sheet subsystem has improved.<br>
      5.7.3-5.7.4: The small changes.<br>
      5.7.5-5.7.6: The resource manager has improved.<br>
      5.7.7-5.8.2: The small changes.<br>
      5.8.3-5.8.5: The background subsystem has improved.<br>
      5.8.6: The small changes.<br>
      5.8.7-5.9.1: The sprite sheet subsystem has improved.<br>
      5.9.2-5.9.4: The small changes.<br>
      5.9.5: The text-drawing subsystem has improved.<br>
      5.9.6-5.9.8: The small changes.<br>
      5.9.9: The Windows 2000 support has been removed.<br>
      6.0: The changes in the engine API.<br>
      6.0.1: The new subsystem has been added.<br>
      6.0.2: The small changes.<br>
      6.0.3: The background subsystem and sprite subsystem have improved.<br>
      6.0.4: The small changes.<br>
      6.0.5: The picture subsystem has improved.<br>
      6.0.6-6.0.7: The small changes.<br>
      6.0.7.1: The documentation has been updated.<br>
      6.0.8: The base graphics subsystem has improved.<br>
      6.0.8.1: The documentation has been updated.<br>
      6.0.9-6.1.1: The small changes.<br>
      6.1.2: The text drawing subsystem has improved.<br>
      6.1.3: The small changes.<br>
      6.1.3.1: The documentation has been updated.<br>
      6.1.4: The small bug has been fixed.<br>
      6.1.5-6.1.6: The sprite sheet subsystem has improved.<br>
      6.1.7-6.2.1: The small changes.<br>
      6.2.2-6.2.3: The base graphics subsystem has improved.<br>
      6.2.4-6.2.6: The binary file subsystem has improved.<br>
      6.2.6.1: The documentation has been updated.<br>
      6.2.7: The collision detection subsystem has improved.<br>
      6.2.8: The small bug has been fixed.<br>
      6.2.9: The small changes.<br>
      6.3: The base sprite subsystem has improved.<br>
      6.3.1-6.3.2: The small changes.<br>
      6.3.3: The base graphics subsystem is backported from the Neon game development kit 5.8.4.<br>
      6.3.4: The Visual C++ 2005 support has been added.<br>
      6.3.5: The small changes.<br>
      6.3.6: The ordinary sprite subsystem has improved.<br>
      6.3.7: The sprite sheet subsystem has improved.<br>
      6.3.8: The background subsystem has improved.<br>
      6.3.9: The text-drawing subsystem has improved.<br>
      6.4: The small changes.<br>
      6.4.1: The collision detection subsystem has improved.<br>
      6.4.1.1: The documentation has been updated.<br>
      6.4.2: The image loader has improved.<br>
      6.4.3: The base sprite subsystem has improved.<br>
      6.4.4: The ordinary sprite subsystem has improved.<br>
      6.4.5-6.4.6: The background subsystem has improved.<br>
      6.4.7: The sprite sheet subsystem has improved.<br>
      6.4.8-6.4.9: The text drawing subsystem has improved.<br>
      6.5: The ordinary sprite subsystem has improved.<br>
      6.5.1: The background subsystem has improved.<br>
      6.5.2: The sprite sheet subsystem has improved.<br>
      6.5.3-6.5.4: The text-drawing subsystem has improved.<br>
      6.5.5: The resource manager has improved.<br>
      6.5.6: The processor usage has reduced.<br>
      6.5.7-6.5.8: The small changes.<br>
      6.5.9: The small bug in the gamepad subsystem has been fixed.<br>
      6.6: The source code synced with the Gray game development kit 2.2.7.<br>
      6.6.1: The text-drawing subsystem has improved.<br>
      6.6.2: The simple sound subsystem is backported from the Neon game development kit 5.7.8.<br>
      6.6.3: The small bug in the multimedia subsystem has been fixed.<br>
      6.6.4-6.6.6: The small changes.<br>
      6.6.7: The multimedia subsystem has improved.<br>
      6.6.8: The simple sound subsystem has been removed.<br>
      6.6.9-6.7: The multimedia subsystem has improved.<br>
      6.7.1: The timer subsystem has improved.<br>
      6.7.2-6.7.3: The sprite subsystem has improved.<br>
      6.7.4: The background subsystem has improved.<br>
      6.7.5: The text-drawing subsystem has improved.<br>
      6.7.6: The sprite subsystem has improved.<br>
      6.7.7: The rendering performance has increased.<br>
      6.7.8-6.7.9: The image loader has improved.<br>
      6.8: The small changes.<br>
      6.8.1: The ordinary sprite subsystem has improved.<br>
      6.8.2: The small changes.<br>
      6.8.3: An audio subsystem replaces the multimedia subsystem<br>
      6.8.4: The image loader has improved.<br>
      6.8.5: The rendering performance has increased.<br>
      6.8.6: The audio subsystem has improved.<br>
      6.8.7: The small changes.<br>
      6.8.8-6.9.1: The gamepad subsystem has improved.<br>
      6.9.2: The small changes.<br>
      6.9.3: The source code synced with the the Neon game development kit 6.2.6.<br>
      6.9.4: The sprite sheet subsystem has improved.<br>
      6.9.5: The source code synced with the the Neon game development kit 6.3.4.<br>
      6.9.6: The source code synced with the Gray game development kit 2.5.7.<br>
      6.9.7: The gamepad support has improved.<br>
      6.9.8: The source code synced with the Gray game development kit 2.6.<br>
      6.9.9: The image resizer has improved.<br>
      7.0: The source code synced with the Neon game development kit 6.3.6.<br>
      7.0.1: The image resizer has improved.<br>
      7.0.2: The small changes.<br>
      7.0.3: The small bug has been fixed.<br>
      7.0.4-7.0.6: The gamepad support has improved.<br>
      7.0.7: The small changes.<br>
      7.0.8-7.1.6: The gamepad support has improved.<br>
      7.1.7: The small changes.<br>
      7.1.8-7.2: The image resizer has improved.<br>
      7.2.1-7.2.2: The small changes.<br>
      7.2.3-7.2.4: The image resizer has improved.<br>
      7.2.5: The small changes.<br>
      7.2.6-7.2.9: The image resizer has improved.<br>
      7.3-7.3.1: The small changes.<br>
      7.3.2: The small rendering bug has been fixed.<br>
      7.3.3: The animation subsystem is backported from the Eugene game development kit 5.6.2.<br>
      7.3.4: The background subsystem has improved.<br>
      7.3.5: The small changes.<br>
      7.3.6: The source code synced with the Simple Windows Game Framework 7.3.5.<br>
      7.3.7: The image resizer has improved.<br>
      7.3.8-7.4: The experimental branch.<br>
      7.4.1: The new subsystem has been added.<br>
      7.4.2-7.4.4: The tile-map subsystem has improved.<br>
      7.4.5: The image resizer is backported from the Eugene game development kit 7.3.5.<br>
      7.4.6: The image resizer is backported from the Eugene game development kit 7.3.6.<br>
      7.4.7-7.5: The image resizer has improved.<br>
      7.5.1: The new subsystem has been added.<br>
      7.5.2: The small changes.<br>
      7.5.3: The small bug has been fixed.<br>
      7.5.4: The coordinates conversion subsystem has improved.<br>
      7.5.5: The new subsystem has been added.<br>
      7.5.6-7.5.7: The isometric subsystem has improved.<br>
      7.5.8: The coordinates conversion subsystem has improved.<br>
      7.5.9-7.6.1: The isometric subsystem has improved.<br>
      7.6.2: The tile-map subsystem has improved.<br>
      7.6.3: The image resizer is backported from the Eugene game development kit 7.4.5.<br>
      7.6.4: The small bug in the tile-map subsystem has been fixed.<br>
      7.6.5: The coordinates conversion subsystem has improved.<br>
      7.6.6: The base graphics subsystem has improved.<br>
      7.6.7-7.7.1: The image resizer has improved.<br>
      7.7.2 - 7.7.3: The small changes.<br>
      7.7.4: The small bug has been fixed.<br>
      7.7.5-7.7.6: The image resizer has improved.<br>
      7.7.7: The small changes.<br>
      7.7.8: The isometric level subsystem has improved.<br>
      7.7.9: The isometric subsystem has improved.<br>
      7.8: The small changes.<br>
      7.8.1: The isometric subsystem has improved.<br>
      7.8.2-7.8.3: The small changes.<br>
      7.8.4: The isometric level subsystem has improved.<br>
      7.8.5: The small changes.<br>
      7.8.6: The animation subsystem has improved.<br>
      7.8.7: The sprite sheet subsystem has improved.<br>
      7.8.8: The small changes.<br>
      7.8.9: The base sprite subsystem has improved.<br>
      7.9: The text drawing subsystem has improved.<br>
      7.9.1: The base sprite subsystem has improved.<br>
      7.9.2: The background subsystem has improved.<br>
      7.9.3: The new subsystem has been added.<br>
      7.9.4: The new subsystem has been added.<br>
      7.9.5-7.9.6: The small changes.<br>
      7.9.7: The base sprite subsystem has improved.<br>
      7.9.8: The image loader has improved.<br>
      7.9.9: The small changes.<br>
      8.0-8.0.2: The image resizer has improved.<br>
      8.0.3-8.0.5: The small changes.<br>
      8.0.6: The image resizer is backported from the Eugene game development kit 7.9.9.<br>
      8.0.7: The image resizer has improved.<br>
      8.0.8-8.0.9: The texture loader has improved.<br>
      8.1-8.1.1: The picture subsystem has improved.<br>
      8.1.2: The image resizer is backported from the Eugene game development kit 8.0.5.<br>
      8.1.3: The texture loader has improved.<br>
      8.1.4: The small changes.<br>
      8.1.5: The image resizer has improved.<br>
      8.1.6-8.1.7: The small changes.<br>
      8.1.8: The small bug in the tile-map subsystem has been fixed.<br>
      8.1.9: The small bug with the keyboard and mouse input subsystem has been fixed.<br>
      8.2: The ordinary sprite subsystem has improved.<br>
      8.2.1: The background subsystem has improved.<br>
      8.2.2: The rendering performance has increased.<br>
      8.2.3-8.2.8: The small changes.<br>
      8.2.9: The rendering performance has increased.<br>
      8.3: The small bug has been fixed.<br>
      8.3.1: The small changes.<br>
      8.3.2: The rendering performance has increased.<br>
      8.3.3: The animation subsystem has improved.<br>
      8.3.4: The background subsystem has improved.<br>
      8.3.5: The source code synced with the Neon game development kit 7.2.9.<br>
      8.3.6: The small changes.<br>
      8.3.7: The source code synced with the Neon game development kit 7.3.<br>
      8.3.8: The source code synced with the Neon game development kit 7.3.1.<br>
      8.3.9: The source code synced with the Neon game development kit 7.3.2.<br>
      8.4: The source code synced with the Neon game development kit 7.3.3.<br>
      8.4.1: The small changes.<br>
      8.4.2: The base graphics subsystem has improved.<br>
      8.4.3-8.4.5: The small changes.<br>
      8.4.5.1: The documentation has been updated.<br>
      8.4.6: The small changes.<br>
      8.4.7-8.4.8: The picture subsystem has improved.<br>
      8.4.9: The image loader has improved.<br>
      8.5: The small changes.<br>
      8.5.0.1: The documentation has been updated.<br>
      8.5.1-8.5.5: The small changes.<br>
      8.5.6-8.5.7: The image loader has improved.<br>
      8.5.8-8.6.4: The small changes.<br>
      8.6.5: The rendering has improved.<br>
      8.6.6: The collision detection subsystem has improved.<br>
      8.6.7-8.6.9: The small changes.<br>
      8.7: The sprite sheet subsystem has improved.<br>
      8.7.1: The small bug has been fixed.<br>
      8.7.2: The small changes.<br>
      8.7.3: The small bug has been fixed.<br>
      8.7.4: The source code synced with the Black Game Development Kit 5.6.8.<br>
      8.7.5: The source code synced with the Black Game Development Kit 5.6.9.<br>
      8.7.6-8.7.9: The small changes.<br>
      8.8: The source code synced with the Black Game Development Kit 5.7.6.<br>
      8.8.1: The synchronization timer is backported from the Neon game development kit 7.5.8.<br>
      8.8.2: The synchronization timer is backported from the Neon game development kit 7.7.7.<br>
      8.8.3: The memory subsystem has improved.<br>
      8.8.4: The small bug has been fixed.<br>
      8.8.5: The small changes.<br>
      8.8.6: The source code synced with the Black Game Development Kit 5.8.2.<br>
      8.8.7: The image resizer has improved.<br>
      8.8.8: The animation subsystem has improved.<br>
      8.8.9: The source code synced with the Black Game Development Kit 5.8.7.<br>
      8.9: The source code synced with the Black Game Development Kit 5.8.8.<br>
      8.9.0.1: The documentation has been updated.<br>
      8.9.1: The synchronization timer is backported from the Eugene game development kit 8.8.1.<br>
      8.9.2: The source code synced with the Black Game Development Kit 5.9.<br>
      8.9.3: The source code synced with the Black Game Development Kit 5.9.4.<br>
      8.9.4: The source code synced with the Black Game Development Kit 5.9.6.<br>
      8.9.5: The keyboard input subsystem is backported from the Neon game development kit 7.9.1.<br>
      8.9.6-8.9.7: The code page converter has improved.<br>
      8.9.8-8.9.9: The small changes.<br>
      9.0: The small bug has been fixed.<br>
      9.0.1: The small changes.<br>
      9.0.2: The source code synced with the Black Game Development Kit 6.0.3.<br>
      9.0.3: The small changes.<br>
      9.0.4: The base sprite subsystem has improved.<br>
      9.0.5: The background subsystem has improved.<br>
      9.0.6: The text-drawing subsystem has improved.<br>
      9.0.7-9.0.8: The small changes.<br>
      9.0.9: The image resizer has improved.<br>
      9.1: The small changes.<br>
      9.1.0.1-9.1.0.9: The documentation has been updated.<br>
      9.2: The small changes.<br>
      9.2.0.1-9.2.0.3: The documentation has been updated.<br>
      9.2.1: The image resizer has improved.<br>
      9.2.2: The small changes.<br>
      9.2.2.1: The documentation has been updated.<br>
      9.2.3: The small changes.<br>
      9.2.4: The small bug has been fixed.<br>
      9.2.4.1-9.2.4.4: The documentation has been updated.<br>
      9.2.5: The source code synced with the Gray Game Development Kit 4.2.<br>
      9.2.6-9.2.7: The text drawing subsystem has improved.<br>
      9.2.7.1: The documentation has been updated.<br>
      9.2.8: The small bug has been fixed.<br>
      9.2.9: The small changes.<br>
      9.3: The isometric subsystem has improved.<br>
      9.3.1: The new subsystem has been added.<br>
      9.3.2-9.3.5: The isometric map subsystem has improved.<br>
      9.3.6: The small changes.<br>
      9.3.7-9.3.9: The isometric level subsystem has improved.<br>
      9.4: The isometric coordinates subsystem has improved.<br>
      9.4.1: The tile map subsystem has improved.<br>
      9.4.2: The small changes.<br>
      9.4.3: The sprite sheet subsystem has improved.<br>
      9.4.4: The resource manager has improved.<br>
      9.4.5: The small changes.<br>
      9.4.6: The image resizer has improved.<br>
      9.4.7-9.4.8: The small changes.<br>
      9.4.9: The base sprite subsystem has improved.<br>
      9.5: The source code synced with the Black game development kit 6.4.7.<br>
      9.5.1: The source code synced with the Black game development kit 6.4.9.<br>
      9.5.2: The source code synced with the Black game development kit 6.5.1.<br>
      9.5.3: The small changes.<br>
      9.5.4: The parallax background subsystem has improved.<br>
      9.5.5-9.5.6: The base sprite subsystem has improved.<br>
      9.5.7: The base graphics subsystem has improved.<br>
      9.5.8: The source code synced with the Black game development kit 7.3.3.<br>
      9.5.9: The source code synced with the Black game development kit 7.3.5.<br>
      9.6: The source code synced with the Black game development kit 7.3.8.<br>
      9.6.1: The source code synced with the Black game development kit 7.3.9.<br>
      9.6.2: The small bug has been fixed.<br>
      9.6.3: The source code synced with the Black game development kit 7.4.8.<br>
    </big>
  </body>
</html>