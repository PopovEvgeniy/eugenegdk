<html>
 <head>
  <meta http-equiv="content-type" content="text/html; charset=us-ascii">
  <title>Programmer Reference</title>
 </head>
 <body>
  <div align="center"><big>Eugene Game Development Kit: Programmer Reference</big><br>
  </div>
  <big><br>
   <br>
  </big>
  <ol id="mozToc">
   <!--mozToc h1 1 h2 2 h3 3 h4 4 h5 5 h6 6-->
   <li><a href="#mozTocId368114">Part 1. Welcome</a>
    <ol>
     <li><a href="#mozTocId96569">Chapter 1. The introduction</a></li>
     <li><a href="#mozTocId619515">Chapter 2. A special thanks</a></li>
     <li><a href="#mozTocId768262">Chapter 3. The license</a></li>
     <li><a href="#mozTocId349565">Chapter 4. The system requirements</a></li>
     <li><a href="#mozTocId246473">Chapter 5. The troubleshooting guide</a></li>
     <li><a href="#mozTocId341518">Chapter 6. The compilers</a></li>
     <li><a href="#mozTocId250267">Chapter 7. The platform-specific notes</a></li>
     <li><a href="#mozTocId93850">Chapter 8. The engine namespace</a></li>
     <li><a href="#mozTocId241696">Chapter 9. The custom data types</a></li>
    </ol>
   </li>
   <li><a href="#mozTocId736492">Part 2. Basic things</a>
    <ol>
     <li><a href="#mozTocId74094">Chapter 1. The coordinate system</a></li>
     <li><a href="#mozTocId889249">Chapter 2. A game loop</a></li>
    </ol>
   </li>
   <li><a href="#mozTocId775315">Part 3. Graphics</a>
    <ol>
     <li><a href="#mozTocId660835">Chapter 1. The sub-namespace</a></li>
     <li><a href="#mozTocId307980">Chapter 2. The base graphics subsystem</a></li>
     <li><a href="#mozTocId648437">Chapter 3. The picture subsystem</a></li>
     <li><a href="#mozTocId467966">Chapter 4. The animation subsystem</a></li>
     <li><a href="#mozTocId259576">Chapter 5. The vertex index</a></li>
     <li><a href="#mozTocId555408">Chapter 6. The image kind</a></li>
     <li><a href="#mozTocId893444">Chapter 7. The ordinary background</a></li>
     <li><a href="#mozTocId910184">Chapter 8. The static background</a></li>
     <li><a href="#mozTocId807594">Chapter 9. The parallax background</a></li>
     <li><a href="#mozTocId347790">Chapter 10. The base sprite subsystem</a></li>
     <li><a href="#mozTocId156525">Chapter 11. The ordinary sprites</a></li>
     <li><a href="#mozTocId832010">Chapter 12. The static sprites</a></li>
     <li><a href="#mozTocId98487">Chapter 13. The sprite sheet</a></li>
     <li><a href="#mozTocId292221">Chapter 14. The text</a></li>
     <li><a href="#mozTocId652638">Chapter 15. Loading an image</a></li>
     <li><a href="#mozTocId265884">Chapter 16. The camera</a></li>
    </ol>
   </li>
   <li><a href="#mozTocId778712">Part 4. The transformation</a>
    <ol>
     <li><a href="#mozTocId798362">Chapter 1. The sub-namespace</a></li>
     <li><a href="#mozTocId505409">Chapter 2. The Cartesian coordinates and the screen coordinates</a></li>
     <li><a href="#mozTocId876509">Chapter 3. The Cartesian coordinates and the isometric coordinates</a></li>
     <li><a href="#mozTocId909113">Chapter 4. An isometric level</a></li>
    </ol>
   </li>
   <li><a href="#mozTocId375391">Part 5. The common things</a>
    <ol>
     <li><a href="#mozTocId633183">Chapter 1. The sub-namespace</a></li>
     <li><a href="#mozTocId673941">Chapter 2. The abnormal program termination</a></li>
     <li><a href="#mozTocId284221">Chapter 3. The timers</a></li>
     <li><a href="#mozTocId674703">Chapter 4. The collision detector</a></li>
     <li><a href="#mozTocId560876">Chapter 5. The tilemaps</a></li>
    </ol>
   </li>
   <li><a href="#mozTocId208248">Part 6. The other important things</a>
    <ol>
     <li><a href="#mozTocId605872">Chapter 1. The sub-namespace</a></li>
     <li><a href="#mozTocId893520">Chapter 2. The memory</a></li>
     <li><a href="#mozTocId995157">Chapter 3. The audio</a></li>
    </ol>
   </li>
   <li><a href="#mozTocId1450">Part 7. Misc</a>
    <ol>
     <li><a href="#mozTocId109433">Chapter 1. The Filesystem</a></li>
     <li><a href="#mozTocId260090">Chapter 2. A tool</a></li>
     <li><a href="#mozTocId256993">Chapter 3. The resource manager</a></li>
    </ol>
   </li>
   <li><a href="#mozTocId181875">Part 8. The binary files</a>
    <ol>
     <li><a href="#mozTocId706443">Chapter 1. The sub-namespace</a></li>
     <li><a href="#mozTocId168093">Chapter 2. The base binary file subsystem</a></li>
     <li><a href="#mozTocId648748">Chapter 3. The file reader</a></li>
     <li><a href="#mozTocId969117">Chapter 4. The file writer</a></li>
    </ol>
   </li>
   <li><a href="#mozTocId527362">Part 9. The input</a>
    <ol>
     <li><a href="#mozTocId524623">Chapter 1. The sub-namespace</a></li>
     <li><a href="#mozTocId190470">Chapter 2. The keyboard</a></li>
     <li><a href="#mozTocId599574">Chapter 3. The mouse</a></li>
     <li><a href="#mozTocId243934">Chapter 4. The gamepad</a></li>
    </ol>
   </li>
   <li><a href="#mozTocId41774">Part 10. The internal details of the engine subsystems</a>
    <ol>
     <li><a href="#mozTocId478780">Chapter 1. A few words for a curious programmer</a></li>
     <li><a href="#mozTocId570462">Chapter 2. The internal classes</a></li>
     <li><a href="#mozTocId338619">Chapter 3. The base graphics subsystem</a></li>
     <li><a href="#mozTocId328098">Chapter 4. The gamepad</a></li>
     <li><a href="#mozTocId304358">Chapter 5. The input</a></li>
     <li><a href="#mozTocId539190">Chapter 6. The audio</a></li>
    </ol>
   </li>
   <li><a href="#mozTocId928107">Version history</a></li>
  </ol>
  <h1><a id="mozTocId368114" class="mozTocH1"></a><big>Part 1. Welcome</big></h1>
  <h2><a id="mozTocId96569" class="mozTocH2"></a><big>Chapter 1. The introduction</big></h2>
  <big><br>
   <u>The introduction.</u><br>
   <br>
   Hello! My name is Popov Evgeniy Alekseyevich. I am an
   individual programmer. I enjoy creating software. I also like
   old-school video games. Do you want to develop video games for Microsoft
   Windows? You need a good game engine to do it. I made my own engine. I
   hope that my C++ game engine will be useful for many programmers.<br>
   <br>
   <u>Features.</u><br>
   <br>
   Let me show you the engine features. Let's go.<br>
   <br>
  </big>
  <ul>
   <li><big>Open-source code.</big></li>
   <li><big>Very fast.</big></li>
   <li><big>The easy-to-use object-oriented design.</big></li>
   <li><big>The minimum number of external dependencies: <a href="https://learn.microsoft.com/en-us/windows/win32/directx">DirectX</a>, <a href="https://opengl.org">OpenGL</a>, and the standard <a href="https://learn.microsoft.com/en-us/windows/win32/apiindex/windows-api-list">Windows API</a> libraries.</big></li>
   <li><big>You don't need to link a main program with the engine binary file. The engine is just the source code files.</big></li>
  </ul>
  <big><u><br>
    Installation.</u><br>
   <br>
   How to install this engine? Follow these steps:<br>
   <br>
   Copy these files to your project directory:<br>
   <br>
  </big>
  <ul>
   <li><big>eugenegdk.h</big></li>
   <li><big>eugenegdk.cpp</big></li>
  </ul>
  <big><br>
   Add it to your project.<br>
   Add this directive to your code: <i>#include "eugenegdk.h"</i><br>
   Yes. This is really all you need to do.<br>
  </big>
  <h2><a id="mozTocId619515" class="mozTocH2"></a><big>Chapter 2. A special thanks</big></h2>
  <big><br>
   I want to say «Big thanks for the technical consultation» to these people:<br>
   <br>
  </big>
  <ul>
   <li><a href="https://github.com/dmitrysmagin"><big>Dmitry Smagin</big></a></li>
   <li><a href="https://bsg.org.ua"><big>Pavel Samko</big></a></li>
   <li><a href="https://github.com/EXL"><big>EXL</big></a></li>
   <li><a href="http://www.almost-university.com"><big>Vladimir Mozhenkov</big></a></li>
   <li><a href="https://vk.com/strong666"><big>Vitaliy Molochkov</big></a></li>
   <li><a href="mailto:eyegem@mail.ru"><big>Evgenia Germanova</big></a></li>
   <li><big>DDMZ</big></li>
   <li><big>Anastasiya</big></li>
  </ul>
  <big><br>
   Thanks to the PVS-Studio team for the <a href="https://www.viva64.com/en/b/0614/">free license</a>.<br>
  </big>
  <h2><a id="mozTocId768262" class="mozTocH2"></a><big>Chapter 3. The license</big></h2>
  <big><br>
   <u>The Eugene Game Development Kit license.</u><br>
   <br>
   Copyright (C) 2021 – 2025 Popov Evgeniy Alekseyevich<br>
   <br>
   This software is provided 'as–is', without any express or implied<br>
   warranty. In no event will the authors be held liable for any damages<br>
   arising from the use of this software.<br>
   Permission is granted to anyone to use this software for any purpose,<br>
   including commercial applications, and to alter it and redistribute it<br>
   freely, subject to the following restrictions:<br>
   1. The origin of this software must not be misrepresented; you must not<br>
   claim that you wrote the original software. If you use this software<br>
   in a product, an acknowledgment in the product documentation would be<br>
   appreciated but is not required.<br>
   2. Altered source versions must be plainly marked as such, and must not be<br>
   misrepresented as being the original software.<br>
   3. This notice may not be removed or altered from any source distribution.<br>
   <br>
   <u>The third–party license.</u><br>
   <br>
   Copyright (c) 2007 – 2010 The Khronos Group Inc.<br>
   <br>
   Permission is hereby granted, free of charge, to any person obtaining a<br>
   copy of this software and/or associated documentation files (the<br>
   "Materials"), to deal in the Materials without restriction, including<br>
   without limitation the rights to use, copy, modify, merge, publish,<br>
   distribute, sublicense, and/or sell copies of the Materials, and to<br>
   permit persons to whom the Materials are furnished to do so, subject to<br>
   the following conditions:<br>
   The above copyright notice and this permission notice shall be included<br>
   in all copies or substantial portions of the Materials.<br>
   THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
   NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
   DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
   OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE MATERIALS OR THE
   USE OR OTHER DEALINGS IN THE MATERIALS.<br>
  </big>
  <h2><a id="mozTocId349565" class="mozTocH2"></a><big>Chapter 4. The system requirements</big></h2>
  <big><br>
   You can see the minimum system requirements below.<br>
   <br>
  </big>
  <table border="1">
   <tbody>
    <tr>
     <td><big>Operating system</big></td>
     <td><big>Windows XP or higher</big></td>
    </tr>
    <tr>
     <td><big>Minimum color depth</big></td>
     <td><big>16 bits</big></td>
    </tr>
    <tr>
     <td><big>Sound card</big></td>
     <td><big>Any sound card</big></td>
    </tr>
    <tr>
     <td colspan="1" rowspan="2"><big>Processor</big></td>
     <td><big>Intel Pentium II 400 MHz for 32-bit systems</big></td>
    </tr>
    <tr>
     <td><big>Intel Core 2 Duo for 64-bit systems</big></td>
    </tr>
   </tbody>
  </table>
  <big><br>
  </big>
  <h2><a id="mozTocId246473" class="mozTocH2"></a><big>Chapter 5. The troubleshooting guide</big></h2>
  <big><br>
   You need <a href="https://learn.microsoft.com/en-us/cpp/windows/latest-supported-vc-redist?view=msvc-170">Visual
    C++ Redistributable</a> packages if your game code is compiled under Visual C++.<br>
  </big>
  <h2><a id="mozTocId341518" class="mozTocH2"></a><big>Chapter 6. The compilers</big></h2>
  <big><br>
   This engine was successfully tested with these compilers:<br>
   <br>
  </big>
  <ul>
   <li><a href="https://jmeubank.github.io/tdm-gcc/"><big>TDM-GCC</big></a></li>
   <li><a href="http://mingw-w64.org"><big>MINGW-w64</big></a></li>
   <li><a href="http://openwatcom.org"><big>Open Watcom</big></a></li>
   <li><a href="https://open-watcom.github.io"><big>Open Watcom V2 Fork</big></a></li>
   <li><big>Visual C++ 2003</big></li>
   <li><big>Visual C++ 2005</big></li>
   <li><big>Visual C++ 2008</big></li>
   <li><big>Visual C++ 2010</big></li>
   <li><big>Visual C++ 2012</big></li>
   <li><big>Visual C++ 2013</big></li>
   <li><big>Visual C++ 2015</big></li>
   <li><big>Visual C++ 2017</big></li>
   <li><big>Visual C++ 2019</big></li>
   <li><big>Visual C++ 2022</big></li>
   <li><big>C++ Builder 2010</big></li>
   <li><big>C++ Builder XE</big></li>
   <li><big>C++ Builder XE2</big></li>
   <li><big>C++ Builder XE3</big></li>
   <li><big>C++ Builder XE4</big></li>
   <li><big>C++ Builder XE5</big></li>
   <li><big>C++ Builder XE6</big></li>
   <li><big>C++ Builder XE7</big></li>
   <li><big>C++ Builder XE8</big></li>
   <li><big>C++ Builder 10 Seattle</big></li>
   <li><big>C++ Builder 10.1 Berlin</big></li>
   <li><big>C++ Builder 10.2 Tokyo</big></li>
   <li><big>C++ Builder 10.3 Rio</big></li>
   <li><big>C++ Builder 10.4 Sydney</big></li>
   <li><big>C++ Builder 11 Alexandria</big></li>
  </ul>
  <h2><a id="mozTocId250267" class="mozTocH2"></a><big>Chapter 7. The platform-specific notes</big></h2>
  <big><u><br>
    The old processor support.<br>
   </u><br>
   You need one of the following compilers for the old processor support:<br>
   <br>
  </big>
  <ul>
   <li><big>Open Watcom</big></li>
   <li><big>Open Watcom V2 Fork</big></li>
   <li><big>Visual C++ 2003</big></li>
   <li><big>Visual C++ 2005</big></li>
  </ul>
  <big><br>
   <u>Windows XP support.</u><br>
   <br>
   You need one of the following compilers for <a href="https://en.wikipedia.org/wiki/Windows_XP">Windows XP</a> support:<br>
   <br>
  </big>
  <ul>
   <li><big>TDM–GCC</big></li>
   <li><big>Open Watcom</big></li>
   <li><big>Open Watcom V2 Fork</big></li>
   <li><big>Visual C++ 2003</big></li>
   <li><big>Visual C++ 2005</big></li>
   <li><big>Visual C++ 2008</big></li>
  </ul>
  <big><u><br>
    Windows SDK and DirectX SDK.</u><br>
   <br>
   You need <a href="https://www.microsoft.com/en-us/download/details.aspx?id=15656">Windows
    Server 2003 SP1 Platform SDK</a> and <a href="https://archive.org/details/dxsdk_feb2005">DirectX
    SDK February 2005</a> if you are using Visual C++ 2005 Express.<br>
   <u><br>
    A note for the Visual C++ users.</u><br>
   <br>
   Disable the precompiled headers before starting compilation. The old
   Visual C++ users can do it via the project creation wizard.<br>
   The Visual C++ 2017 or higher users must follow these steps:<br>
   <br>
   Go to «Project Properties — C/C++ — Precompiled Headers»<br>
   Set the «Precompiled Header» option to «Not Using Precompiled Headers».<br>
   <br>
   <u>A note for the MINGW-w64 and TDM-GCC users.</u><br>
   <br>
   Don't forget to link your program with these files:<br>
   <br>
  </big>
  <ul>
   <li><big>user32.lib</big></li>
   <li><big>kernel32.lib</big></li>
   <li><big>gdi32.lib</big></li>
   <li><big>opengl32.lib</big></li>
   <li><big>ole32.lib</big></li>
   <li><big>strmiids.lib</big></li>
   <li><big>winmm.lib</big></li>
  </ul>
  <big><br>
   See the documentation of the compiler for more information about linking.<br>
  </big>
  <h2><a id="mozTocId93850" class="mozTocH2"></a><big>Chapter 8. The engine namespace</big></h2>
  <big><br>
   <i>EUGENEGDK</i> is the main namespace. All the engine classes are declared in a few nested namespaces.<br>
  </big>
  <h2><a id="mozTocId241696" class="mozTocH2"></a><big>Chapter 9. The custom data types</big></h2>
  <big><br>
   Almost all custom data types are declared in the <i>EUGENEGDK</i> namespace.<br>
  </big>
  <h1><a id="mozTocId736492" class="mozTocH1"></a><big>Part 2. Basic things</big></h1>
  <h2><a id="mozTocId74094" class="mozTocH2"></a><big>Chapter 1. The coordinate system</big></h2>
  <big><br>
   The engine uses the standard coordinate system by default. The coordinates
   start at the top-left corner. Look at this picture to understand it.<br>
   <br>
   <img alt="" src="coordinate_system.png" height="111" width="107"><br>
  </big>
  <h2><a id="mozTocId889249" class="mozTocH2"></a><big>Chapter 2. A game loop</big></h2>
  <big><br>
   What is the main point in your game? A game loop. You can see the structure of a typical game loop below.<br>
   <br>
   <img alt="" src="game_loop.png" height="354" width="379"><br>
   <br>
  </big>
  <h1><a id="mozTocId775315" class="mozTocH1"></a><big>Part 3. Graphics</big></h1>
  <h2><a id="mozTocId660835" class="mozTocH2"></a><big>Chapter 1. The sub-namespace</big></h2>
  <big><br>
   All classes in this section are declared in the <i>Graphics</i> sub-namespace.<br>
  </big>
  <h2><a id="mozTocId307980" class="mozTocH2"></a><big>Chapter 2. The base graphics subsystem</big></h2>
  <big><br>
   <u>The introduction.</u><br>
   <br>
   The base graphics subsystem does render a game scene. This subsystem uses
   <a href="http://opengl.org">OpenGL</a> for rendering. All modern video
   cards support hardware acceleration. The software implementation
   will be activated if the acceleration is not available.<br>
   <br>
   <u>The render performance.</u><br>
   <br>
   Always use the latest video card drivers. It may increase the rendering
   performance. You can also try to change the screen resolution if you have low rendering performance.<br>
   <br>
   <u>The FPS limitation.</u><br>
   <br>
   FPS is an important thing. Many FPS are needed for a good animation, but it
   also needs high processor usage. The FPS limit is 60 by default. It has an ideal value.<br>
   <br>
   <u>Work with the base graphics subsystem.</u><br>
   <br>
   The <i>Screen</i> class provides access to the base graphics subsystem.
   Let's look at the publicly available methods.<br>
   <br>
   <i>void Screen::clear_screen(); -</i> Clear the screen. Fill it with black color.<br>
   <br>
   <i>void Screen::initialize(); -</i> Initialize the base graphic subsystem with the default screen resolution.<br>
   <i><br>
    void Screen::initialize(const unsigned int width, const unsigned int
    height); -</i> Initialize the base graphic subsystem with the custom screen resolution.<br>
   <br>
   <i>bool Screen::sync(); -</i> Show the current content of the back buffer
   on the screen. Return false if a game is terminated. This method uses the FPS limits and waits between frames.<br>
   <br>
   <i>bool Screen::update(); -</i> Show the current content of the back
   buffer on the screen. Return false if a game is terminated. This method
   ignores the FPS limit and needs high processor usage.<br>
   <i><br>
    bool Screen::sync(const bool limit); </i>- Show the current content of
   the back buffer on the screen. Return false if a game is terminated.<br>
   <i><br>
    bool Screen::is_ready(); -</i> Return true if the subsystem has already been initialized.<br>
   <br>
   <i>bool Screen::is_accelerated() const; -</i> Return true if the render is hardware-accelerated.<br>
   <br>
   <i>bool Screen::is_software() const; -</i> Return true if the software render is active.<br>
   <br>
   <i>unsigned int Screen::get_fps() const; -</i> Return the current FPS value.<br>
   <i><br>
    unsigned int Screen::get_color() const; -</i> Return the current color depth in bits per pixel.<br>
   <br>
   <i>unsigned int Screen::get_width() const; -</i> Return the screen width in pixels.<br>
   <i><br>
    unsigned int Screen::get_height() const; -</i> Return the screen height in pixels.<br>
   <i><br>
    unsigned int Screen::get_rate() const; -</i> Return the screen refresh rate.<br>
   <i><br>
    bool Screen::check_x(const unsigned int x) const; -</i> Return true if the x-coordinate is valid.<br>
   <br>
   <i>bool Screen::check_y(const unsigned int y) const; -</i> Return true if the y-coordinate is valid.<br>
   <br>
   <i>bool Screen::check_horizontal_border(const EUGENEGDK::BOX target) const; -</i> Return true if a game object has collided with the horizontal screen border.<br>
   <br>
   <i>bool Screen::check_vertical_border(const EUGENEGDK::BOX target) const; -</i> Return true if a game object has collided with the vertical screen border.<br>
   <br>
   <i>Screen *Screen::get_handle(); -</i> Return the handle to the base graphics subsystem object.<br>
  </big>
  <h2><a id="mozTocId648437" class="mozTocH2"></a><big>Chapter 3. The picture subsystem</big></h2>
  <big><u><br>
    An important subsystem.</u><br>
   <br>
   The picture subsystem implements an image storage.<br>
   <u><br>
    Work with the picture subsystem.</u><br>
   <br>
   The <i>Picture</i> class provides simple access to the picture subsystem.
   Don't use it directly. Let's look at the publicly available methods.<br>
   <i><br>
    unsigned int *Picture::get_image(); -</i> Return the handle to the image storage.<br>
   <i><br>
    void Picture::destroy_image(); -</i> Destroy an image in the storage.<br>
   <i><br>
    bool Picture::is_storage_empty() const; -</i> Return true if the storage is empty.<br>
   <i><br>
    unsigned int Picture::get_image_width() const; -</i> Return the image width in pixels.<br>
   <br>
   <i>unsigned int Picture::get_image_height() const; -</i> Return the image height in pixels.<br>
   <i><br>
    size_t Picture::get_pixel_amount() const; -</i> Return the amount of the image pixels.<br>
   <br>
   <i>size_t Picture::get_image_lenght() const; -</i> Return the image length in bytes.<br>
  </big>
  <h2><a id="mozTocId467966" class="mozTocH2"></a><big>Chapter 4. The animation subsystem</big></h2>
  <big><u><br>
    An important subsystem.</u><br>
   <br>
   The animation subsystem lets you control the animation frames.<br>
   <u><br>
    The frame index.</u><br>
   <br>
   The first frame index is 1.<br>
   <br>
   <u>Work with the animation subsystem.</u><br>
   <br>
   The <i>Animation</i> class provides simple access to the animation
   subsystem. Don't use it directly. Let's look at the publicly available methods.<br>
   <br>
   <i>unsigned int Animation::get_frames() const; -</i> Return the number of the frames.<br>
   <i><br>
    unsigned int Animation::get_frame() const; -</i> Return the current frame.<br>
   <br>
   <i>bool Animation::is_last_frame() const; -</i> Return true if the current frame is the last frame.<br>
   <br>
   <i>bool Animation::check_frame(const unsigned int target) const; -</i> Return true if the target frame is valid.<br>
   <br>
  </big>
  <h2><a id="mozTocId259576" class="mozTocH2"></a><big>Chapter 5. The vertex index</big></h2>
  <big><br>
   The vertex index looks like the predefined constants. You can see it below.<br>
   <br>
  </big>
  <table style="width: 358px; height: 139px;" border="1">
   <tbody>
    <tr>
     <td><big>Vertex index<br>
      </big></td>
     <td><big>Description</big></td>
    </tr>
    <tr>
     <td><big>FIRST_VERTEX<br>
      </big></td>
     <td><big>The first vertex<br>
      </big></td>
    </tr>
    <tr>
     <td><big>SECOND_VERTEX</big></td>
     <td><big>The second vertex<br>
      </big></td>
    </tr>
    <tr>
     <td style="vertical-align: top;"><big>THIRD_VERTEX</big></td>
     <td style="vertical-align: top;"><big>The third vertex<br>
      </big></td>
    </tr>
    <tr>
     <td style="vertical-align: top;"><big>LAST_VERTEX</big></td>
     <td style="vertical-align: top;"><big>The last vertex</big></td>
    </tr>
   </tbody>
  </table>
  <big><br>
  </big>
  <h2><a id="mozTocId555408" class="mozTocH2"></a><big>Chapter 6. The image kind</big></h2>
  <big><br>
   The image types look like the predefined constants. You can see it below.<br>
   <br>
  </big>
  <table style="width: 723px; height: 106px;" border="1">
   <tbody>
    <tr>
     <td><big>Image type<br>
      </big></td>
     <td><big>Description</big></td>
    </tr>
    <tr>
     <td><big>HORIZONTAL_ANIMATED</big></td>
     <td><big>The horizontal animated background or the horizontal strip</big></td>
    </tr>
    <tr>
     <td><big>VERTICAL_ANIMATED</big></td>
     <td><big>The vertical animated background or the vertical strip</big></td>
    </tr>
   </tbody>
  </table>
  <big><br>
  </big>
  <h2><a id="mozTocId893444" class="mozTocH2"></a><big>Chapter 7. The ordinary background</big></h2>
  <big><br>
   <u>The decoration for a level.</u><br>
   <br>
   A background is a big image with a few frames. Any game has a background.
   The background will be stretched to the screen resolution before rendering
   the game scene. The background transparency is always disabled.<br>
   <br>
   The horizontal animated backgrounds look like the horizontal photo
   ribbons. The vertical animated backgrounds look like the vertical photo ribbons.<br>
   <br>
   <u>Work with the background.</u><br>
   <br>
   Just use the <i>Background</i> class to work with the background. Let's
   look at the publicly available methods.<br>
   <br>
   <i>Background *Background::get_handle(); -</i> Return the handle to the background object.<br>
   <br>
   <i>void Background::prepare(const Screen *screen); -</i> Prepare for drawing.<br>
   <i><br>
    void Background::prepare(Screen &amp;screen); -</i> Prepare for drawing.<br>
   <i><br>
    void Background::prepare(const unsigned int width, const unsigned int height); -</i> Prepare for drawing.<br>
   <br>
   <i>void Background::disable_mirror(); -</i> Disable the background mirroring mode.<br>
   <i><br>
    void Background::horizontal_mirror(); -</i> Set the horizontal background mirroring mode.<br>
   <br>
   <i>void Background::vertical_mirror(); -</i> Set the vertical background mirroring mode.<br>
   <br>
   <i>void Background::complex_mirror(); -</i> Set both the horizontal
   background mirroring mode and the vertical background mirroring mode.<br>
   <br>
   <i>bool Background::is_horizontally_mirrored(); -</i> Return true if the background is horizontally mirrored.<br>
   <br>
   <i>bool Background::is_vertically_mirrored(); -</i> Return true if the background is vertically mirrored.<br>
   <br>
   <i>bool Background::is_complex_mirrored(); -</i> Return true if the background is both horizontally and vertically mirrored.<br>      
   <br>
   <i>unsigned int Background::set_target(const unsigned int target); -</i> Set the target frame and return it.<br>
   <br>
   <i>void Background::step(); -</i> Increase the target frame. Set it to 1 if the target is more than the number of frames.<br>
   <br>
   <i>void Background::set_settings(const EUGENEGDK::IMAGE_KIND kind, const unsigned int frames); -</i> Set the background settings.<br>
   <br>
   <i>bool Background::load(Image *background, const EUGENEGDK::IMAGE_KIND
    kind, const unsigned int frames); -</i> Load a background from the buffer and return true if it is loaded.<br>
   <br>
   <i>bool Background::load(Image &amp;background, const EUGENEGDK::IMAGE_KIND
    kind, const unsigned int frames); -</i> Load a background from the buffer and return true if it is loaded.<br>
   <br>
   <i>bool Background::load(const char *name, const EUGENEGDK::IMAGE_KIND
    kind, const unsigned int frames); -</i> Load a background from the target file and return true if it is loaded.<br>
   <i><br>
    void Background::draw(); -</i> Draw a background.<br>
   <br>
   <i>void Background::draw(const unsigned int target); -</i> Draw the target frame.<br>
   <i><br>
    void Background::destroy_image(); -</i> Destroy a background image.<br>
   <br>
   <i>void Background::destroy(); -</i> Destroy a background image and the texture.<br>
   <br>
   <i>bool Background::is_load() const; -</i> Return true if a background has already been loaded.<br>
   <br>
   <i>bool Background::is_last_frame() const; -</i> Return true if the current frame is the last frame.<br>
   <br>
   <i>bool Background::check_frame(const unsigned int target) const; -</i>Return true if the target frame is valid.<br>
   <br>
   <i>unsigned int Background::get_frame() const; -</i> Return the current frame.<br>
   <i><br>
    unsigned int Background::get_frames() const; -</i> Return the number of the frames.<br>
   <i><br>
    unsigned int Background::get_width() const; -</i> Return the width of the background.<br>
   <i><br>
    unsigned int Background::get_height() const; -</i> Return the height of the background.<br>
   <i><br>
    EUGENEGDK::IMAGE_KIND Background::get_kind() const; -</i> Get the background kind.<br>
   <br>
   <u>A background texture</u><br>
   <br>
   The background doesn't draw if the background texture doesn't exist. It
   will be automatically created when you load an image.<br>
   <br>
   Important notice<br>
   <br>
   Always call the <i>prepare</i> after the background has been loaded.<br>
  </big>
  <h2><a id="mozTocId910184" class="mozTocH2"></a><big>Chapter 8. The static background</big></h2>
  <big><u><br>
    A few words about the static background.</u><br>
   <br>
   The static background is a simple kind of background. It contains one frame only.<br>
   <u><br>
    Work with the background.</u><br>
   <br>
   Just use the <i>Scene</i> class to work with the static background. Let's
   look at the publicly available methods.<br>
   <br>
   <i>Scene *Scene::get_handle(); -</i> Return the handle to the background object.<br>
   <i><br>
    void Scene::prepare(const Screen *screen); -</i> Prepare for drawing.<br>
   <br>
   <i>void Scene::prepare(Screen &amp;screen); -</i> Prepare for drawing.<br>
   <br>
   <i>void Scene::prepare(const unsigned int width, const unsigned int height); -</i> Prepare for drawing.<br>
   <br>
   <i>void Scene::disable_mirror(); -</i> Disable the background mirroring mode.<br>
   <br>
   <i>void Scene::horizontal_mirror(); -</i> Set the horizontal background mirroring mode.<br>
   <i><br>
    void Scene::vertical_mirror(); -</i> Set the vertical background mirroring mode.<br>
   <br>
   <i>void Scene::complex_mirror(); -</i> Set both the horizontal background
   mirroring mode and the vertical background mirroring mode.<br>
   <br>
   <i>bool Scene::is_horizontally_mirrored(); -</i> Return true if the background is horizontally mirrored.<br>
   <br>
   <i>bool Scene::is_vertically_mirrored(); -</i> Return true if the background is vertically mirrored.<br>
   <br>
   <i>bool Scene::is_complex_mirrored(); -</i> Return true if the background is both horizontally and vertically mirrored.<br>
   <br>
   <i>bool Scene::load(Image *background); -</i> Load a background from the buffer and return true if it is loaded.<br>
   <br>
   <i>bool Scene::load(Image &amp; background); -</i> Load a background from the buffer and return true if it is loaded.<br>
   <br>
   <i>bool Scene::load(const char *name); -</i> Load a background from the target file and return true if it is loaded.<br>
   <br>
   <i>void Scene::draw(); -</i> Draw a background.<br>
   <br>
   <i>void Scene::destroy_image(); -</i> Destroy a background image.<br>
   <br>
   <i>void Scene::destroy(); -</i> Destroy a background image and destroy the texture.<br>
   <br>
   <i>bool Scene::is_load() const; -</i> Return true if a static background has already been loaded.<br>
   <br>
   <i>unsigned int Scene::get_width() const; -</i> Return the width of the background.<br>
   <i><br>
    unsigned int Scene::get_height() const; -</i> Return the height of the background.<br>
   <br>
   <u>A background texture</u><br>
   <br>
   The background doesn't draw if the background texture doesn't exist. It
   will be automatically created when you load an image.<br>
   <br>
   <u>Important notice</u><br>
   <br>
   Always call the <i>prepare</i> after the background has been loaded.<br>
  </big>
  <h2><a id="mozTocId807594" class="mozTocH2"></a><big>Chapter 9. The parallax background<br></big></h2>
  <big><u><br>
    A few words about the parallax.</u><br>
   <br>
   The parallax background is a background with scrolling support.<br>
   <u><br>
    The speed.</u><br>
   <br>
   The scrolling speed should be a positive number.<br>
   <br>
   <u>Work with the background.</u><br>
   <br>
   Just use the <i>Parallax</i> class to work with the parallax background.
   Let's look at the publicly available methods.<br>
   <i><br>
    Parallax *Parallax::get_handle(); -</i> Return the handle to the background object.<br>
   <br>
   <i>void Parallax::prepare(const Screen *screen); -</i> Prepare for drawing.<br>
   <i><br>
    void Parallax::prepare(Screen &amp;screen); -</i> Prepare for drawing.<br>
   <i><br>
    void Parallax::prepare(const unsigned int width, const unsigned int height); -</i> Prepare for drawing.<br>
   <br>
   <i>void Parallax::disable_mirror(); -</i> Disable the background mirroring mode.<br>
   <i><br>
    void Parallax::horizontal_mirror(); -</i> Set the horizontal background mirroring mode.<br>
   <i><br>
    void Parallax::vertical_mirror(); -</i> Set the vertical background mirroring mode.<br>
   <br>
   <i>void Parallax::complex_mirror(); -</i> Set both the horizontal
   background mirroring mode and the vertical background mirroring mode.<br>
   <br>   
   <i>bool Parallax::is_horizontally_mirrored(); -</i> Return true if the background is horizontally mirrored.<br>
   <br>
   <i>bool Parallax::is_vertically_mirrored(); -</i> Return true if the background is vertically mirrored.<br>
   <br>
   <i>bool Parallax::is_complex_mirrored(); -</i> Return true if the background is both horizontally and vertically mirrored.<br>
   <br>   
   <i>bool Parallax::load(Image *background); -</i> Load a background from the buffer and return true if it is loaded.<br>
   <i><br>
    bool Parallax::load(Image &amp; background); -</i> Load a background from the buffer and return true if it is loaded.<br>
   <br>
   <i>bool Parallax::load(const char *name); -</i> Load a background from the target file and return true if it is loaded.<br>
   <br>
   <i>void Parallax::set_horizontal_speed(const float speed); -</i> Set the horizontal scrolling speed.<br>
   <br>
   <i>void Parallax::set_vertical_speed(const float speed); -</i> Set the vertical scrolling speed.<br>
   <br>
   <i>void Parallax::set_speed(const float horizontal, const float vertical); -</i> Set the scrolling speed.<br>
   <br>
   <i>float Parallax::get_horizontal_speed() const; -</i> Return the horizontal speed.<br>
   <i><br>
    float Parallax::get_vertical_speed() const; -</i> Return the vertical speed.<br>
   <br>
   <i>void Parallax::draw(); -</i> Draw a background.<br>
   <br>
   <i>void Parallax::destroy_image(); -</i> Destroy a background image.<br>
   <br>
   <i>void Parallax::destroy(); -</i> Destroy a background image and destroy the texture.<br>
   <br>
   <i>bool Parallax::is_load() const; -</i> Return true if a parallax background has already been loaded.<br>
   <br>
   <i>unsigned int Parallax::get_width() const; -</i> Return the width of the background.<br>
   <br>
   <i>unsigned int Parallax::get_height() const; -</i> Return the height of the background.<br>
   <u><br>
    A background texture.</u><br>
   <br>
   The background doesn't draw if the background texture doesn't exist. It
   will be automatically created when you load an image.<br>
   <br>
   <u>An important notice.</u><br>
   <br>
   Always call the <i>prepare</i> after the background has been loaded.<br>
  </big>
  <h2><a id="mozTocId347790" class="mozTocH2"></a><big>Chapter 10. The base sprite subsystem</big></h2>
  <big><u><br>
    A small, important thing.</u><br>
   <br>
   A sprite is a transparent image. It is useful for many things: enemies, bonuses, etc.<br>
   <u><br>
    Work with the base sprite subsystem.</u><br>
   <br>
   The <i>Billboard</i> class provides simple access to the base sprite
   subsystem. Don't use it directly. Let's look at the publicly available methods.<br>
   <br>
   <i>void Billboard::set_texture_coordinates(const EUGENEGDK::VERTEX_INDEX
    index, const float u, const float v); -</i> Set the texture coordinates.<br>
   <br>
   <i>void Billboard::set_transparent(const bool enabled); -</i> Enable or disable the transparent mode.<br>
   <br>
   <i>bool Billboard::get_transparent() const; -</i> Return true if the transparent mode is enabled.<br>
   <br>
   <i>void Billboard::set_position(const unsigned int x, const unsigned int y); -</i> Set the sprite position.<br>
   <br>
   <i>void Billboard::set_start(const unsigned int x, const unsigned int y); -</i> Set the start position of the sprite.<br>
   <br>
   <i>void Billboard::set_size(const unsigned int width, const unsigned int height); -</i> Change the sprite size.<br>
   <br>
   <i>void Billboard::set_x(const unsigned int x); -</i> Set the x-coordinate of the sprite position.<br>
   <br>
   <i>void Billboard::set_y(const unsigned int y); -</i> Set the y-coordinate of the sprite position.<br>
   <i><br>
    void Billboard::set_width(const unsigned int width); -</i> Change the sprite width.<br>
   <br>
   <i>void Billboard::set_height(const unsigned int height); -</i> Change the sprite height.<br>
   <br>
   <i>unsigned int Billboard::increase_x(); -</i> Increase the x-coordinate and return it.<br>
   <br>
   <i>unsigned int Billboard::decrease_x(); -</i> Decrease the x-coordinate and return it.<br>
   <br>
   <i>unsigned int Billboard::increase_y(); -</i> Increase the y-coordinate and return it.<br>
   <i><br>
    unsigned int Billboard::decrease_y(); -</i> Decrease the y-coordinate and return it.<br>
   <br>
   <i>unsigned int Billboard::increase_x(const unsigned int increment); -</i> Increase the x-coordinate with the user value and return it.<br>
   <br>
   <i>unsigned int Billboard::decrease_x(const unsigned int decrement); -</i> Decrease the x-coordinate with the user value and return it.<br>
   <br>
   <i>unsigned int Billboard::increase_y(const unsigned int increment); -</i> Increase the y-coordinate with the user value and return it.<br>
   <br>
   <i>unsigned int Billboard::decrease_y(const unsigned int decrement); -</i> Decrease the y-coordinate with the user value and return it.<br>
   <br>
   <i>unsigned int Billboard::get_start_x() const; -</i> Return the x-coordinate of the start position.<br>
   <br>
   <i>unsigned int Billboard::get_start_y() const; -</i> Return the y-coordinate of the start position.<br>
   <i><br>
    unsigned int Billboard::get_x() const; -</i> Return the x-coordinate of the sprite position.<br>
   <br>
   <i>unsigned int Billboard::get_y() const; -</i> Return the y-coordinate of the sprite position.<br>
   <br>
   <i>unsigned int Billboard::get_width() const; -</i> Return the width of the sprite.<br>
   <i><br>
    unsigned int Billboard::get_height() const; -</i> Return the height of the sprite.<br>
   <br>
   <i>bool Billboard::is_load() const; -</i> Return true if the sprite has already been loaded.<br>
   <i><br>
    EUGENEGDK::BOX Billboard::get_box() const; -</i> Return the collision-related information.<br>
   <br>
   <i>void Billboard::disable_mirror(); -</i> Disable the sprite mirroring mode.<br>
   <br>
   <i>void Billboard::horizontal_mirror(); -</i> Set the horizontal sprite mirroring mode.<br>
   <i><br>
    void Billboard::vertical_mirror(); -</i> Set the vertical sprite mirroring mode.<br>
   <br>
   <i>void Billboard::complex_mirror(); -</i> Set both the horizontal sprite
   mirroring mode and the vertical sprite mirroring mode.<br>
   <br>   
   <i>bool Billboard::is_horizontally_mirrored(); -</i> Return true if the sprite is horizontally mirrored.<br>
   <br>
   <i>bool Billboard::is_vertically_mirrored(); -</i> Return true if the sprite is vertically mirrored.<br>
   <br>
   <i>bool Billboard::is_complex_mirrored(); -</i> Return true if the sprite is both horizontally and vertically mirrored.<br>
   <br>   
   <i>bool Billboard::is_mirrored(); -</i> Return true if the sprite is mirrored in any way.<br>
   <br>   
   <i>void Billboard::go_start(); -</i> Set the sprite position to the start position.<br>
   <br>
   <i>void Billboard::go_start_x(); -</i> Set the x-coordinate of the sprite position to the x-coordinate of the start position.<br>
   <br>
   <i>void Billboard::go_start_y(); -</i> Set the y-coordinate of the sprite position to the y-coordinate of the start position.<br>
   <br>
   <i>bool Billboard::draw(); -</i> Draw a sprite and return the transparent mode status.<br>
   <br>
   <i>bool Billboard::draw(const unsigned int x, const unsigned int y); -</i> Draw a sprite at the target position and return the transparent mode status.<br>
   <br>
   <i>void Billboard::draw(const bool transparency); -</i> Set the transparent mode and draw a sprite.<br>
   <br>
   <i>void Billboard::draw(const bool transparency, const unsigned int x, const unsigned int y); -</i> Set the transparent mode and draw a sprite at the target position.<br>
  </big>
  <h2><a id="mozTocId156525" class="mozTocH2"></a><big>Chapter 11. The ordinary sprites</big></h2>
  <big><br>
   <u>The sprite types.</u><br>
   <br>
   There are two kinds of ordinary sprites: the horizontal strips and the
   vertical strips. It is a small image with a few frames.<br>
   The horizontal strip looks like the horizontal photo ribbon. The vertical strip looks like the vertical photo ribbon.<br>
   <br>
   <u>Work with the sprites.</u><br>
   <br>
   Just use the <i>Sprite</i> class to work with a sprite. It is derived
   from three classes: <i>Billboard</i>, <i>Animation</i>, and <i>Picture</i>.
   Let's look at the publicly available methods.<br>
   <br>
   <i>void Sprite::set_settings(const EUGENEGDK::IMAGE_KIND kind, const unsigned int frames); -</i> Set the sprite settings.<br>
   <br>
   <i>bool Sprite::load(Image *buffer, const EUGENEGDK::IMAGE_KIND kind, const unsigned int frames); -</i> Load a sprite from the buffer and return true if it is loaded.<br>
   <br>
   <i>bool Sprite::load(Image &amp;buffer, const EUGENEGDK::IMAGE_KIND kind, const unsigned int frames); -</i> Load a sprite from the buffer and return true if it is loaded.<br>
   <br>
   <i>bool Sprite::load(const char *name, const EUGENEGDK::IMAGE_KIND kind, const unsigned int frames); -</i> Load a sprite from the target file and return true if it is loaded.<br>
   <br>
   <i>unsigned int Sprite::set_target(const unsigned int target); -</i> Set the target frame and return it.<br>
   <br>
   <i>void Sprite::step(); -</i> Increase the target frame. Set it to 1 if the target is more than the number of frames.<br>
   <br>
   <i>EUGENEGDK::IMAGE_KIND Sprite::get_kind() const; -</i> Get the sprite kind.<br>
   <i><br>
    Sprite *Sprite::get_handle(); -</i> Return the handle to the sprite object.<br>
   <i><br>
    void Sprite::clone(Sprite *target); -</i> Create a copy of the sprite if the storage of the target sprite is not empty.<br>
   <br>
   <i>void Sprite::clone(Sprite &amp;target); -</i> Create a copy of the sprite if the storage of the target sprite is not empty.<br>
   <br>
   <i>void Sprite::destroy(); -</i> Destroy a sprite image and destroy the texture.<br>
   <br>
   <u>A sprite texture</u><br>
   <br>
   A sprite doesn't draw if the sprite texture doesn't exist. It will
   automatically be created when you load or clone a sprite.<br>
  </big>
  <h2><a id="mozTocId832010" class="mozTocH2"></a><big>Chapter 12. The static sprites</big></h2>
  <big><u><br>
    A few words about the static sprites.</u><br>
   <br>
   The static sprite is a simple kind of sprite. It contains one frame only.<br>
   <u><br>
    Work with the static sprites.</u><br>
   <br>
   Just use the <i>Cartoon</i> class to work with a static sprite. It is
   derived from two classes: billboard and picture. Let's look at the publicly available methods.<br>
   <br>
   <i>bool Cartoon::load(Image *buffer); -</i> Load a sprite from the buffer and return true if it is loaded.<br>
   <i><br>
    bool Cartoon::load(Image &amp;buffer); -</i> Load a sprite from the buffer and return true if it is loaded.<br>
   <br>
   <i>bool Cartoon::load(const char *name); -</i> Load a sprite from the target file and return true if it is loaded.<br>
   <br>
   <i>Cartoon *Cartoon::get_handle(); -</i> Return the handle to the sprite object.<br>
   <br>
   <i>void Cartoon::clone(Cartoon *target); -</i> Create a copy of the sprite if the storage of the target sprite is not empty.<br>
   <br>
   <i>void Cartoon::clone(Cartoon &amp;target); -</i> Create a copy of the sprite if the storage of the target sprite is not empty.<br>
   <br>
   <i>void Cartoon::destroy(); -</i> Destroy a sprite image and the texture.<br>
   <u><br>
    A sprite texture</u><br>
   <br>
   A sprite doesn't draw if the sprite texture doesn't exist. It will
   automatically be created when you load or clone a sprite.<br>
  </big>
  <h2><a id="mozTocId98487" class="mozTocH2"></a><big>Chapter 13. The sprite sheet</big></h2>
  <big><br>
   <u>Some words about the sprite sheet.</u><br>
   <br>
   A sprite sheet is a special kind of animated sprite. Each frame has a
   fixed size. The sheet is a matrix of frames. Look at this picture to understand it.<br>
   <br>
   <img alt="" src="sheet.png" height="249" width="380"><br>
   <u><br>
    The rows and columns.</u><br>
   <br>
   The first row index is 1. The first column index is 1.<br>
   <br>
   <u>Work with the sheet.</u><br>
   <br>
   The <i>Sheet</i> class provides access to the sprite sheet subsystem. It
   is derived from three classes: <i>Billboard</i>, <i>Picture</i>, and <i>Animation</i>.
   Let's look at the publicly available methods.<br>
   <i><br>
    bool Sheet::check_row(const unsigned int target) const; -</i> Return true if the target row is valid.<br>
   <br>
   <i>bool Sheet::check_column(const unsigned int target) const; -</i> Return true if the target column is valid.<br>
   <i><br>
    unsigned int Sheet::get_row(const unsigned int target) const; -</i> Return row of the target frame.<br>
   <br>
   <i>unsigned int Sheet::get_column(const unsigned int target) const; -</i> Return column of the target frame.<br>
   <br>
   <i>unsigned int Sheet::calculate(const unsigned int row, const unsigned int column) const; -</i> Calculate the frame by row and column.<br>
   <br>
   <i>unsigned int Sheet::get_rows() const; -</i> Return the number of rows.<br>
   <br>
   <i>unsigned int Sheet::get_columns() const; -</i> Return the number of columns.<br>
   <br>
   <i>void Sheet::destroy(); -</i> Destroy a sprite sheet image and the texture.<br>
   <br>
   <i>void Sheet::select(const unsigned int row, const unsigned int column); -</i> Select the target frame by row and column.<br>
   <br>
   <i>unsigned int Sheet::set_target(const unsigned int target); -</i> Set the target frame and return it.<br>
   <br>
   <i>void Sheet::step(); -</i> Increase the target frame. Set it to 1 if the target is more than the number of frames.<br>
   <br>
   <i>bool Sheet::load(Image *sheet, const unsigned int row_amount, const unsigned int column_amount); -</i> Load a sprite sheet from the buffer and return true if it is loaded.<br>
   <br>
   <i>bool Sheet::load(Image &amp;sheet, const unsigned int row_amount, const unsigned int column_amount); -</i> Load a sprite sheet from the buffer and return true if it is loaded.<br>
   <br>
   <i>bool Sheet::load(const char *name, const unsigned int row_amount, const unsigned int column_amount); -</i> Load a sprite sheet from a target file and return true if it is loaded.<br>
   <br>
   <i>Sheet *Sheet::get_handle(); -</i> Return the handle to the sprite sheet.<br>
   <i><br>
    void Sheet::clone(Sheet *target); -</i> Create a copy of the sprite sheet if the storage of the target sprite sheet is not empty.<br>
   <br>
   <i>void Sheet::clone(Sheet &amp;target); -</i> Create a copy of the sprite sheet if the storage of the target sprite sheet is not empty.<br>
   <br>
   <u>A sprite sheet texture.</u><br>
   <br>
   A sprite sheet doesn't draw if the sprite sheet texture doesn't exist. It
   will be automatically created when you load a sheet.<br>
  </big>
  <h2><a id="mozTocId292221" class="mozTocH2"></a><big>Chapter 14. The text</big></h2>
  <big><br>
   <u>How to print a text?</u><br>
   <br>
   Just use the text subsystem to print the text. This subsystem needs a font
   for text printing. You must load a font before starting to print the text.
   The font is just a sprite sheet with 16 rows and 16 columns.<br>
   <br>
   <u>The valid characters.</u><br>
   <br>
   Only 8-bit characters are supported.<br>
   <br>
   <u>The text orientation.</u><br>
   <br>
   The text orientation looks like the predefined constants. You can see it below.<br>
   <br>
  </big>
  <table border="1" height="85" width="443">
   <tbody>
    <tr>
     <td><big>Text orientation<br>
      </big></td>
     <td><big>Description</big></td>
    </tr>
    <tr>
     <td><big>HORIZONTAL_TEXT</big></td>
     <td><big>The horizontally oriented text<br>
      </big></td>
    </tr>
    <tr>
     <td><big>VERTICAL_TEXT</big></td>
     <td><big>The vertically oriented text</big></td>
    </tr>
   </tbody>
  </table>
  <big><br>
   <u>Work with the text.</u><br>
   <br>
   The <i>Text</i> class provides a simple interface to the text subsystem.
   Let's look at the publicly available methods.<br>
   <br>
   <i>Text *Text::get_handle(); -</i> Return the handle to the text printing subsystem.<br>
   <br>
   <i>EUGENEGDK::TEXT_KIND Text::get_orientation() const; -</i> Get the current text orientation.<br>
   <br>
   <i>void Text::set_orientation(const EUGENEGDK::TEXT_KIND target); -</i> Set the current text orientation.<br>
   <br>
   <i>bool Text::is_font_load() const; -</i> Return true if the font has already been loaded.<br>
   <br>
   <i>unsigned int Text::get_font_width() const; -</i> Get the current font width in pixels.<br>
   <br>
   <i>unsigned int Text::get_font_height() const; -</i> Get the current font height in pixels.<br>
   <i><br>
    unsigned int Text::get_x() const; -</i> Get the x-coordinate of the text output position.<br>
   <br>
   <i>unsigned int Text::get_y() const; -</i> Get the y-coordinate of the text output position.<br>
   <br>
   <i>void Text::set_position(const unsigned int x, const unsigned int y); -</i> Set the output position.<br>
   <i><br>
    void Text::set_size(const unsigned int width, const unsigned int height); -</i> Change the font size.<br>
   <i><br>
    void Text::set_width(const unsigned int width); -</i> Set the font width.<br>
   <br>
   <i>void Text::set_height(const unsigned int height); -</i> Set the font height.<br>
   <br>
   <i>void Text::set_settings(const unsigned int width, const unsigned int height, const EUGENEGDK::TEXT_KIND kind); -</i> Set the text output settings.<br>
   <i><br>
    bool Text::load_font(Image *font); -</i> Load a font from the buffer and return true if it is loaded.<br>
   <br>
   <i>bool Text::load_font(Image &amp;font); -</i> Load a font from the buffer and return true if it is loaded.<br>
   <i><br>
    bool Text::load_font(const char *name); -</i> Load a font from the target file and return true if it is loaded.<br>
   <br>
   <i>void Text::print(const char target); -</i> Print a single character at the current position.<br>
   <i><br>
    void Text::print(const unsigned int x, const unsigned int y, const char target); -</i> Print a single character at the specific position.<br>
   <br>
   <i>size_t Text::print(const char *target); -</i> Print a text at the current position and return the text length.<br>
   <br>
   <i>size_t Text::print(const unsigned int x, const unsigned int y, const char *target); -</i> Print a text at the specific position and return the text length.<br>
   <br>
   <i>void Text::destroy_image(); -</i> Destroy a font image.<br>
   <br>
   <i>void Text::destroy_font(); -</i> Destroy a font image and the texture.<br>
  </big>
  <h2><a id="mozTocId652638" class="mozTocH2"></a><big>Chapter 15. Loading an image</big></h2>
  <big><u><br>
    Load an image from a file.</u><br>
   <br>
   Use the image loader to load an image from a file. The <i>Image</i> class
   provides simple access to the image loader. It is a simple class with a few methods.<br>
   <br>
   <i>unsigned char *Image::load(const char *name); -</i> Load a Truevision TGA image and return the handle to the image buffer.<br>
   <i><br>
    unsigned char *Image::get_data(); -</i> Return the handle to the image buffer.<br>
   <i><br>
    unsigned int Image::get_width() const; -</i> Return the width of the current image.<br>
   <br>
   <i>unsigned int Image::get_height() const; -</i> Return the height of the current image.<br>
   <br>
   <i>size_t Image::get_length() const; -</i> Return the length of the image buffer in bytes.<br>
   <br>
   <i>Image *Image::get_handle(); -</i> Return the handle to the image loader.<br>
   <br>
   <i>void Image::destroy_image(); -</i> Destroy the current image and free the image buffer.<br>
   <br>
   <u>An important remark.</u><br>
   <br>
   A new image will replace the current image if the current image already
   exists. An incorrect image will be ignored and won't load.<br>
   The source image will be converted to <a href="https://en.wikipedia.org/wiki/RGBA">RGBA</a>
   format. The pixels equal to the top-left pixel will be marked as transparent.<br>
   <u><br>
    The supported format.</u><br>
   <br>
   All loading images must have the correct specifications. You can load an
   image from a 24-bit <a href="https://en.wikipedia.org/wiki/Truevision_TGA">Truevision TGA</a> picture.<br>
   <br>
   <u>The recommended software.</u><br>
   <br>
   You can use a wide range of graphics software to convert your images to
   the correct format. I recommend using <a href="https://www.gimp.org">GIMP</a>
   to do it. It is a powerful image editor.<br>
  </big>
  <h2><a id="mozTocId265884" class="mozTocH2"></a><big>Chapter 16. The camera</big></h2>
  <big><br>
   <u>A few words about the camera.</u><br>
   <br>
   The 2D camera defines the size of the visible area. It will be stretched
   to the screen resolution before rendering the game scene.<br>
   <br>
   <u>Work with the camera.</u><br>
   <br>
   The <i>Camera</i> class provides simple access to the camera subsystem.
   Let's look at the publicly available methods.<br>
   <i><br>
    Camera *Camera::get_handle(); -</i> Return the handle to the camera subsystem.<br>
   <br>
   <i>unsigned int Camera::increase_x(); -</i> Increase the x-coordinate of the camera offset and return it.<br>
   <br>
   <i>unsigned int Camera::decrease_x(); -</i> Decrease the x-coordinate of the camera offset and return it.<br>
   <i><br>
    unsigned int Camera::increase_y(); -</i> Increase the y-coordinate of the camera offset and return it.<br>
   <i><br>
    unsigned int Camera::decrease_y(); -</i> Decrease the y-coordinate of the camera offset and return it.<br>
   <br>
   <i>unsigned int Camera::increase_x(const unsigned int increment); -</i> Increase the x-coordinate of the camera offset with the user value and return it.<br>
   <br>
   <i>unsigned int Camera::decrease_x(const unsigned int decrement); -</i> Decrease the x-coordinate of the camera offset with the user value and return it.<br>
   <i><br>
    unsigned int Camera::increase_y(const unsigned int increment); -</i> Increase the y-coordinate of the camera offset with the user value and return it.<br>
   <i><br>
    unsigned int Camera::decrease_y(const unsigned int decrement); -</i> Decrease the y-coordinate of the camera offset with the user value and return it.<br>
   <i><br>
    unsigned int Camera::get_x() const; -</i> Return the x-coordinate of the camera offset.<br>
   <i><br>
    unsigned int Camera::get_y() const; -</i> Return the y-coordinate of the camera offset.<br>
   <br>
   <i>unsigned int Camera::get_screen_width() const; -</i> Return the screen width in pixels.<br>
   <br>
   <i>unsigned int Camera::get_screen_height() const; -</i> Return the screen height in pixels.<br>
   <br>
   <i>unsigned int Camera::get_viewport_width() const; -</i> Return the viewport width in pixels.<br>
   <br>
   <i>unsigned int Camera::get_viewport_height() const; -</i> Return the viewport height in pixels.<br>
   <br>
   <i>unsigned int Camera::get_highest_x() const; -</i> Return the highest allowable x-coordinate of the current visible area.<br>
   <i><br>
    unsigned int Camera::get_highest_y() const; -</i> Return the highest allowable y-coordinate of the current visible area.<br>
   <i><br>
    unsigned int Camera::get_highest_x_offset() const; -</i> Return the highest allowable x-offset of the camera.<br>
   <i><br>
    unsigned int Camera::get_highest_y_offset() const; -</i> Return the highest allowable y-offset of the camera.<br>
   <i><br>
    unsigned int Camera::get_world_x(const unsigned screen_int x) const; -</i> Convert the screen x-coordinate to the world x-coordinate.<br>
   <br>
   <i>unsigned int Camera::get_world_y(const unsigned screen_int y) const; -</i> Convert the screen y-coordinate to the world y-coordinate.<br>
   <br>
   <i>unsigned int Camera::set_x(const unsigned int x); -</i> Set the x-coordinate of the camera offset and return it.<br>
   <br>
   <i>unsigned int Camera::set_y(const unsigned int y); -</i> Set the y-coordinate of the camera offset and return it.<br>
   <i><br>
    void Camera::initialize(const unsigned int width, const unsigned int height); -</i> Initialize the subsystem and set the screen size.<br>
   <i><br>
    void Camera::initialize(Screen *screen); -</i> Initialize the subsystem and set the screen size.<br>
   <br>
   <i>void Camera::initialize(Screen &amp;screen); -</i> Initialize the subsystem and set the screen size.<br>
   <br>
   <i>void Camera::set_viewport(const unsigned int width, const unsigned int height); -</i> Set the viewport settings.<br>
   <br>
   <i>void Camera::set_offset(const unsigned int x, const unsigned int y); -</i> Set the camera offset.<br>
   <br>
   <i>bool Camera::check_horizontal_border(const EUGENEGDK::BOX target) const; -</i> Return true if a game object has collided with the horizontal visible area border.<br>
   <i><br>
    bool Camera::check_vertical_border(const EUGENEGDK::BOX target) const; -</i> Return true if a game object has collided with the vertical visible area border.<br>
   <i><br>
    void Camera::update(); -</i> Update the camera.<br>
   <i><br>
    void Camera::update(const unsigned int x, const unsigned int y); -</i> Set the offsets and update the camera.<br>
   <br>
   <i>void Camera::reset(); -</i> Reset the camera settings.<br>
   <br>
   <u>An important remark.</u><br>
   <br>
   Always set the viewport size after initializing the camera. Always update the camera before drawing.<br>
  </big>
  <h1><a id="mozTocId778712" class="mozTocH1"></a><big>Part 4. The transformation</big></h1>
  <h2><a id="mozTocId798362" class="mozTocH2"></a><big>Chapter 1. The sub-namespace</big></h2>
  <big><br>
   All classes in this section are declared in the <i>Transformation</i> sub-namespace.<br>
  </big>
  <h2><a id="mozTocId505409" class="mozTocH2"></a><big>Chapter 2. The Cartesian coordinates and the screen coordinates</big></h2>
  <big><br>
   <u>The Cartesian coordinates.</u><br>
   <br>
   The Cartesian coordinates start at the center of the screen. Look at this picture to understand it.<br>
   <br>
   <img alt="" src="cartesian_system.png" height="111" width="107"><br>
   <br>
   <u>The coordinates conversion.</u><br>
   <br>
   You can convert the Cartesian coordinates to the screen coordinates. You
   can also convert the screen coordinates to the Cartesian coordinates.<br>
   <br>
   Just use the <i>Coordinates</i> class to do it. Let's look at the publicly available methods.<br>
   <i><br>
    Coordinates *Coordinates::get_handle(); -</i> Return the handle to the coordinates conversion subsystem.<br>
   <br>
   <i>void Coordinates::initialize(const int viewport_width, const int viewport_height); -</i> Initialize the subsystem.<br>
   <br>
   <i>int Coordinates::get_viewport_width() const; -</i> Return the viewport width in pixels.<br>
   <br>
   <i>int Coordinates::get_viewport_height() const; -</i> Return the viewport height in pixels.<br>
   <br>
   <i>int Coordinates::get_lowest_cartesian_x() const; -</i> Return the lowest allowable Cartesian x-coordinate.<br>
   <br>
   <i>int Coordinates::get_highest_cartesian_x() const; -</i> Return the highest allowable Cartesian x-coordinate.<br>
   <i><br>
    int Coordinates::get_lowest_cartesian_y() const; -</i> Return the lowest allowable Cartesian y-coordinate.<br>
   <i><br>
    int Coordinates::get_highest_cartesian_y() const; -</i> Return the highest allowable Cartesian y-coordinate.<br>
   <br>
   <i>bool Coordinates::check_cartesian_x(const int x) const; -</i> Return true if the Cartesian x-coordinate is valid.<br>
   <br>
   <i>bool Coordinates::check_cartesian_y(const int y) const; -</i> Return true if the Cartesian y-coordinate is valid.<br>
   <i><br>
    int Coordinates::get_screen_x(const int x) const; -</i> Convert the Cartesian x-coordinate to the screen x-coordinate.<br>
   <br>
   <i>int Coordinates::get_screen_y(const int y) const; -</i> Convert the Cartesian y-coordinate to the screen y-coordinate.<br>
   <i><br>
    int Coordinates::get_cartesian_x(const int x) const; -</i> Convert the screen x-coordinate to the Cartesian x-coordinate.<br>
   <i><br>
    int Coordinates::get_cartesian_y(const int y) const; -</i> Convert the screen y-coordinate to the Cartesian y-coordinate.<br>
  </big>
  <h2><a id="mozTocId876509" class="mozTocH2"></a><big>Chapter 3. The Cartesian coordinates and the isometric coordinates</big></h2>
  <big><br>
   <u>A few words about the isometric games.</u><br>
   <br>
   <a href="https://en.wikipedia.org/wiki/Isometric_projection">Isometric
    projection</a> is a very popular way for pseudo-3D games. Many old-school games are isometric games.<br>
   <br>
   <u>The coordinates conversion.</u><br>
   <br>
   You can convert the Cartesian coordinates to the isometric coordinates.
   You can also convert the isometric coordinates to the Cartesian
   coordinates. Just use the <i>Isometric</i> class to do it. Let's look at the publicly available methods.<br>
   <br>
   <i>static int Isometric::get_isometric_x(const int x, const int y); -</i> Convert the x-coordinate from the Cartesian system to the isometric system.<br>
   <br>
   <i>static int Isometric::get_isometric_y(const int x, const int y); -</i> Convert the y-coordinate from the Cartesian system to the isometric system.<br>
   <br>
   <i>static int Isometric::get_cartesian_x(const int x, const int y); -</i> Convert the x-coordinate from the isometric system to the Cartesian system.<br>
   <br>
   <i>static int Isometric::get_cartesian_y(const int x, const int y); -</i> Convert the y-coordinate from the isometric system to the Cartesian system.<br>
  </big>
  <h2><a id="mozTocId909113" class="mozTocH2"></a><big>Chapter 4. An isometric level</big></h2>
  <big><br>
   The isometric level subsystem is intended to help you create an isometric
   level. Just use the <i>Level</i> class to do it. Let's look at the publicly available methods.<br>
   <br>
   <i>Level *Level::get_handle(); -</i> Return the handle to the isometric level subsystem.<br>
   <br>
   <i>void Level::initialize(const int tile_width, const int tile_height); -</i> Initialize the subsystem.<br>
   <br>
   <i>void Level::set_offset(const int x_offset, const int y_offset); -</i> Set the coordinates offset.<br>
   <br>
   <i>int Level::get_x_offset() const; -</i> Return the x-offset.<br>
   <br>
   <i>int Level::get_y_offset() const; -</i> Return the y-offset.<br>
   <br>
   <i>int Level::get_x(const int row, const int column) const; -</i> Return the target x-coordinate.<br>
   <br>
   <i>int Level::get_y(const int row, const int column) const; -</i> Return the target y-coordinate.<br>
  </big>
  <h1><a id="mozTocId375391" class="mozTocH1"></a><big>Part 5. The common things</big></h1>
  <h2><a id="mozTocId633183" class="mozTocH2"></a><big>Chapter 1. The sub-namespace</big></h2>
  <big><br>
   All classes in this section are declared in the <i>Common</i> sub-namespace.<br>
  </big>
  <h2><a id="mozTocId673941" class="mozTocH2"></a><big>Chapter 2. The abnormal program termination</big></h2>
  <big><br>
   You can use the <i>Halt</i> function to terminate a program. This
   function is declared in the <i>EGENEGDK</i> namespace.<br>
   <i><br>
    void EUGENEGDK::Halt(const char *message); -</i> Terminate the program. Write an error message to the log file if logging is enabled.<br>
  </big>
  <h2><a id="mozTocId284221" class="mozTocH2"></a><big>Chapter 3. The timers</big></h2>
  <big><br>
   A timer is a very useful thing. Just use the <i>Timer</i> class to work
   with the timer. Let's look at the publicly available methods.<br>
   <i><br>
    Timer *Timer::get_handle(); -</i> Return the handle to the timer.<br>
   <br>
   <i>void Timer::set_timer(const double seconds); -</i> Set the timer interval and initialize the start point.<br>
   <i><br>
    double Timer::get_interval() const; -</i> Return the current timer interval.<br>
   <br>
   <i>bool Timer::check_timer(); -</i> Return true and reinitialize the start
   point if the interval between the stop and start points is larger than or
   equal to a specific number of seconds.<br>
  </big>
  <h2><a id="mozTocId674703" class="mozTocH2"></a><big>Chapter 4. The collision detector<br>
   </big></h2>
  <big><br>
   <u>An important thing for any game.</u><br>
   <br>
   What is an important thing for a video game? A collision.<br>
   <br>
   <u>The collision details.</u><br>
   <br>
   The detector uses the bounding box collision method to detect a collision.
   The collision-related information is stored in a custom data type.<br>
   <br>
   <i>typedef struct<br>
    {<br>
    unsigned int x;<br>
    unsigned int y;<br>
    unsigned int width;<br>
    unsigned int height;<br>
    } BOX;</i><br>
   <u><br>
    Work with the collision detector.</u><br>
   <br>
   The <i>Collision</i> class provides easy access to the collision
   detectors. It is a simple class with a few methods. Let's look at the publicly available methods.<br>
   <br>
   <i>Collision *Collision::get_handle(); -</i> Return the handle to the collision detector.<br>
   <br>
   <i>void Collision::set_target(const EUGENEGDK::BOX first_target, const EUGENEGDK::BOX second_target); -</i> Set the targets for the collision detector.<br>
   <br>
   <i>bool Collision::check_collision() const; -</i> Return true if the collision between two objects is accepted.<br>
   <br>
   <i>bool Collision::check_collision(const EUGENEGDK::BOX first_target, const EUGENEGDK::BOX second_target); -</i> Set the targets and check the collision between them.<br>
  </big>
  <h2><a id="mozTocId560876" class="mozTocH2"></a><big>Chapter 5. The tilemaps</big></h2>
  <big><u><br>
    A few words about the tilemaps.</u><br>
   <br>
   The tilemap is a tile matrix. A tile is a small, non-transparent sprite. A
   tilemap is a very useful thing for the background.<br>
   <u><br>
    The rows and columns.</u><br>
   <br>
   The first row index is 0. The first column index is 0.<br>
   <u><br>
    Work with the tilemap.</u><br>
   <br>
   The <i>Tilemap</i> class provides easy access to the tilemap. It is a
   simple class with a few methods. Let's look at the publicly available methods.<br>
   <i><br>
    Tilemap *Tilemap::get_handle(); -</i> Return the handle to the tilemap subsystem.<br>
   <i><br>
    void Tilemap::initialize(const unsigned int tile_width, const unsigned int tile_height); -</i> Initialize the subsystem.<br>
   <i><br>
    unsigned int Tilemap::get_tile_width() const; -</i> Return the tile width in pixels.<br>
   <br>
   <i>unsigned int Tilemap::get_tile_height() const; -</i> Return the tile height in pixels.<br>
   <i><br>
    unsigned int Tilemap::get_x(const unsigned int row) const; -</i> Get the x-coordinate from the target row.<br>
   <i><br>
    unsigned int Tilemap::get_y(const unsigned int column) const; -</i> Get the y-coordinate from the target column.<br>
   <i><br>
    unsigned int Tilemap::get_row(const unsigned int x) const; -</i> Get the row from the x-coordinate.<br>
   <i><br>
    unsigned int Tilemap::get_column(const unsigned int y) const; -</i> Get the column from the y-coordinate.<br>
   <i><br>
    unsigned int Tilemap::get_row_amount(const unsigned int viewport_width) const; -</i> Get the maximum number of the visible rows.<br>
   <i><br>
    unsigned int Tilemap::get_column_amount(const unsigned int viewport_width) const; -</i> Get the maximum number of the visible columns.<br>
   <br>
   <i>unsigned int Tilemap::get_tile_amount(const unsigned int viewport_width, const unsigned int viewport_height) const; -</i> Get the maximum number of the visible tiles.<br>
   <i><br>
    bool Tilemap::check_row(const unsigned int row, const unsigned int viewport_width) const; -</i> Return true if the row is valid.<br>
   <i><br>
    bool Tilemap::check_column(const unsigned int column, const unsigned int viewport_height) const; -</i> Return true if the column is valid.<br>
   <br>
   <i>EUGENEGDK::BOX Tilemap::get_box(const unsigned int row, const unsigned int column) const; -</i> Return the collision-related information.<br>
  </big><br>
  <h1><a id="mozTocId208248" class="mozTocH1"></a><big>Part 6. The other important things</big></h1>
  <h2><a id="mozTocId605872" class="mozTocH2"></a><big>Chapter 1. The sub-namespace</big></h2>
  <big><br>
   All classes in this section are declared in the <i>Misc</i> sub-namespace.<br>
  </big>
  <h2><a id="mozTocId893520" class="mozTocH2"></a><big>Chapter 2. The memory</big></h2>
  <big><br>
   RAM is an important resource. Just use the <i>Memory</i> class to get the
   total memory size and the free memory size. Let's look at the publicly available methods.<br>
   <br>
   <i>unsigned long long int Memory::get_total_physical(); -</i> Return the total physical memory size in bytes.<br>
   <br>
   <i>unsigned long long int Memory::get_free_physical(); -</i> Return the free physical memory size in bytes.<br>
   <br>
   <i>unsigned long long int Memory::get_total_virtual(); -</i> Return the total <a href="https://en.wikipedia.org/wiki/Virtual_memory">virtual memory</a> size in bytes.<br>
   <br>
   <i>unsigned long long int Memory::get_free_virtual(); -</i> Return the free <a href="https://en.wikipedia.org/wiki/Virtual_memory">virtual memory</a> size in bytes.<br>
   <i><br>
    unsigned long long int Memory::get_physical_usge(); -</i> Return the physical memory usage in bytes.<br>
   <i><br>
    unsigned long long int Memory::get_virtual_usge(); -</i> Return the virtual memory usage in bytes.<br>
   <br>
   <i>unsigned long int Memory::get_usage(); -</i> Return the percentage of the physical memory used.<br>
  </big>
  <h2><a id="mozTocId995157" class="mozTocH2"></a><big>Chapter 3. The audio</big></h2>
  <big><br>
   <u>A few words about the audio subsystem.</u><br>
   <br>
   This subsystem is intended for playing music and sounds. <a href="https://en.wikipedia.org/wiki/WAV">Waveform Audio File Format</a>, 
   <a href="https://en.wikipedia.org/wiki/MP3">MPEG Audio Layer 3</a>, and <a href="https://en.wikipedia.org/wiki/Windows_Media_Audio">Windows Media Audio</a> are supported.<br>
   <br>
   <u>The additional formats.</u><br>
   <br>
   You can use an additional format if you install third-party codecs.<br>
   <br>
   <u>Working with the audio.</u><br>
   <br>
   Just use the <i>Audio</i> class to work with the audio. Let's look at the publicly available methods.<br>
   <br>
   <i>void Audio::initialize(); -</i> Initialize the subsystem.<br>
   <br>
   <i>void Audio::initialize(const char *target); -</i> Initialize the subsystem and load a sound file.<br>
   <i><br>
    void Audio::load(const char *target); -</i> Load a sound file.<br>
   <br>
   <i>void Audio::play(); -</i> Play a sound.<br>
   <br>
   <i>void Audio::play_loop(); -</i> Checking the playback status and restarting playback if needed.<br>
   <br>
   <i>void Audio::play(const bool loop); -</i> Play a sound. You can set loop mode if you want.<br>
   <br>
   <i>void Audio::stop(); -</i> Stop playing the content of the target file.<br>
   <br>
   <i>bool Audio::check_playing(); -</i> Return true if the sound resource is playing.<br>
  </big>
  <h1><a id="mozTocId1450" class="mozTocH1"></a><big>Part 7. Misc</big></h1>
  <h2><a id="mozTocId109433" class="mozTocH2"></a><big>Chapter 1. The Filesystem</big></h2>
  <big><br>
   This module is implemented as two simple functions. All these functions
   are declared in the <i>Filesystem</i> sub-namespace.<br>
   <br>
   <i>file_exist</i>: Check the target file to see if one exists.<br>
   <br>
   <i>delete_file</i>: Deletes the target file.<br>
   <br>
   All functions take the target file name as an argument and return false if the operation failed.<br>
  </big>
  <h2><a id="mozTocId260090" class="mozTocH2"></a><big>Chapter 2. A tool</big></h2>
  <big><br>
   This module is implemented as a few functions. All these functions are
   declared in the <i>Tools</i> sub-namespace.<br>
   <br>
   <i>void quit(); -</i> Exit from your program and return the user to the operating system.<br>
   <br>
   <i>bool enable_logging(const char *name); -</i> Enable redirecting error messages to a log file and return false if the operation failed.<br>
   <br>
   <i>void randomize(); -</i> Initialize the random number generator.<br>
   <i><br>
    unsigned int get_random(const unsigned int number); -</i> Return a random value between zero and the number.<br>
   <br>
   <i>unsigned int get_texture_size(); -</i> Return the maximum width or height of the texture.<br>
   <br>
   <i>EUGENEGDK::BOX generate_box(const unsigned int x, const unsigned int y, const unsigned int width, const unsigned int height); -</i> Generate the collision-related information.<br>
  </big>
  <h2><a id="mozTocId256993" class="mozTocH2"></a><big>Chapter 3. The resource manager</big></h2>
  <big><br>
   A resource is an instance of a user-defined class or structure. The
   resource manager is implemented as a few template functions. All these
   functions are declared in the <i>Resource</i> sub-namespace.<br>
   <br>
   <i>create</i>: Create a resource. The first form of this function creates a
   single resource. It takes a handle to a resource handle as an argument.
   The second form creates an array of the resources. It takes a handle to a resource handle and a resource amount.<br>
   <br>
   <i>destroy</i>: Delete a resource if it already exists. This function takes a resource handle as an argument.<br>
   <br>
   <i>destroy_array</i>: Deletes the resource array if it already exists. This function takes a resource array handle as an argument.<br>
  </big>
  <h1><a id="mozTocId181875" class="mozTocH1"></a><big>Part 8. The binary files</big></h1>
  <h2><a id="mozTocId706443" class="mozTocH2"></a><big>Chapter 1. The sub-namespace</big></h2>
  <big><br>
   All classes in this section are declared in the <i>File</i> sub-namespace.<br>
  </big>
  <h2><a id="mozTocId168093" class="mozTocH2"></a><big>Chapter 2. The base binary file subsystem</big></h2>
  <big><br>
   <u>Work with the binary files.</u><br>
   <br>
   The <i>Binary_File</i> class provides simple access to the base binary
   subsystem. Don't use it directly. Let's look at the publicly available methods.<br>
   <br>
   <i>void Binary_File::close(); -</i> Close the file.<br>
   <br>
   <i>void Binary_File::set_position(const long int offset); -</i> Set the file position.<br>
   <br>
   <i>long int Binary_File::get_position(); -</i> Return the current file position.<br>
   <br>
   <i>long int Binary_File::get_length(); -</i> Return the file length in bytes.<br>
   <br>
   <i>bool Binary_File::check_error(); -</i> Return true if the last file operation failed.<br>
   <br>
   <i>bool Binary_File::is_open() const; -</i> Return true if the file was successfully opened.<br>
   <u><br>
    An important notice.</u><br>
   <br>
   The target file size limit is 2 gigabytes.<br>
  </big>
  <h2><a id="mozTocId648748" class="mozTocH2"></a><big>Chapter 3. The file reader</big></h2>
  <big><br>
   The file reader is intended to read data from the binary files. The <i>Input_File</i>
   class provides access to a file reader. It is derived from the <i>Binary_File</i>
   class. Let's look at the publicly available methods.<br>
   <br>
   <i>Input_File* Input_File::get_handle(); -</i> Return the handle to the file reader.<br>
   <br>
   <i>void Input_File::open(const char *name); -</i> Open a file to read.<br>
   <br>
   <i>void Input_File::read(void *buffer, const size_t length); -</i> Read data from the file.<br>
  </big>
  <h2><a id="mozTocId969117" class="mozTocH2"></a><big>Chapter 4. The file writer</big></h2>
  <big><br>
   The file writer is intended to write data to the binary files. The <i>Output_File</i>
   class provides access to a file writer. It is derived from the <i>Binary_File</i>
   class. Let's look at the publicly available methods.<br>
   <br>
   <i>Output_File* Output_File::get_handle(); -</i> Return the handle to the file writer.<br>
   <i><br>
    void Output_File::open(const char *name); -</i> Open a file to write.<br>
   <br>
   <i>void Output_File::create_temp(); -</i> Create a temporary file. This file will be deleted when it is closed.<br>
   <br>
   <i>void Output_File::write(const void *buffer, const size_t length); -</i> Write data to the file.<br>
   <br>
   <i>void Output_File::flush(); -</i> Force writing the internal buffer data to the file.<br>
  </big>
  <h1><a id="mozTocId527362" class="mozTocH1"></a><big>Part 9. The input</big></h1>
  <h2><a id="mozTocId524623" class="mozTocH2"></a><big>Chapter 1. The sub-namespace</big></h2>
  <big><br>
   All classes in this section are declared in the <i>Input</i> sub-namespace.<br>
  </big>
  <h2><a id="mozTocId190470" class="mozTocH2"></a><big>Chapter 2. The keyboard</big></h2>
  <big><u><br>
    The low-level input.</u><br>
   <br>
   Any keyboard has a built-in chip. It generates a special code when the
   user presses or releases the key. This code is called a «scan code».<br>
   <br>
   <u>Working with the keyboard.</u><br>
   <br>
   Just use the <i>Keyboard</i> class to work with a keyboard. Let's look at
   the publicly available methods.<br>
   <br>
   <i>void Keyboard::initialize(); -</i> Initialize the subsystem.<br>
   <br>
   <i>bool Keyboard::check_hold(const unsigned char code); -</i> Return true if a key with a specific scan code is pressed or held.<br>
   <i><br>
    bool Keyboard::check_press(const unsigned char code); -</i> Return true if a key with a specific scan code was pressed.<br>
   <br>
   <i>bool Keyboard::check_release(const unsigned char code); -</i> Return true if a key with a specific scan code was released.<br>
   <br>
   <i>bool Keyboard::is_ready() const; -</i> Return true if the subsystem has already been initialized.<br>
   <br>
   <u>The list of the supported scan codes</u><br>
   <br>
   You can see a list of the scan codes below.<br>
   <br>
  </big>
  <table border="1">
   <tbody>
    <tr>
     <td><big>Key</big></td>
     <td><big>Code</big></td>
     <td><big>Key</big></td>
     <td><big>Code</big></td>
     <td><big>Key</big></td>
     <td><big>Code</big></td>
    </tr>
    <tr>
     <td><big>Escape</big></td>
     <td><big>1</big></td>
     <td><big>A</big></td>
     <td><big>30</big></td>
     <td><big>F1</big></td>
     <td><big>59</big></td>
    </tr>
    <tr>
     <td><big>! or 1</big></td>
     <td><big>2</big></td>
     <td><big>S</big></td>
     <td><big>31</big></td>
     <td><big>F2</big></td>
     <td><big>60</big></td>
    </tr>
    <tr>
     <td><big>@ or 2</big></td>
     <td><big>3</big></td>
     <td><big>D</big></td>
     <td><big>32</big></td>
     <td><big>F3</big></td>
     <td><big>61</big></td>
    </tr>
    <tr>
     <td><big># or 3</big></td>
     <td><big>4</big></td>
     <td><big>F</big></td>
     <td><big>33</big></td>
     <td><big>F4</big></td>
     <td><big>62</big></td>
    </tr>
    <tr>
     <td><big>$ or 4</big></td>
     <td><big>5</big></td>
     <td><big>G</big></td>
     <td><big>34</big></td>
     <td><big>F5</big></td>
     <td><big>63</big></td>
    </tr>
    <tr>
     <td><big>% or 5</big></td>
     <td><big>6</big></td>
     <td><big>H</big></td>
     <td><big>35</big></td>
     <td><big>F6</big></td>
     <td><big>64</big></td>
    </tr>
    <tr>
     <td><big>^ or 6</big></td>
     <td><big>7</big></td>
     <td><big>J</big></td>
     <td><big>36</big></td>
     <td><big>F7</big></td>
     <td><big>65</big></td>
    </tr>
    <tr>
     <td><big>&amp; or 7</big></td>
     <td><big>8</big></td>
     <td><big>K</big></td>
     <td><big>37</big></td>
     <td><big>F8</big></td>
     <td><big>66</big></td>
    </tr>
    <tr>
     <td><big>* or 8</big></td>
     <td><big>9</big></td>
     <td><big>L</big></td>
     <td><big>38</big></td>
     <td><big>F9</big></td>
     <td><big>67</big></td>
    </tr>
    <tr>
     <td><big>( or 9</big></td>
     <td><big>10</big></td>
     <td style="height: 22px;"><big>: or ;</big></td>
     <td><big>39</big></td>
     <td><big>F10</big></td>
     <td><big>68</big></td>
    </tr>
    <tr>
     <td><big>0 or )</big></td>
     <td><big>11</big></td>
     <td><big>" or '</big></td>
     <td><big>40</big></td>
     <td><big>F11</big></td>
     <td><big>133</big></td>
    </tr>
    <tr>
     <td><big>_ or |</big></td>
     <td><big>12</big></td>
     <td><big>~ or `</big></td>
     <td><big>41</big></td>
     <td><big>F12</big></td>
     <td><big>134</big></td>
    </tr>
    <tr>
     <td><big>+ or =</big></td>
     <td><big>13</big></td>
     <td><big>Left Shift</big></td>
     <td><big>42</big></td>
     <td><big>Num Lock</big></td>
     <td><big>69</big></td>
    </tr>
    <tr>
     <td><big>Backspace</big></td>
     <td><big>14</big></td>
     <td><big>| or \</big></td>
     <td><big>43</big></td>
     <td><big>Scroll Lock</big></td>
     <td><big>70</big></td>
    </tr>
    <tr>
     <td><big>Tab</big></td>
     <td><big>15</big></td>
     <td><big>Z</big></td>
     <td><big>44</big></td>
     <td><big>Home or 7</big></td>
     <td><big>71</big></td>
    </tr>
    <tr>
     <td><big>Q</big></td>
     <td><big>16</big></td>
     <td><big>X</big></td>
     <td><big>45</big></td>
     <td><big>Up or 8</big></td>
     <td><big>72</big></td>
    </tr>
    <tr>
     <td><big>W</big></td>
     <td><big>17</big></td>
     <td><big>C</big></td>
     <td><big>46</big></td>
     <td><big>Page up or 9</big></td>
     <td><big>73</big></td>
    </tr>
    <tr>
     <td><big>E</big></td>
     <td><big>18</big></td>
     <td><big>V</big></td>
     <td><big>47</big></td>
     <td><big>Gray -</big></td>
     <td><big>74</big></td>
    </tr>
    <tr>
     <td><big>R</big></td>
     <td><big>19</big></td>
     <td><big>B</big></td>
     <td><big>48</big></td>
     <td><big>Left or 4</big></td>
     <td><big>75</big></td>
    </tr>
    <tr>
     <td><big>T</big></td>
     <td><big>20</big></td>
     <td><big>N</big></td>
     <td><big>49</big></td>
     <td><big>Center or 5</big></td>
     <td><big>76</big></td>
    </tr>
    <tr>
     <td><big>Y</big></td>
     <td><big>21</big></td>
     <td><big>M</big></td>
     <td><big>50</big></td>
     <td><big>Right or 6</big></td>
     <td><big>77</big></td>
    </tr>
    <tr>
     <td><big>U</big></td>
     <td><big>22</big></td>
     <td><big>&lt; or ,</big></td>
     <td><big>51</big></td>
     <td><big>Gray +</big></td>
     <td><big>78</big></td>
    </tr>
    <tr>
     <td><big>I</big></td>
     <td><big>23</big></td>
     <td><big>&gt; or .</big></td>
     <td><big>52</big></td>
     <td><big>End or 1</big></td>
     <td style="height: 22px;"><big>79</big></td>
    </tr>
    <tr>
     <td><big>O</big></td>
     <td><big>24</big></td>
     <td><big>?</big></td>
     <td><big>53</big></td>
     <td><big>Down or 2</big></td>
     <td><big>80</big></td>
    </tr>
    <tr>
     <td><big>P</big></td>
     <td><big>25</big></td>
     <td><big>Right shift</big></td>
     <td><big>54</big></td>
     <td><big>Page down or 3</big></td>
     <td><big>81</big></td>
    </tr>
    <tr>
     <td><big>{ or [</big></td>
     <td><big>26</big></td>
     <td><big>Print Screen or *</big></td>
     <td><big>55</big></td>
     <td><big>Insert or 0</big></td>
     <td><big>82</big></td>
    </tr>
    <tr>
     <td><big>} or ]</big></td>
     <td><big>27</big></td>
     <td><big>Alt</big></td>
     <td><big>56</big></td>
     <td><big>Delete or .</big></td>
     <td><big>83</big></td>
    </tr>
    <tr>
     <td><big>Enter</big></td>
     <td><big>28</big></td>
     <td><big>Spacebar</big></td>
     <td><big>57</big></td>
     <td colspan="1" rowspan="2"><br>
      <br>
     </td>
     <td colspan="1" rowspan="2"><br>
     </td>
    </tr>
    <tr>
     <td><big>Control</big></td>
     <td><big>29</big></td>
     <td><big>Caps Lock</big></td>
     <td><big>58</big></td>
    </tr>
   </tbody>
  </table>
  <big><br>
  </big>
  <h2><a id="mozTocId599574" class="mozTocH2"></a><big>Chapter 3. The mouse</big></h2>
  <big><u><br>
    A few words about mice.</u><br>
   <br>
   A mouse is very useful for interaction with a graphical user interface.
   But the mouse can also be used in video games.<br>
   <br>
   <u>Working with the mouse.</u><br>
   <br>
   Just use the <i>Mouse</i> class to work with a mouse. Let's look at the publicly available methods.<br>
   <i><br>
    void Mouse::show(); -</i> Show the mouse cursor.<br>
   <i><br>
    void Mouse::hide(); -</i> Hide the mouse cursor.<br>
   <i><br>
    unsigned int Mouse::get_x(); -</i> Return the x-position of the mouse.<br>
   <br>
   <i>unsigned int Mouse::get_y(); -</i> Return the y-position of the mouse.<br>
   <br>
   <i>void Mouse::set_position(const unsigned int x, const unsigned int y); -</i> Set the position of the mouse.<br>
   <i><br>
    bool Mouse::check_hold(const EUGENEGDK::MOUSE_BUTTON button); -</i> Return true if a mouse button is pressed or held.<br>
   <br>
   <i>bool Mouse::check_press(const EUGENEGDK::MOUSE_BUTTON button); -</i> Return true if a mouse button was pressed.<br>
   <br>
   <i>bool Mouse::check_release(const EUGENEGDK::MOUSE_BUTTON button); -</i> Return true if a mouse button was released.<br>
   <u><br>
    The mouse buttons.</u><br>
   <br>
   The mouse button codes look like the predefined constants. You can see it below.<br>
   <br>
  </big>
  <table border="1">
   <tbody>
    <tr>
     <td><big>Mouse button code</big></td>
     <td><big>Button</big></td>
    </tr>
    <tr>
     <td><big>MOUSE_LEFT</big></td>
     <td><big>Left button</big></td>
    </tr>
    <tr>
     <td><big>MOUSE_RIGHT</big></td>
     <td><big>Right button</big></td>
    </tr>
    <tr>
     <td><big>MOUSE_MIDDLE</big></td>
     <td><big>Middle button</big></td>
    </tr>
   </tbody>
  </table>
  <big><br>
  </big>
  <h2><a id="mozTocId243934" class="mozTocH2"></a><big>Chapter 4. The gamepad</big></h2>
  <big><br>
   <u>The best friend of a retro gamer.</u><br>
   <br>
   What is a good choice for a game control device when the user plays an
   arcade or an old-school video game? A gamepad. This engine provides simple access to it.<br>
   <u><br>
    The number of the connected gamepads.</u><br>
   <br>
   You can connect a few gamepads. Any connected gamepad has an internal
   index. The first gamepad index is 0. It will be activated by default.<br>
   <br>
   <u>The ordinary button codes.</u><br>
   <br>
   The ordinary button codes look like predefined constants. The first button
   is <i>GAMEPAD_BUTTON1</i>. The last button is <i>GAMEPAD_BUTTON32</i>.<br>
   <br>
   <u>The D-pad button codes.</u><br>
   <br>
   The D-pad button codes look like the predefined constants. You can see it below.<br>
   <br>
  </big>
  <table border="1">
   <tbody>
    <tr>
     <td><big>D-pad button code</big></td>
     <td><big>D-pad button</big></td>
    </tr>
    <tr>
     <td><big>GAMEPAD_NONE</big></td>
     <td><big>None of the D-pad buttons are pressed or held down.</big></td>
    </tr>
    <tr>
     <td><big>GAMEPAD_UP</big></td>
     <td><big>D-pad up</big></td>
    </tr>
    <tr>
     <td><big>GAMEPAD_DOWN</big></td>
     <td><big>D-pad down</big></td>
    </tr>
    <tr>
     <td><big>GAMEPAD_LEFT</big></td>
     <td><big>D-pad left</big></td>
    </tr>
    <tr>
     <td><big>GAMEPAD_RIGHT</big></td>
     <td><big>D-pad right</big></td>
    </tr>
    <tr>
     <td><big>GAMEPAD_UPLEFT</big></td>
     <td><big>Both D-pad up and D-pad left</big></td>
    </tr>
    <tr>
     <td><big>GAMEPAD_UPRIGHT</big></td>
     <td><big>Both D-pad up and D-pad right</big></td>
    </tr>
    <tr>
     <td><big>GAMEPAD_DOWNLEFT</big></td>
     <td><big>Both D-pad down and D-pad left</big></td>
    </tr>
    <tr>
     <td><big>GAMEPAD_DOWNRIGHT</big></td>
     <td><big>Both D-pad down and D-pad right</big></td>
    </tr>
   </tbody>
  </table>
  <big><br>
   <u>The stick identifiers.</u><br>
   <br>
   The stick identifiers look like the predefined constants. You can see it below.<br>
   <br>
  </big>
  <table border="1">
   <tbody>
    <tr>
     <td><big>Identifiers</big></td>
     <td><big>Description</big></td>
    </tr>
    <tr>
     <td><big>GAMEPAD_LEFT_STICK</big></td>
     <td><big>Left stick</big></td>
    </tr>
    <tr>
     <td><big>GAMEPAD_RIGHT_STICK</big></td>
     <td><big>Right stick</big></td>
    </tr>
   </tbody>
  </table>
  <big><br>
   <u>The stick direction</u><br>
   <br>
   The stick direction looks like the predefined constants. You can see it below.<br>
   <br>
  </big>
  <table border="1">
   <tbody>
    <tr>
     <td><big>Value</big></td>
     <td><big>X-direction</big></td>
     <td><big>Y-direction</big></td>
    </tr>
    <tr>
     <td><big>GAMEPAD_NEUTRAL_DIRECTION</big></td>
     <td><big>Neutral</big></td>
     <td><big>Neutral</big></td>
    </tr>
    <tr>
     <td><big>GAMEPAD_POSITIVE_DIRECTION</big></td>
     <td><big>Right</big></td>
     <td><big>Up</big></td>
    </tr>
    <tr>
     <td><big>GAMEPAD_NEGATIVE_DIRECTION</big></td>
     <td><big>Left</big></td>
     <td><big>Down</big></td>
    </tr>
   </tbody>
  </table>
  <big><br>
   <u>Working with the gamepad.</u><br>
   <br>
   Just use the <i>Gamepad</i> class to work with the gamepad. Let's look at the publicly available methods.<br>
   <br>
   <i>unsigned int Gamepad::get_amount(); -</i> Return the number of the connected gamepads.<br>
   <i><br>
    unsigned int Gamepad::get_button_amount() const; -</i> Return the number of the gamepad buttons.<br>
   <i><br>
    unsigned int Gamepad::get_stick_amount() const; -</i> Return the number of the gamepad sticks.<br>
   <i><br>
    void Gamepad::update(); -</i> Update the internal gamepad state.<br>
   <i><br>
    void Gamepad::set_active(const unsigned int gamepad); -</i> Set the current active gamepad.<br>
   <br>
   <i>EUGENEGDK::GAMEPAD_DPAD Gamepad::get_dpad() const; -</i> Return the code of the pressed or held D-pad button.<br>
   <i><br>
    bool Gamepad::check_hold(const EUGENEGDK::GAMEPAD_BUTTONS button) const; -</i> Return true if the button is pressed or held.<br>
   <i><br>
    bool Gamepad::check_press(const EUGENEGDK::GAMEPAD_BUTTONS button) const; -</i> Return true if the button was pressed.<br>
   <br>
   <i>bool Gamepad::check_released(const EUGENEGDK::GAMEPAD_BUTTONS button) const; -</i> Return true if the button was released.<br>
   <br>
   <i>EUGENEGDK::GAMEPAD_DIRECTION Gamepad::get_stick_x(const EUGENEGDK::GAMEPAD_STICKS stick) const; -</i> Return the x-direction of a specific stick.<br>
   <i><br>
    EUGENEGDK::GAMEPAD_DIRECTION Gamepad::get_stick_y(const EUGENEGDK::GAMEPAD_STICKS stick) const; -</i> Return the y-direction of a specific stick.<br>
   <i><br>
    EUGENEGDK::GAMEPAD_DIRECTION Gamepad::get_left_stick_x() const; -</i> Return the x-direction of the left stick.<br>
   <br>
   <i>EUGENEGDK::GAMEPAD_DIRECTION Gamepad::get_left_stick_y() const; -</i> Return the y-direction of the left stick.<br>
   <i><br>
    EUGENEGDK::GAMEPAD_DIRECTION Gamepad::get_right_stick_x() const; -</i> Return the x-direction of the right stick.<br>
   <i><br>
    EUGENEGDK::GAMEPAD_DIRECTION Gamepad::get_right_stick_y() const; -</i> Return the y-direction of the right stick.<br>
  </big>
  <h1><a id="mozTocId41774" class="mozTocH1"></a><big>Part 10. The internal details of the engine subsystems</big></h1>
  <h2><a id="mozTocId478780" class="mozTocH2"></a><big>Chapter 1. A few words for a curious programmer</big></h2>
  <big><br>
   The engine subsystems have a different internal structure. It has been
   hidden from you, and you don't have access to it. Do you want to know
   about the hidden things? Just read the next chapter.<br>
  </big>
  <h2><a id="mozTocId570462" class="mozTocH2"></a><big>Chapter 2. The internal classes</big></h2>
  <big><u><br>
    The internal classes.</u><br>
   <br>
   Some classes are designed for internal use only. Don't touch them. What are these strange classes doing?<br>
   <u><br>
    Microsoft Windows-specific classes.</u><br>
   <br>
   All Microsoft Windows-specific classes are declared in the <i>Internal</i> sub-namespace.<br>
   <br>
   <i>Engine</i> creates the game window and does message processing.<br>
   <i>Synchronization</i> implements the synchronization timer.<br>
   <i>Display</i> implements the display manager.<br>
   <i>WINGL</i> contains Windows-specific OpenGL initialization code.<br>
   <u><br>
    The core classes.</u><br>
   <br>
   All engine core classes and functions are declared in the <i>Core</i> sub-namespace.<br>
   <br>
   <i>FPS</i> implements the FPS counter.<br>
   <i>Unicode_Converter</i> implements the system code page to UTF-16 converter.<br>
   <i>Render</i> implements the OpenGL render.<br>
   <i>Resizer</i> is intended to calculate the correct texture size.<br>
   <i>Rectangle</i> is intended to draw a textured rectangle.<br>
   <i>Shape</i> is the base class of the <i>Rectangle</i> class.<br>
  </big>
  <h2><a id="mozTocId338619" class="mozTocH2"></a><big>Chapter 3. The base graphics subsystem</big></h2>
  <big><u><br>
    The visible object.</u><br>
   <br>
   Any visible object is a textured rectangle.<br>
   <br>
   <u>The textures.</u><br>
   <br>
   A texture width must be a power of two. A texture height also must be a
   power of two. Any image will be automatically resized before uploading.<br>
   <u><br>
    The vertex arrays and the texture coordinates array.</u><br>
   <br>
   Any rectangle needs four vertices and four texture coordinates.<br>
   A single vertex represents the following custom data type:<br>
   <br>
   <i>typedef struct Vertex<br>
    {<br>
    int x;<br>
    int y;<br>
    };</i><br>
   <br>
   A single texture coordinate represents the following custom data type:<br>
   <br>
   <i>typedef struct<br>
    {<br>
    float u;<br>
    float v;<br>
    } Point;</i><br>
   <br>
   All these custom types are declared in the <i>Core</i> sub-namespace.<br>
  </big>
  <h2><a id="mozTocId328098" class="mozTocH2"></a><big>Chapter 4. The gamepad</big></h2>
  <big><br>
   The gamepad subsystem is working over the <a href="https://msdn.microsoft.com/ru-ru/library/windows/desktop/dd757116%28v=vs.85%29.aspx">Joystick Multimedia API</a>.<br>
  </big>
  <h2><a id="mozTocId304358" class="mozTocH2"></a><big>Chapter 5. The input</big></h2>
  <big><u><br>
    The input backend.</u><br>
   <br>
   The input subsystem is the simple thing. It works over the standard Microsoft Windows API.<br>
   <br>
   <u>The internal key state.</u><br>
   <br>
   The internal state of a key looks like the
   predefined constants. You can see it below.<br>
   <br>
  </big>
  <table border="1">
   <tbody>
    <tr>
     <td><big>Key/button state</big></td>
     <td><big>Description</big></td>
    </tr>
    <tr>
     <td><big>KEY_PRESSED</big></td>
     <td><big>A key or button is pressed or held.</big></td>
    </tr>
    <tr>
     <td><big>KEY_RELEASED</big></td>
     <td><big>A key or button was released.</big></td>
    </tr>
   </tbody>
  </table>
  <big><br>
  </big>
  <h2><a id="mozTocId539190" class="mozTocH2"></a><big>Chapter 6. The audio</big></h2>
  <big><br>
   The audio subsystem is working over <a href="https://docs.microsoft.com/en-us/windows/desktop/DirectShow/directshow">DirectShow</a>.
   It is available as part of <a href="https://en.wikipedia.org/wiki/DirectX">DirectX</a>.
   DirectX is pre-installed by default under the modern versions of Windows.<br>
  </big>
  <h1><a id="mozTocId928107" class="mozTocH1"></a><big>Version history</big></h1>
  <big><br>
   0.1: Initial version.<br>
   0.1.1-0.7.6: The internal unstable builds.<br>
   0.7.7: The small changes.<br>
   0.7.8: The small bug in the sprite subsystem has been fixed.<br>
   0.7.9-0.8.1: The small changes.<br>
   0.8.2: The sprite subsystem has improved.<br>
   0.8.3: PCX support has been removed.<br>
   0.8.4: The small changes.<br>
   0.8.5: The FPS counter has improved.<br>
   0.8.6-0.8.9: The small changes.<br>
   0.9: TGA support has improved.<br>
   0.9.1: The small bug in the sprite subsystem has been fixed.<br>
   0.9.2: The small changes.<br>
   0.9.3: The new subsystem has been added.<br>
   0.9.4-0.9.5: The graphic primitives subsystem has improved.<br>
   0.9.6-0.9.9: The small changes.<br>
   1.0: The base graphics subsystem has improved.<br>
   1.0.1-1.0.2: The background subsystem has improved.<br>
   1.0.3: The small changes.<br>
   1.0.4: The small bug in the sprite subsystem has been fixed.<br>
   1.0.5-1.1.4: The small changes.<br>
   1.1.5-1.1.6: The small bug has been fixed.<br>
   1.1.7: The unused dependency has been removed.<br>
   1.1.8-1.2.5: The small changes.<br>
   1.2.6: The small bug has been fixed.<br>
   1.2.7: The small changes.<br>
   1.2.8: The rendering performance has increased.<br>
   1.2.9: The Windows 2000 support has been added.<br>
   1.3: The small changes.<br>
   1.3.1: The image resizer has improved.<br>
   1.3.2: The gamepad subsystem has improved.<br>
   1.3.3: The project name changed.<br>
   1.3.4: The sprite subsystem has improved.<br>
   1.3.5: The small changes.<br>
   1.3.6: The tileset subsystem has improved.<br>
   1.3.7: The small changes.<br>
   1.3.8: The sprite subsystem has improved.<br>
   1.3.9: The tileset subsystem has improved.<br>
   1.4: The sprite subsystem has improved.<br>
   1.4.1: The text subsystem has improved.<br>
   1.4.2-1.4.5: The small changes.<br>
   1.4.6: The new subsystem has been added. Windows 2000 support has been removed.<br>
   1.4.7-1.4.8: The sprite subsystem has improved.<br>
   1.4.9: The text subsystem has improved.<br>
   1.5: The small changes.<br>
   1.5.1: The optional software rendering has been added.<br>
   1.5.2-1.5.7: The small changes.<br>
   1.5.8: The keyboard input has improved.<br>
   1.5.9: The mouse input has improved.<br>
   1.6: The gamepad support has improved.<br>
   1.6.1: The small bug in the gamepad subsystem has been fixed.<br>
   1.6.2: The small changes.<br>
   1.6.3: The Filesystem subsystem has improved.<br>
   1.6.4-1.6.5: The small changes.<br>
   1.6.6: The base graphics subsystem has improved.<br>
   1.6.7: The small changes.<br>
   1.6.8: The gamepad support has improved.<br>
   1.6.9-1.7: The small changes.<br>
   1.7.1: The small bug in the sprite subsystem has been fixed.<br>
   1.7.2: The graphic primitives subsystem has improved.<br>
   1.7.3-1.7.4: The small changes.<br>
   1.7.5-1.7.6: The picture subsystem has improved.<br>
   1.7.7-1.7.8: The sprite subsystem has improved.<br>
   1.7.9-1.8: The picture subsystem has improved.<br>
   1.8.1: The small changes.<br>
   1.8.2: The tileset subsystem has improved.<br>
   1.8.3: The small changes.<br>
   1.8.4-1.8.6: The binary file subsystem has improved.<br>
   1.8.7-1.8.8: The image loader has improved.<br>
   1.8.9: The small changes.<br>
   1.9-1.9.1: The image loader has improved.<br>
   1.9.2: The picture subsystem has improved.<br>
   1.9.3: The small changes.<br>
   1.9.4: The tileset subsystem has improved.<br>
   1.9.5-1.9.8: The small changes.<br>
   1.9.9: The background subsystem has improved.<br>
   2.0-2.0.3: The image loader has improved.<br>
   2.0.4: The sprite subsystem has improved.<br>
   2.0.5: The background subsystem has improved.<br>
   2.0.6-2.1.2: The text printing subsystem has improved.<br>
   2.1.3: The background subsystem has improved.<br>
   2.1.4-2.1.8: The small changes.<br>
   2.1.9-2.2.7: The multimedia subsystem has improved.<br>
   2.2.8-2.3.1: The small changes.<br>
   2.3.2-2.3.3: The base graphics subsystem has improved.<br>
   2.3.4: The synchronization timer has improved.<br>
   2.3.5-2.3.6: The small changes.<br>
   2.3.7: The multimedia subsystem has improved.<br>
   2.3.8: The keyboard input has improved.<br>
   2.3.9: The small changes.<br>
   2.4: The mouse input has improved.<br>
   2.4.1: The small changes.<br>
   2.4.2: The binary file subsystem has improved.<br>
   2.4.3-2.4.7: The small changes.<br>
   2.4.8: The background subsystem has improved.<br>
   2.4.9: The sprite subsystem has improved.<br>
   2.5: The tileset subsystem has improved.<br>
   2.5.1-2.5.2: The small changes.<br>
   2.5.3: The sprite subsystem has improved.<br>
   2.5.4-2.5.6: The tileset subsystem has improved.<br>
   2.5.7: The small changes.<br>
   2.5.8: The sprite subsystem has improved.<br>
   2.5.9-2.6: The small changes.<br>
   2.6.1: The animation subsystem has improved.<br>
   2.6.2: The background subsystem has improved.<br>
   2.6.3-2.6.4: The sprite subsystem has improved.<br>
   2.6.5: The background subsystem has improved.<br>
   2.6.6: The base graphics subsystem has improved.<br>
   2.6.7: The small changes.<br>
   2.6.8: The primitive subsystem has improved.<br>
   2.6.9: The small bug has been fixed.<br>
   2.7: The primitive subsystem was removed.<br>
   2.7.1-2.7.6: The preview release of the next branch.<br>
   2.7.7: The public release of the next branch.<br>
   2.7.8-2.7.9: The small changes.<br>
   2.8: Go back to the old stable branch.<br>
   2.8.1-2.8.5: The small changes.<br>
   2.8.6: Merge the old branch and the new branch.<br>
   2.8.7: The small bug has been fixed.<br>
   2.8.8-2.9.9: The small changes.<br>
   3.0: The basic graphics subsystem has improved.<br>
   3.0.1: The small changes.<br>
   3.0.2: The keyboard subsystem has improved.<br>
   3.0.3-3.0.5: The small changes.<br>
   3.0.6: The operating system interaction subsystem has improved.<br>
   3.0.7-3.1.1: The small changes.<br>
   3.2-3.2.1: A few changes in the engine API.<br>
   3.2.2: The small changes.<br>
   3.3: The new subsystem has been added.<br>
   3.3.1-3.3.4: The small changes.<br>
   3.3.5: The keyboard input has improved.<br>
   3.3.6: The image loader has improved.<br>
   3.3.7-3.3.8: The small changes.<br>
   3.3.9-3.4: The sprite subsystem has improved.<br>
   3.4.1: The background subsystem has improved.<br>
   3.4.2: The image storage has improved.<br>
   3.4.3: The sprite subsystem has improved.<br>
   3.4.4: The image loader has improved.<br>
   3.4.5: The image storage has improved.<br>
   3.4.6: The tileset subsystem has improved.<br>
   3.4.7: The background subsystem has improved.<br>
   3.4.8-3.4.9: The sprite subsystem has improved.<br>
   3.5-3.5.4: The small changes.<br>
   3.5.5: The tileset subsystem has improved.<br>
   3.5.6-3.6.4: The small changes.<br>
   3.6.5: The multimedia subsystem has improved.<br>
   3.6.6-3.6.8: The small changes.<br>
   3.6.9: The sprite subsystem has improved.<br>
   3.7: The background subsystem has improved.<br>
   3.7.1: The small changes.<br>
   3.7.2: The binary file subsystem has improved.<br>
   3.7.3: The background subsystem has improved.<br>
   3.7.4-3.7.5: The small changes.<br>
   3.7.6: The small bug has been fixed.<br>
   3.7.7-3.8.5: The small changes.<br>
   3.8.6: The gamepad subsystem has improved.<br>
   3.8.7-3.8.8: The small changes.<br>
   3.8.9: The image resizer has improved.<br>
   3.9-3.9.7: The small changes.<br>
   3.9.8-3.9.9: The keyboard input has improved.<br>
   4.0-4.0.1: The small changes.<br>
   4.0.2: The collision detection subsystem has improved.<br>
   4.0.3: The small bug in the collision detection subsystem has been fixed.<br>
   4.0.4: The collision detection subsystem has improved.<br>
   4.0.5-4.0.6: The small changes.<br>
   4.0.7: The new internal subsystem has been added.<br>
   4.0.8: The small changes in the engine core.<br>
   4.0.9: The image loader has improved.<br>
   4.1: The keyboard input has improved.<br>
   4.1.1: The small bug in the image loader has improved.<br>
   4.1.2: The keyboard input has improved.<br>
   4.1.3-4.2.1: The small changes.<br>
   4.2.2: The image resizer has improved.<br>
   4.2.3: The image storage has improved.<br>
   4.2.4: The image loader has improved.<br>
   4.2.5: The small changes.<br>
   4.2.6: The image storage has improved.<br>
   4.2.7: The mouse input has improved.<br>
   4.2.8: The keyboard input has improved.<br>
   4.2.9: The small changes.<br>
   4.3-4.3.3: The gamepad subsystem has improved.<br>
   4.3.4: The collision detection subsystem has improved.<br>
   4.3.5: The small changes.<br>
   4.3.6-4.3.8: The system interaction subsystem has improved.<br>
   4.3.9-4.4: The collision detection subsystem has improved.<br>
   4.4.1: The new subsystem has been added.<br>
   4.4.1.1: The documentation has been updated.<br>
   4.4.2: The small changes.<br>
   4.4.3-4.4.4: The new supported compiler has been added.<br>
   4.4.4.1: The documentation has been updated.<br>
   4.4.5: The small changes.<br>
   4.4.6: The new subsystem has been added.<br>
   4.4.6.1: The documentation has been updated.<br>
   4.4.7-4.4.8: The small changes.<br>
   4.4.9: The Windows 2000 support has been added.<br>
   4.4.9.1: The documentation has been updated.<br>
   4.5-4.5.3: The small changes.<br>
   4.5.4: The gamepad support has improved.<br>
   4.5.5-4.5.7: The rendering has improved.<br>
   4.5.8-4.6.2: The small changes.<br>
   4.6.3: The image resizer has improved.<br>
   4.6.4: The small changes.<br>
   4.6.5: The small bug in the binary file subsystem has been fixed.<br>
   4.6.6-4.6.8: The small changes.<br>
   4.6.9-4.7: The changes in the engine API.<br>
   4.7.0.1: The documentation has been updated.<br>
   4.7.1-4.7.2: The small changes.<br>
   4.7.3: The changes in the engine API.<br>
   4.7.4-4.8: The small changes.<br>
   4.8.1-4.8.3: The rendering has improved.<br>
   4.8.4-4.8.6: The small changes.<br>
   4.8.7: The keyboard input has improved.<br>
   4.8.8-4.8.9: The display manager has improved.<br>
   4.9-4.9.1: The small changes.<br>
   4.9.2: The display manager has improved.<br>
   4.9.3-4.9.4: The small changes.<br>
   4.9.5: The keyboard input has improved.<br>
   4.9.6: The mouse input has improved.<br>
   4.9.7-5.0.8: The small changes.<br>
   5.0.9-5.2: The experimental branch.<br>
   5.2.1: The small changes.<br>
   5.2.2: The text printing subsystem has improved.<br>
   5.2.3-5.2.5: The small changes.<br>
   5.2.6: The changes in the engine API.<br>
   5.2.7: The new subsystem has been added.<br>
   5.2.8-5.2.9: The sprite subsystem has improved.<br>
   5.3: The base sprite subsystem has improved.<br>
   5.3.1-5.3.4: The small changes.<br>
   5.3.5: The new subsystem has been added.<br>
   5.3.6: The small changes.<br>
   5.3.7: The tileset subsystem was removed.<br>
   5.3.8: The small changes.<br>
   5.3.9: The sprite sheet subsystem has improved.<br>
   5.4-5.4.1: The small changes.<br>
   5.4.2-5.4.5: The text printing subsystem has improved.<br>
   5.4.6-5.5.2: The background subsystem has improved.<br>
   5.5.3-5.5.7: The small changes.<br>
   5.5.8: The background subsystem has improved.<br>
   5.5.9: The base sprite subsystem has improved.<br>
   5.6-5.6.4: The small changes.<br>
   5.6.5: The background subsystem has improved.<br>
   5.6.6: The text printing subsystem has improved.<br>
   5.6.7: The background subsystem has improved.<br>
   5.6.8: The text printing subsystem has improved.<br>
   5.6.9: The small changes.<br>
   5.7: The text printing subsystem has improved.<br>
   5.7.1-5.7.2: The sprite sheet subsystem has improved.<br>
   5.7.3-5.7.4: The small changes.<br>
   5.7.5-5.7.6: The resource manager has improved.<br>
   5.7.7-5.8.2: The small changes.<br>
   5.8.3-5.8.5: The background subsystem has improved.<br>
   5.8.6: The small changes.<br>
   5.8.7-5.9.1: The sprite sheet subsystem has improved.<br>
   5.9.2-5.9.4: The small changes.<br>
   5.9.5: The text printing subsystem has improved.<br>
   5.9.6-5.9.8: The small changes.<br>
   5.9.9: The Windows 2000 support has been removed.<br>
   6.0: The changes in the engine API.<br>
   6.0.1: The new subsystem has been added.<br>
   6.0.2: The small changes.<br>
   6.0.3: The background subsystem and sprite subsystem have improved.<br>
   6.0.4: The small changes.<br>
   6.0.5: The picture subsystem has improved.<br>
   6.0.6-6.0.7: The small changes.<br>
   6.0.7.1: The documentation has been updated.<br>
   6.0.8: The base graphics subsystem has improved.<br>
   6.0.8.1: The documentation has been updated.<br>
   6.0.9-6.1.1: The small changes.<br>
   6.1.2: The text printing subsystem has improved.<br>
   6.1.3: The small changes.<br>
   6.1.3.1: The documentation has been updated.<br>
   6.1.4: The small bug has been fixed.<br>
   6.1.5-6.1.6: The sprite sheet subsystem has improved.<br>
   6.1.7-6.2.1: The small changes.<br>
   6.2.2-6.2.3: The base graphics subsystem has improved.<br>
   6.2.4-6.2.6: The binary file subsystem has improved.<br>
   6.2.6.1: The documentation has been updated.<br>
   6.2.7: The collision detection subsystem has improved.<br>
   6.2.8: The small bug has been fixed.<br>
   6.2.9: The small changes.<br>
   6.3: The base sprite subsystem has improved.<br>
   6.3.1-6.3.2: The small changes.<br>
   6.3.3: The base graphics subsystem is backported from the Neon Game Development Kit 5.8.4.<br>
   6.3.4: The Visual C++ 2005 support has been added.<br>
   6.3.5: The small changes.<br>
   6.3.6: The ordinary sprite subsystem has improved.<br>
   6.3.7: The sprite sheet subsystem has improved.<br>
   6.3.8: The background subsystem has improved.<br>
   6.3.9: The text printing subsystem has improved.<br>
   6.4: The small changes.<br>
   6.4.1: The collision detection subsystem has improved.<br>
   6.4.1.1: The documentation has been updated.<br>
   6.4.2: The image loader has improved.<br>
   6.4.3: The base sprite subsystem has improved.<br>
   6.4.4: The ordinary sprite subsystem has improved.<br>
   6.4.5-6.4.6: The background subsystem has improved.<br>
   6.4.7: The sprite sheet subsystem has improved.<br>
   6.4.8-6.4.9: The text printing subsystem has improved.<br>
   6.5: The ordinary sprite subsystem has improved.<br>
   6.5.1: The background subsystem has improved.<br>
   6.5.2: The sprite sheet subsystem has improved.<br>
   6.5.3-6.5.4: The text printing subsystem has improved.<br>
   6.5.5: The resource manager has improved.<br>
   6.5.6: The processor usage has reduced.<br>
   6.5.7-6.5.8: The small changes.<br>
   6.5.9: The small bug in the gamepad subsystem has been fixed.<br>
   6.6: The source code synced with the Gray Game Development Kit 2.2.7.<br>
   6.6.1: The text printing subsystem has improved.<br>
   6.6.2: The simple sound subsystem is backported from the Neon Game Development Kit 5.7.8.<br>
   6.6.3: The small bug in the multimedia subsystem has been fixed.<br>
   6.6.4-6.6.6: The small changes.<br>
   6.6.7: The multimedia subsystem has improved.<br>
   6.6.8: The simple sound subsystem has been removed.<br>
   6.6.9-6.7: The multimedia subsystem has improved.<br>
   6.7.1: The timer subsystem has improved.<br>
   6.7.2-6.7.3: The sprite subsystem has improved.<br>
   6.7.4: The background subsystem has improved.<br>
   6.7.5: The text printing subsystem has improved.<br>
   6.7.6: The sprite subsystem has improved.<br>
   6.7.7: The rendering performance has increased.<br>
   6.7.8-6.7.9: The image loader has improved.<br>
   6.8: The small changes.<br>
   6.8.1: The ordinary sprite subsystem has improved.<br>
   6.8.2: The small changes.<br>
   6.8.3: An audio subsystem replaces the multimedia subsystem.<br>
   6.8.4: The image loader has improved.<br>
   6.8.5: The rendering performance has increased.<br>
   6.8.6: The audio subsystem has improved.<br>
   6.8.7: The small changes.<br>
   6.8.8-6.9.1: The gamepad subsystem has improved.<br>
   6.9.2: The small changes.<br>
   6.9.3: The source code synced with the Neon Game Development Kit 6.2.6.<br>
   6.9.4: The sprite sheet subsystem has improved.<br>
   6.9.5: The source code synced with the Neon Game Development Kit 6.3.4.<br>
   6.9.6: The source code synced with the Gray Game Development Kit 2.5.7.<br>
   6.9.7: The gamepad support has improved.<br>
   6.9.8: The source code synced with the Gray Game Development Kit 2.6.<br>
   6.9.9: The image resizer has improved.<br>
   7.0: The source code synced with the Neon Game Development Kit 6.3.6.<br>
   7.0.1: The image resizer has improved.<br>
   7.0.2: The small changes.<br>
   7.0.3: The small bug has been fixed.<br>
   7.0.4-7.0.6: The gamepad support has improved.<br>
   7.0.7: The small changes.<br>
   7.0.8-7.1.6: The gamepad support has improved.<br>
   7.1.7: The small changes.<br>
   7.1.8-7.2: The image resizer has improved.<br>
   7.2.1-7.2.2: The small changes.<br>
   7.2.3-7.2.4: The image resizer has improved.<br>
   7.2.5: The small changes.<br>
   7.2.6-7.2.9: The image resizer has improved.<br>
   7.3-7.3.1: The small changes.<br>
   7.3.2: The small rendering bug has been fixed.<br>
   7.3.3: The animation subsystem is backported from the Eugene Game Development Kit 5.6.2.<br>
   7.3.4: The background subsystem has improved.<br>
   7.3.5: The small changes.<br>
   7.3.6: The source code synced with the Simple Windows Game Framework 7.3.5.<br>
   7.3.7: The image resizer has improved.<br>
   7.3.8-7.4: The experimental branch.<br>
   7.4.1: The new subsystem has been added.<br>
   7.4.2-7.4.4: The tilemap subsystem has improved.<br>
   7.4.5: The image resizer is backported from the Eugene Game Development Kit 7.3.5.<br>
   7.4.6: The image resizer is backported from the Eugene Game Development Kit 7.3.6.<br>
   7.4.7-7.5: The image resizer has improved.<br>
   7.5.1: The new subsystem has been added.<br>
   7.5.2: The small changes.<br>
   7.5.3: The small bug has been fixed.<br>
   7.5.4: The coordinates conversion subsystem has improved.<br>
   7.5.5: The new subsystem has been added.<br>
   7.5.6-7.5.7: The isometric subsystem has improved.<br>
   7.5.8: The coordinates conversion subsystem has improved.<br>
   7.5.9-7.6.1: The isometric subsystem has improved.<br>
   7.6.2: The tilemap subsystem has improved.<br>
   7.6.3: The image resizer is backported from the Eugene Game Development Kit 7.4.5.<br>
   7.6.4: The small bug in the tilemap subsystem has been fixed.<br>
   7.6.5: The coordinates conversion subsystem has improved.<br>
   7.6.6: The base graphics subsystem has improved.<br>
   7.6.7-7.7.1: The image resizer has improved.<br>
   7.7.2 - 7.7.3: The small changes.<br>
   7.7.4: The small bug has been fixed.<br>
   7.7.5-7.7.6: The image resizer has improved.<br>
   7.7.7: The small changes.<br>
   7.7.8: The isometric level subsystem has improved.<br>
   7.7.9: The isometric subsystem has improved.<br>
   7.8: The small changes.<br>
   7.8.1: The isometric subsystem has improved.<br>
   7.8.2-7.8.3: The small changes.<br>
   7.8.4: The isometric level subsystem has improved.<br>
   7.8.5: The small changes.<br>
   7.8.6: The animation subsystem has improved.<br>
   7.8.7: The sprite sheet subsystem has improved.<br>
   7.8.8: The small changes.<br>
   7.8.9: The base sprite subsystem has improved.<br>
   7.9: The text printing subsystem has improved.<br>
   7.9.1: The base sprite subsystem has improved.<br>
   7.9.2: The background subsystem has improved.<br>
   7.9.3: The new subsystem has been added.<br>
   7.9.4: The new subsystem has been added.<br>
   7.9.5-7.9.6: The small changes.<br>
   7.9.7: The base sprite subsystem has improved.<br>
   7.9.8: The image loader has improved.<br>
   7.9.9: The small changes.<br>
   8.0-8.0.2: The image resizer has improved.<br>
   8.0.3-8.0.5: The small changes.<br>
   8.0.6: The image resizer is backported from the Eugene Game Development Kit 7.9.9.<br>
   8.0.7: The image resizer has improved.<br>
   8.0.8-8.0.9: The texture loader has improved.<br>
   8.1-8.1.1: The picture subsystem has improved.<br>
   8.1.2: The image resizer is backported from the Eugene Game Development Kit 8.0.5.<br>
   8.1.3: The texture loader has improved.<br>
   8.1.4: The small changes.<br>
   8.1.5: The image resizer has improved.<br>
   8.1.6-8.1.7: The small changes.<br>
   8.1.8: The small bug in the tilemap subsystem has been fixed.<br>
   8.1.9: The small bug with the keyboard and mouse input subsystem has been fixed.<br>
   8.2: The ordinary sprite subsystem has improved.<br>
   8.2.1: The background subsystem has improved.<br>
   8.2.2: The rendering performance has increased.<br>
   8.2.3-8.2.8: The small changes.<br>
   8.2.9: The rendering performance has increased.<br>
   8.3: The small bug has been fixed.<br>
   8.3.1: The small changes.<br>
   8.3.2: The rendering performance has increased.<br>
   8.3.3: The animation subsystem has improved.<br>
   8.3.4: The background subsystem has improved.<br>
   8.3.5: The source code synced with the Neon Game Development Kit 7.2.9.<br>
   8.3.6: The small changes.<br>
   8.3.7: The source code synced with the Neon Game Development Kit 7.3.<br>
   8.3.8: The source code synced with the Neon Game Development Kit 7.3.1.<br>
   8.3.9: The source code synced with the Neon Game Development Kit 7.3.2.<br>
   8.4: The source code synced with the Neon Game Development Kit 7.3.3.<br>
   8.4.1: The small changes.<br>
   8.4.2: The base graphics subsystem has improved.<br>
   8.4.3-8.4.5: The small changes.<br>
   8.4.5.1: The documentation has been updated.<br>
   8.4.6: The small changes.<br>
   8.4.7-8.4.8: The picture subsystem has improved.<br>
   8.4.9: The image loader has improved.<br>
   8.5: The small changes.<br>
   8.5.0.1: The documentation has been updated.<br>
   8.5.1-8.5.5: The small changes.<br>
   8.5.6-8.5.7: The image loader has improved.<br>
   8.5.8-8.6.4: The small changes.<br>
   8.6.5: The rendering has improved.<br>
   8.6.6: The collision detection subsystem has improved.<br>
   8.6.7-8.6.9: The small changes.<br>
   8.7: The sprite sheet subsystem has improved.<br>
   8.7.1: The small bug has been fixed.<br>
   8.7.2: The small changes.<br>
   8.7.3: The small bug has been fixed.<br>
   8.7.4: The source code synced with the Black Game Development Kit 5.6.8.<br>
   8.7.5: The source code synced with the Black Game Development Kit 5.6.9.<br>
   8.7.6-8.7.9: The small changes.<br>
   8.8: The source code synced with the Black Game Development Kit 5.7.6.<br>
   8.8.1: The synchronization timer is backported from the Neon Game Development Kit 7.5.8.<br>
   8.8.2: The synchronization timer is backported from the Neon Game Development Kit 7.7.7.<br>
   8.8.3: The memory subsystem has improved.<br>
   8.8.4: The small bug has been fixed.<br>
   8.8.5: The small changes.<br>
   8.8.6: The source code synced with the Black Game Development Kit 5.8.2.<br>
   8.8.7: The image resizer has improved.<br>
   8.8.8: The animation subsystem has improved.<br>
   8.8.9: The source code synced with the Black Game Development Kit 5.8.7.<br>
   8.9: The source code synced with the Black Game Development Kit 5.8.8.<br>
   8.9.0.1: The documentation has been updated.<br>
   8.9.1: The synchronization timer is backported from the Eugene Game Development Kit 8.8.1.<br>
   8.9.2: The source code synced with the Black Game Development Kit 5.9.<br>
   8.9.3: The source code synced with the Black Game Development Kit 5.9.4.<br>
   8.9.4: The source code synced with the Black Game Development Kit 5.9.6.<br>
   8.9.5: The keyboard input subsystem is backported from the Neon Game Development Kit 7.9.1.<br>
   8.9.6-8.9.7: The code page converter has improved.<br>
   8.9.8-8.9.9: The small changes.<br>
   9.0: The small bug has been fixed.<br>
   9.0.1: The small changes.<br>
   9.0.2: The source code synced with the Black Game Development Kit 6.0.3.<br>
   9.0.3: The small changes.<br>
   9.0.4: The base sprite subsystem has improved.<br>
   9.0.5: The background subsystem has improved.<br>
   9.0.6: The text printing subsystem has improved.<br>
   9.0.7-9.0.8: The small changes.<br>
   9.0.9: The image resizer has improved.<br>
   9.1: The small changes.<br>
   9.1.0.1-9.1.0.9: The documentation has been updated.<br>
   9.2: The small changes.<br>
   9.2.0.1-9.2.0.3: The documentation has been updated.<br>
   9.2.1: The image resizer has improved.<br>
   9.2.2: The small changes.<br>
   9.2.2.1: The documentation has been updated.<br>
   9.2.3: The small changes.<br>
   9.2.4: The small bug has been fixed.<br>
   9.2.4.1-9.2.4.4: The documentation has been updated.<br>
   9.2.5: The source code synced with the Gray Game Development Kit 4.2.<br>
   9.2.6-9.2.7: The text printing subsystem has improved.<br>
   9.2.7.1: The documentation has been updated.<br>
   9.2.8: The small bug has been fixed.<br>
   9.2.9: The small changes.<br>
   9.3: The isometric subsystem has improved.<br>
   9.3.1: The new subsystem has been added.<br>
   9.3.2-9.3.5: The isometric map subsystem has improved.<br>
   9.3.6: The small changes.<br>
   9.3.7-9.3.9: The isometric level subsystem has improved.<br>
   9.4: The isometric coordinates subsystem has improved.<br>
   9.4.1: The tile map subsystem has improved.<br>
   9.4.2: The small changes.<br>
   9.4.3: The sprite sheet subsystem has improved.<br>
   9.4.4: The resource manager has improved.<br>
   9.4.5: The small changes.<br>
   9.4.6: The image resizer has improved.<br>
   9.4.7-9.4.8: The small changes.<br>
   9.4.9: The base sprite subsystem has improved.<br>
   9.5: The source code synced with the Black Game Development Kit 6.4.7.<br>
   9.5.1: The source code synced with the Black Game Development Kit 6.4.9.<br>
   9.5.2: The source code synced with the Black Game Development Kit 6.5.1.<br>
   9.5.3: The small changes.<br>
   9.5.4: The parallax background subsystem has improved.<br>
   9.5.5-9.5.6: The base sprite subsystem has improved.<br>
   9.5.7: The base graphics subsystem has improved.<br>
   9.5.8: The source code synced with the Black Game Development Kit 7.3.3.<br>
   9.5.9: The source code synced with the Black Game Development Kit 7.3.5.<br>
   9.6: The source code synced with the Black Game Development Kit 7.3.8.<br>
   9.6.1: The source code synced with the Black Game Development Kit 7.3.9.<br>
   9.6.2: The small bug has been fixed.<br>
   9.6.3: The source code synced with the Black Game Development Kit 7.4.8.<br>
   9.6.4: The source code synced with the Black Game Development Kit 7.5.<br>
   9.6.5: The source code synced with the Black Game Development Kit 7.5.1.<br>
   9.6.5.1: The documentation has been updated.<br>
   9.6.6: The source code synced with the Black Game Development Kit 7.5.2.<br>
   9.6.7-9.6.8: The small changes.<br>
   9.6.9: The base graphics subsystem has improved.<br>
   9.6.9.1-9.6.9.4: The documentation has been updated.<br>
   9.6.9.5: The project files are updated.<br>
   9.6.9.6: The documentation has been updated.<br>
   9.7: The text printing subsystem has improved.<br>
   9.7.0.1-9.7.0.6: The documentation has been updated.<br>
   9.7.1: The camera subsystem has improved.<br>
   9.7.2: The base sprite subsystem has improved.<br>
   9.7.3: The sprite subsystem has improved.<br>
   9.7.4: The background subsystem has improved.<br>
   9.7.5: The text printing subsystem has improved.<br>
   9.7.6: The rendering performance has increased.<br>
   9.7.6.1: The documentation has been updated.<br>
   9.7.7: The sprite subsystem has improved.<br>
   9.7.8: The ordinary background subsystem has improved.<br>
   9.7.9-9.8: The small changes.<br>
   9.8.1: The base sprite subsystem has improved.<br>
   9.8.2: The ordinary background subsystem has improved.<br>
   9.8.3: The static background subsystem has improved.<br>
   9.8.4: The parallax background subsystem has improved.<br>
   9.8.5: The base sprite subsystem has improved.<br>
  </big>
 </body>
</html>